<!DOCTYPE html>
<html lang="zh-Hans">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
    
    <meta name="renderer" content="webkit"/>
    <meta name="force-rendering" content="webkit"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    <script>if (/*@cc_on!@*/false || (!!window.MSInputMethodContext && !!document.documentMode)) window.location.href="https://support.dmeng.net/upgrade-your-browser.html?referrer="+encodeURIComponent(window.location.href); </script>
    
    
        <link rel="shortcut icon" href="/images/favicon.ico">
    
     
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.13.1/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/vuetify@2.2.30/dist/vuetify.min.css" rel="stylesheet">
    
<link rel="stylesheet" href="/css/main.css">

    
    
    
    
    
    
    
    
    
    
              
    
    
    
    
    
    <title>
        
            csapp-cacheLab | wwow&#39;s blog
        
    </title>
    
    
<meta name="generator" content="Hexo 5.1.1"></head>
<body>
    <div id="app">
        <v-app>
            <v-content id="page">
                <v-container fluid>
                    <v-row>
                        <v-col cols="2" class="d-none d-md-block">
                            <div id="sidebar" class="float-right">
    <a href="/" rel="home">
        <v-avatar size=96>
            <img id="logo" src="/images/avatar.webp">     
        </v-avatar> 
    </a>
    <v-divider></v-divider>
    <div class="mini-menu">
        <v-btn icon href="/">
            <v-icon>home</v-icon>
        </v-btn>
        <v-btn icon href="/categories/">
            <v-icon>folder</v-icon>
        </v-btn>
        <v-btn icon href="/tags/">
            <v-icon>bookmark</v-icon>
        </v-btn>
        <v-btn icon @click="SetNightMode">
            <v-icon>{{ nightMode }}</v-icon>
        </v-btn>
    </div>
    <v-list id="main-menu" class="font-weight-bold" flat>
        
            
            <v-list-item href="/archives/" link>
            <v-list-item-icon><v-icon>archive</v-icon></v-list-item-icon>
            <v-list-item-content>
                Archives
            </v-list-item-content>
            </v-list-item>
        
    </v-list>
    <v-divider></v-divider>
    
        <div class="post-toc">
            <a href="/2020/08/30/csapp-cacheLab/" class="toc-header">Table of Contents</a>
            <div class="toc-content">
                <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#csapp-cacheLab"><span class="toc-number">1.</span> <span class="toc-text">csapp-cacheLab</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PartA"><span class="toc-number">1.0.1.</span> <span class="toc-text">PartA</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Part-B"><span class="toc-number">1.1.</span> <span class="toc-text">Part B</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#32x32"><span class="toc-number">1.1.1.</span> <span class="toc-text">32x32</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#64x64"><span class="toc-number">1.1.2.</span> <span class="toc-text">64x64</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#61x67"><span class="toc-number">1.1.3.</span> <span class="toc-text">61x67</span></a></li></ol></li></ol></li></ol>
            </div>
        </div>
    

    <div id="footer">
        <div class="footer-social">
            
                
                <v-btn icon href="https://github.com/wwow1" target="_blank">
                    <v-icon>fab fa-github</v-icon>
                </v-btn>
            
        </div>
        <v-divider></v-divider>
        <div class="footer-content">
            
                <span id="busuanzi_container_site_uv" style="display: none;"> 
                    Total Visitors <span id="busuanzi_value_site_uv"></span>
                </span>
                <br>
            
            <span>Theme: <a target="_blank" rel="noopener" href="https://github.com/kb1000fx/hexo-theme-insulin">Insulin</a></span><br>
            <span>Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a></span><br>
            <span>
                &copy; 2015 - 2020 
                wwow
            </span>
        </div>
    </div>
</div>

                        </v-col>
                        <v-col cols="12" md="10">
                            <v-row>
  <v-col cols="12" md="8" align-self="end">
    <div id="site-header">
      <div id="site-title">
        <a href="/" rel="home">wwow&#39;s blog</a>
      </div>
      <div id="site-description">努力不一定会成功，但不努力真的很舒服</div>
      <div id="mobile-menu" class="d-block d-md-none">
        <v-text-field label="请输入关键字" data-src="search.xml" v-model="searchHeaderValue" prepend-inner-icon="search" clearable clear-icon="clear" @keydown.enter="EnterSearch(searchHeaderValue,false)"></v-text-field>
        <div class="mobile-mini-menu">
          <v-btn icon href="/">
              <v-icon>home</v-icon>
          </v-btn>
          <v-btn icon href="/categories/">
              <v-icon>folder</v-icon>
          </v-btn>
          <v-btn icon href="/tags/">
              <v-icon>bookmark</v-icon>
          </v-btn>
          <v-btn icon @click="SetNightMode">
              <v-icon>{{ nightMode }}</v-icon>
          </v-btn>
          
            
            <v-btn icon href="/archives/">
              <v-icon>archive</v-icon>
            </v-btn>
          
        </div>
      </div>    
    </div>
  </v-col>  
  <v-col cols="4" align-self="end" class="d-none d-md-block">
    <v-col align-self="end">
      <v-text-field label="请输入关键字" data-src="search.xml" v-model="searchHeaderValue" prepend-icon="search" clearable clear-icon="clear" @keydown.enter="EnterSearch(searchHeaderValue,false)"></v-text-field>
    </v-col> 
  </v-col>
</v-row>

                            <v-card class="elevation-2 post-card">
    
    
        <div class="post-header">
  <a class="post-header-title font-weight-medium" href="/2020/08/30/csapp-cacheLab/">csapp-cacheLab</a>
  <div class="post-header-meta">   
    <span>
      <v-icon color="">event</v-icon>
      Posted on:&nbsp;2020-08-30
    </span>
    <span>
      <v-icon color="">event_available</v-icon>
      Edited on:&nbsp;2020-08-30
    </span>
    <span>
      <v-icon color="">folder</v-icon>
      In:&nbsp;<a class="category-link" href="/categories/csapp/">csapp</a>
    </span>
    
    <span>
      <v-icon color="">visibility</v-icon>
      Views:&nbsp;<span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span></span>
    </span>
    
  </div>
</div>

    
    
    
    
    <div class="post-content">
        <h2 id="csapp-cacheLab"><a href="#csapp-cacheLab" class="headerlink" title="csapp-cacheLab"></a>csapp-cacheLab</h2><p>在开始实验时请认真阅读实验的指导书，其中关于实验的注意点和要求都写的非常明确，这些内容在本篇文章中不会提及。</p>
<p><a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/3e/cachelab.pdf">http://csapp.cs.cmu.edu/3e/cachelab.pdf</a></p>
<h4 id="PartA"><a href="#PartA" class="headerlink" title="PartA"></a>PartA</h4><p>第一部分要求我们编写一个cache的模拟器，通过在运行程序时提供参数确定cache的参数(E–&gt;行数，s–&gt;索引位长，b–&gt;存储块的位长)，然后顺序读取测试文件中提供的64位内存地址序列，最后输出在这一过程中的hit,miss,evicts</p>
<p>压缩包中提供了一个二进制文件csim-ref，这个文件就是我们的参照，我们程序的运行结果需要和它完全相同。</p>
<p>首先是存储cache参数的数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">cacheInfo_</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> S;  <span class="comment">//组数</span></span><br><span class="line">    <span class="keyword">int</span> E;  <span class="comment">//行数</span></span><br><span class="line">    <span class="keyword">int</span> B;  <span class="comment">//块大小（字节）</span></span><br><span class="line">    <span class="keyword">int</span> m;  <span class="comment">//物理地址位数，64</span></span><br><span class="line">    <span class="keyword">int</span> s_bit;  <span class="comment">//组索引位数</span></span><br><span class="line">    <span class="keyword">int</span> b_bit;  <span class="comment">//块偏移位数</span></span><br><span class="line">    <span class="keyword">int</span> t_bit;  <span class="comment">//标记位数</span></span><br><span class="line">&#125;cacheInfo;</span><br></pre></td></tr></table></figure>

<p>然后我们需要处理程序的命令行参数，使用getopt函数（writeup里有提示）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>((ch=getopt(argc,argv,<span class="string">&quot;hvs:E:b:t:&quot;</span>))!=<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">            print_help_info();  <span class="comment">//打印对该程序的使用指南</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:</span><br><span class="line">            verbose_flag=<span class="number">1</span>;   <span class="comment">//修改标志位</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">            cacheInfo.s_bit=atoi(optarg);</span><br><span class="line">            cacheInfo.S=<span class="number">1</span>&lt;&lt;cacheInfo.s_bit;  </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">            cacheInfo.E=atoi(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">            cacheInfo.b_bit=atoi(optarg);</span><br><span class="line">            cacheInfo.B=<span class="number">1</span>&lt;&lt;cacheInfo.b_bit;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">            fp=fopen(optarg,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Unknown option: %c\n&quot;</span>,(<span class="keyword">char</span>)optopt);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后需要定义cache的存储内容，为了逻辑清晰可以再定义一个结构来整合这些信息，但是这只是一个小程序，我就直接使用三个二维数组将cache的信息分开存放了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   cache=(<span class="keyword">long</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">long</span>*)*cacheInfo.S);  </span><br><span class="line"><span class="comment">//分配地址空间模拟cache, [索引组][行数]---&gt;标志位</span></span><br><span class="line">   mark=(<span class="keyword">bool</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">bool</span>*)*cacheInfo.S);   </span><br><span class="line"><span class="comment">//对应每一组内每一行的有效位,[索引组][行数]---&gt;有效位</span></span><br><span class="line">   time_tag=(<span class="keyword">int</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*)*cacheInfo.S); </span><br><span class="line"><span class="comment">//时间标记,[索引组][行数]---&gt;时间戳(用于LRU算法的替换依据)</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cacheInfo.S;i++)&#123;                <span class="comment">//初始化</span></span><br><span class="line">       cache[i]=(<span class="keyword">long</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)*cacheInfo.E);</span><br><span class="line">       mark[i]=(<span class="keyword">bool</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">bool</span>)*cacheInfo.E);</span><br><span class="line">       time_tag[i]=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*cacheInfo.E);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cacheInfo.S;i++)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cacheInfo.E;j++)</span><br><span class="line">           mark[i][j]=<span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>然后就是处理实际的地址访问请求的函数，这里我写一些伪代码说明流程，具体实现还是大家自己思考。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(读入一个memory traces)&#123;</span><br><span class="line">	判断它的类型，如果是I(I类指令最前面没有空格，其他指令前面有空格)则不用处理，<span class="keyword">continue</span>;</span><br><span class="line">    </span><br><span class="line">    取出memory traces的内存地址，将其转换为<span class="keyword">long</span></span><br><span class="line">        </span><br><span class="line">    将内存地址划分为组索引saddr和有效位taddr，块内偏移量可以忽略(writeup中有提示)</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">for</span>(遍历cache数组和mark数组)&#123;</span><br><span class="line">    	<span class="keyword">if</span>(mark[saddr][row]=<span class="literal">true</span>,且cache[saddr][row]=taddr) <span class="comment">//cache中保存有对应的内存单元</span></span><br><span class="line">    	then </span><br><span class="line">        	hit++;</span><br><span class="line">        	更新time[saddr][row]的时间戳;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(cache中没有找到对应内存单元)&#123;</span><br><span class="line">    	miss++;</span><br><span class="line">        LRU_replacement();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(memory trace type==M)&#123;</span><br><span class="line">    	hit++;  <span class="comment">//M必定发生2次hit或1次hit+1次miss,将缺的一次hit补上</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后需要完善cache的替换策略，本次实验中只需要实现较为简单的LRU策略，LRU策略会将一个最长时间未被使用的内存块换出cache，为了支持这一点，我们使用一个time_targ二维数组来记录每一个索引组中每一行的时间戳，使用全局的整型变量time，每一次对内存的访问都会使得time变量递增并且更新到time_targ[saddr] [row]。在需要替换内存块时，就遍历对应索引组的所有行，找到time[saddr] [row]最小的那一个替换出cache。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRU_replacement</span><span class="params">(<span class="keyword">long</span> saddr,<span class="keyword">long</span> taddr,<span class="keyword">char</span>* cacheState)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cacheInfo.E;i++)&#123;  <span class="comment">//首先检查有没有空闲的块可以存放读入的内存单元</span></span><br><span class="line">        <span class="keyword">if</span>(!mark[saddr][i])&#123;</span><br><span class="line">            cache[saddr][i]=taddr;</span><br><span class="line">            mark[saddr][i]=<span class="literal">true</span>;</span><br><span class="line">            time_tag[saddr][i]=time++;  <span class="comment">//时间标记，在驱逐的时候会用到它</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> minTime=<span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="keyword">int</span> minIndex=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cacheInfo.E;i++)&#123;   <span class="comment">//cache已满，需要驱逐</span></span><br><span class="line">        <span class="keyword">int</span> stamp=time_tag[saddr][i];</span><br><span class="line">        <span class="keyword">if</span>(stamp&lt;minTime)&#123;  <span class="comment">//寻找时间戳最小的那一行换出</span></span><br><span class="line">            minTime=stamp;</span><br><span class="line">            minIndex=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;evicts taddr=%ld saddr=%ld\n&quot;</span>,cache[saddr][minIndex],saddr);</span><br><span class="line">    cache[saddr][minIndex]=taddr;  </span><br><span class="line">    time_tag[saddr][minIndex]=time++;</span><br><span class="line">    evicts++;</span><br><span class="line">    <span class="built_in">strcat</span>(cacheState,<span class="string">&quot; evicts&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，partA的cache模拟器就完成了。</p>
<h3 id="Part-B"><a href="#Part-B" class="headerlink" title="Part B"></a>Part B</h3><p>这一部分只要是编写矩阵转置函数，并且要求在转置过程中发生尽可能少的miss</p>
<p>用于测试的矩阵有三种规格32x32,64x64,61x67，我们可以针对不同规模的矩阵使用专门的转置模式（不这么做也过不了测试）。</p>
<p>下面是对性能评估和分数的情况。</p>
<p>• 32 × 32: 8 points if m &lt; 300, 0 points if m &gt; 600<br>• 64 × 64: 8 points if m &lt; 1, 300, 0 points if m &gt; 2, 000<br>• 61 × 67: 10 points if m &lt; 2, 000, 0 points if m &gt; 3, 000</p>
<h4 id="32x32"><a href="#32x32" class="headerlink" title="32x32"></a>32x32</h4><p>首先可以看到普通的按行转置的方法在的数据为: hits:870  misses: 1183  evictions: 1151（32x32）</p>
<p>给定的cache参数为s=5,E=1,b=5，即有32个组，每个组一行，每一行存储32个字节的块</p>
<p>要减少miss的情况，主要要解决冲突不命中的情况。</p>
<p>首先，根据每一个行存储32字节的块，可以推出每一个块一次可以读入8个int，那么我们就可以直接使用8个临时变量将块内的8个int值存在寄存器中，防止后续出现冲突导致它们被换出。根据这个想法，我们改进一下示例代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">int</span> tmp1,tmp2,tmp3,tmp4;</span><br><span class="line"><span class="keyword">int</span> tmp5,tmp6,tmp7,tmp8; </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;M;j+=<span class="number">8</span>)&#123;</span><br><span class="line">        tmp1=A[i][j];  tmp2=A[i][j+<span class="number">1</span>];  tmp3=A[i][j+<span class="number">2</span>];  tmp4=A[i][j+<span class="number">3</span>];</span><br><span class="line">        tmp5=A[i][j+<span class="number">4</span>];  tmp6=A[i][j+<span class="number">5</span>];  tmp7=A[i][j+<span class="number">6</span>];  tmp8=A[i][j+<span class="number">7</span>];</span><br><span class="line">        B[j][i]=tmp1;  B[j+<span class="number">1</span>][i]=tmp2;  B[j+<span class="number">2</span>][i]=tmp3;  B[j+<span class="number">3</span>][i]=tmp4;</span><br><span class="line">        B[j+<span class="number">4</span>][i]=tmp5;  B[j+<span class="number">5</span>][i]=tmp6; B[j+<span class="number">6</span>][i]=tmp7;   B[j+<span class="number">7</span>][i]=tmp8;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>试着测试一下这个改进代码的性能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func 0 (Transpose submission): hits:898, misses:1155, evictions:1123</span><br></pre></td></tr></table></figure>

<p>很遗憾，这种运行模式好像没有提高性能。</p>
<p>我在这里卡了一段时间，最后得到的结论是，需要进一步的了解A，B的内存地址与cache的映射，这样才能做更加细致的分析和优化。</p>
<p>查看测试生成的数据trace.f0。在多次运行数据后，我发现多次测试生成的数组A的地址(0x0030a080)和数组B的地址(0x0034a080)都是固定的，那么我们就能够分析它们分别对应于cache中的哪个组，已经对应的标记位。</p>
<p>根据addr(A)=0x0030a080，addr(B)=0x0034a080，可以发现它们都映射到组4，但是都拥有不同的标记位。</p>
<p>具体分析我们上面的改进代码可以发现，每一轮中的8个对数组A的加载操作只会产生至多1次miss，但是每一次对于数组B的8次存储操作都会引发miss和evict。</p>
<p>下面给出 i=0,j=0 和 i=0，j=1这两个情况下，对数组B的存储操作的输出信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//i=0，j=0,冷启动,---&gt;右侧表示该内存地址对于的cache组</span></span><br><span class="line"> S <span class="number">0034</span>a080,<span class="number">4</span> miss evicts --&gt; saddr=<span class="number">4</span></span><br><span class="line"> S <span class="number">0034</span>a100,<span class="number">4</span> miss  --&gt; saddr=<span class="number">8</span></span><br><span class="line"> S <span class="number">0034</span>a180,<span class="number">4</span> miss  --&gt; saddr=<span class="number">12</span></span><br><span class="line"> S <span class="number">0034</span>a200,<span class="number">4</span> miss  --&gt; saddr=<span class="number">16</span></span><br><span class="line"> S <span class="number">0034</span>a280,<span class="number">4</span> miss  --&gt; saddr=<span class="number">20</span></span><br><span class="line"> S <span class="number">0034</span>a300,<span class="number">4</span> miss  --&gt; saddr=<span class="number">24</span></span><br><span class="line"> S <span class="number">0034</span>a380,<span class="number">4</span> miss  --&gt; saddr=<span class="number">28</span></span><br><span class="line"> S <span class="number">0034</span>a400,<span class="number">4</span> miss  --&gt; saddr=<span class="number">0</span></span><br><span class="line">--------------------------------------------------------------------------------------------------</span><br><span class="line"> <span class="comment">//i=0,j=1,--&gt;右侧表示被“驱逐出”cache的内存块的信息()</span></span><br><span class="line"> S <span class="number">0034</span>a480,<span class="number">4</span> miss evicts --&gt; evicts taddr=<span class="number">3368</span> saddr=<span class="number">4</span></span><br><span class="line"> S <span class="number">0034</span>a500,<span class="number">4</span> miss evicts     evicts taddr=<span class="number">3368</span> saddr=<span class="number">8</span></span><br><span class="line"> S <span class="number">0034</span>a580,<span class="number">4</span> miss evicts     evicts taddr=<span class="number">3368</span> saddr=<span class="number">12</span></span><br><span class="line"> S <span class="number">0034</span>a600,<span class="number">4</span> miss evicts     evicts taddr=<span class="number">3368</span> saddr=<span class="number">16</span></span><br><span class="line"> S <span class="number">0034</span>a680,<span class="number">4</span> miss evicts     evicts taddr=<span class="number">3368</span> saddr=<span class="number">20</span></span><br><span class="line"> S <span class="number">0034</span>a700,<span class="number">4</span> miss evicts     evicts taddr=<span class="number">3368</span> saddr=<span class="number">24</span>    </span><br><span class="line"> S <span class="number">0034</span>a780,<span class="number">4</span> miss evicts     evicts taddr=<span class="number">3368</span> saddr=<span class="number">28</span></span><br><span class="line"> S <span class="number">0034</span>a800,<span class="number">4</span> miss evicts     evicts taddr=<span class="number">3369</span> saddr=<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>可以看到第一轮加载入cache的B的内存块，在第二轮循环中全部被替换出cache，根据输出数据，后续的每一轮循环都会发生这种情况。</p>
<p>那么如何在保证对A维持这样高效的读取的同时，减少对B的冲突不命中呢？</p>
<p>这样就需要修改读取顺序，举例说我们第一组读入的是</p>
<p>B[ 0 ] [ 0 ]，B[ 1 ] [ 0 ]，B[ 2 ] [ 0 ]，B[ 3 ] [ 0 ]，B[ 4 ] [ 0 ]，B[ 5 ] [ 0 ]，B[ 6 ] [ 0 ]，B[ 7 ] [ 0 ]</p>
<p>那么假设我们第二轮读入的不是 B[ 8 ] [ 0 ]，B[ 9 ] [ 0 ]….</p>
<p>而是B[ 0 ] [ 1 ]，B[ 1 ] [ 1 ]，B[ 2 ] [ 1 ]，B[ 3 ] [ 1 ]，B[ 4 ] [ 1 ]，B[ 5 ] [ 1 ]，B[ 6 ] [ 1 ]，B[ 7 ] [ 1 ]</p>
<p>这样第二轮对于B的读取就能够全部命中（准确的说不一定是全部命中，有时会与A发生一次冲突)，并且对于A的高效读取策略也能够兼容。</p>
<p>根据以上的思路修改代码循环的顺序，得到以下代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">int</span> tmp1,tmp2,tmp3,tmp4;</span><br><span class="line">    <span class="keyword">int</span> tmp5,tmp6,tmp7,tmp8;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;M;j+=<span class="number">8</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            tmp1=A[i][j];  tmp2=A[i][j+<span class="number">1</span>];  tmp3=A[i][j+<span class="number">2</span>];  tmp4=A[i][j+<span class="number">3</span>];</span><br><span class="line">            tmp5=A[i][j+<span class="number">4</span>];  tmp6=A[i][j+<span class="number">5</span>];  tmp7=A[i][j+<span class="number">6</span>];  tmp8=A[i][j+<span class="number">7</span>];</span><br><span class="line">            B[j][i]=tmp1;  B[j+<span class="number">1</span>][i]=tmp2;  B[j+<span class="number">2</span>][i]=tmp3;  B[j+<span class="number">3</span>][i]=tmp4;</span><br><span class="line">            B[j+<span class="number">4</span>][i]=tmp5;  B[j+<span class="number">5</span>][i]=tmp6; B[j+<span class="number">6</span>][i]=tmp7;   B[j+<span class="number">7</span>][i]=tmp8;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//外循环按列，内循环按行，每一次在A中横着连续读8个int</span></span><br></pre></td></tr></table></figure>

<p>测试后得到性能如下，miss&lt;300，成功通过第一个测试点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func 0 (Transpose submission): hits:1766, misses:287, evictions:255</span><br></pre></td></tr></table></figure>



<h4 id="64x64"><a href="#64x64" class="headerlink" title="64x64"></a>64x64</h4><p>先使用32x32的代码测试一下，最后得到miss&gt;4000，可以知道，同样的代码在不同的矩阵下是无法通用的，根据讲义上的提示，我们可以根据每个测试点量身定做它独有的访问模式来提高缓存命中率。</p>
<p>重新审视一下这个矩阵，会发现由于列数从32扩展至64，使得每一行的元素实际上需要8个缓存组才能装下，这也说明，我们每次跨越一行，实际上跨越了8个缓存组，由于总共只有32个缓存组，所以在连续转换4行后，再转换到第五行时，会发生冲突不命中，将第一行的缓存数据驱逐出去，这就是我们沿用32x32的策略却效率很差的原因。</p>
<p>通过上述分析后，得出当一次只转置连续4个元素时，就不会发生冲突，这样就得到以下代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">int</span> tmp1,tmp2,tmp3,tmp4;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;M;j+=<span class="number">4</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        tmp1=A[i][j];  tmp2=A[i][j+<span class="number">1</span>];  tmp3=A[i][j+<span class="number">2</span>];  tmp4=A[i][j+<span class="number">3</span>];</span><br><span class="line">        B[j][i]=tmp1;  B[j+<span class="number">1</span>][i]=tmp2;  B[j+<span class="number">2</span>][i]=tmp3;  B[j+<span class="number">3</span>][i]=tmp4;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到测试结果如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func 0 (Transpose submission): hits:6546, misses:1651, evictions:1619</span><br></pre></td></tr></table></figure>

<p>可以看到miss的数量大幅下降，但是还未低于1300。</p>
<p>进一步分析，上述方法中，对B的每一个块只发生一次miss，但是对A的每一个块则发生两次miss(前4个元素一次，后四个一次)，那我们也许可以试着让A的每一个块只发生一次miss，即每一次都直接将块中的8个元素读出，前4个元素直接转换，但是后4个不能马上转换（如果立即转换就会发生冲突，参考上面关于32x32模式的低效原因），这时我们可以把它放在B的其他位置，因为我们有32个缓存组，但是实际上同一时间内的使用率却非常低，所以可以将它存放在不会发生冲突的缓存组。</p>
<p>我们计算一下对于一个8x8的块，这种改进的方法是否会优化miss数。</p>
<p>首先考虑一次只读4个元素转置的方法: misses=8(读入B的8个行)+16(每次读入A的半行)=24</p>
<p>再考虑改进后的方法: missed=8(读入B的4个行)+8(每次读入A的一个行)+4(读入用于暂存A中后4列的4个临时块)=20</p>
<p>可以发现效率有小幅提高，尝试写出代码并查看结果是否如我们推测的那样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i,j,k;</span><br><span class="line"><span class="keyword">int</span> tmp1,tmp2,tmp3,tmp4;</span><br><span class="line"><span class="keyword">int</span> tmp5,tmp6,tmp7,tmp8;</span><br><span class="line"><span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;N<span class="number">-8</span>;k+=<span class="number">8</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;M;j+=<span class="number">8</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i=k;i&lt;k+<span class="number">8</span>;i++)&#123;</span><br><span class="line">            tmp1=A[i][j];  tmp2=A[i][j+<span class="number">1</span>];  tmp3=A[i][j+<span class="number">2</span>];  tmp4=A[i][j+<span class="number">3</span>];</span><br><span class="line">            tmp5=A[i][j+<span class="number">4</span>]; tmp6=A[i][j+<span class="number">5</span>]; tmp7=A[i][j+<span class="number">6</span>]; tmp8=A[i][j+<span class="number">7</span>];</span><br><span class="line">            B[j][i]=tmp1;  B[j+<span class="number">1</span>][i]=tmp2;  B[j+<span class="number">2</span>][i]=tmp3;  B[j+<span class="number">3</span>][i]=tmp4;</span><br><span class="line">            </span><br><span class="line">            B[j][i+<span class="number">8</span>]=tmp5;  B[j+<span class="number">1</span>][i+<span class="number">8</span>]=tmp6;  B[j+<span class="number">2</span>][i+<span class="number">8</span>]=tmp7;  B[j+<span class="number">3</span>][i+<span class="number">8</span>]=tmp8; </span><br><span class="line">            <span class="comment">//暂存在B中的空闲位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=k;i&lt;k+<span class="number">8</span>;i++)&#123;  <span class="comment">//将暂存在B中空闲位置的数据转置到正确的位置</span></span><br><span class="line">            tmp1=B[j][i+<span class="number">8</span>]; tmp2=B[j+<span class="number">1</span>][i+<span class="number">8</span>]; tmp3=B[j+<span class="number">2</span>][i+<span class="number">8</span>]; tmp4=B[j+<span class="number">3</span>][i+<span class="number">8</span>];</span><br><span class="line">            B[j+<span class="number">4</span>][i]=tmp1; B[j+<span class="number">5</span>][i]=tmp2;  B[j+<span class="number">6</span>][i]=tmp3; B[j+<span class="number">7</span>][i]=tmp4;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;M;j+=<span class="number">4</span>)&#123; <span class="comment">//转置到最后一个块时，B的其他位置已经全部转置完毕，没有额外的空间暂存</span></span><br><span class="line">    <span class="comment">//只能退化为4x4的方式(一次只读4个元素)</span></span><br><span class="line">    <span class="keyword">for</span>(i=N<span class="number">-8</span>;i&lt;N;i++)&#123;</span><br><span class="line">        tmp1=A[i][j];  tmp2=A[i][j+<span class="number">1</span>];  tmp3=A[i][j+<span class="number">2</span>];  tmp4=A[i][j+<span class="number">3</span>];</span><br><span class="line">        B[j][i]=tmp1;  B[j+<span class="number">1</span>][i]=tmp2;  B[j+<span class="number">2</span>][i]=tmp3;  B[j+<span class="number">3</span>][i]=tmp4;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到测试结果如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func 0 (Transpose submission): hits:10354, misses:1427, evictions:1395</span><br></pre></td></tr></table></figure>

<p>可以看到，miss数大约减少了1/6，和我们分析的大致相同（miss数的减少有偏差是因为我们上述是对非对角线的块分析，对于对角线上的块而言，A，B在缓存中对应的组相同，A和B之间会发生冲突不命中，所以这些块转置时产生的miss数和我们分析的不一样）。</p>
<p>后续由于我实在想不到更好的优化方法了，只好上网查看其他大佬的解法。这里贴出一个大佬的博客，我觉得他写的十分清晰，同时也有相应的图示。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xbb224007/article/details/81103995">https://blog.csdn.net/xbb224007/article/details/81103995</a></p>
<p>对于这种方法的解析可以直接看上面这个博客，相比于我提供的优化方法而言，这个方法更进一步，它不需要读入额外的4个暂存块，而是使用巧妙的方法在块的内部进行暂存和转置，我这里只贴出自己的代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;N;k+=<span class="number">8</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;M;j+=<span class="number">8</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i=k;i&lt;k+<span class="number">4</span>;i++)&#123;   <span class="comment">//前四行,前四列正常转置，后四列翻转后暂存在B的非对应位中</span></span><br><span class="line">            tmp1=A[i][j];  tmp2=A[i][j+<span class="number">1</span>];  tmp3=A[i][j+<span class="number">2</span>];  tmp4=A[i][j+<span class="number">3</span>];</span><br><span class="line">            tmp5=A[i][j+<span class="number">4</span>]; tmp6=A[i][j+<span class="number">5</span>]; tmp7=A[i][j+<span class="number">6</span>]; tmp8=A[i][j+<span class="number">7</span>];</span><br><span class="line">            B[j][i]=tmp1;  B[j+<span class="number">1</span>][i]=tmp2;  B[j+<span class="number">2</span>][i]=tmp3;  B[j+<span class="number">3</span>][i]=tmp4;</span><br><span class="line">            B[j][i+<span class="number">4</span>]=tmp5; B[j+<span class="number">1</span>][i+<span class="number">4</span>]=tmp6; B[j+<span class="number">2</span>][i+<span class="number">4</span>]=tmp7; B[j+<span class="number">3</span>][i+<span class="number">4</span>]=tmp8;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(d=j;d&lt;j+<span class="number">4</span>;d++)&#123;  <span class="comment">//后四行前四列(corner case)</span></span><br><span class="line">            tmp1=A[k+<span class="number">4</span>][d]; tmp2=A[k+<span class="number">5</span>][d]; tmp3=A[k+<span class="number">6</span>][d]; tmp4=A[k+<span class="number">7</span>][d];</span><br><span class="line">            tmp5=B[d][k+<span class="number">4</span>]; tmp6=B[d][k+<span class="number">5</span>]; tmp7=B[d][k+<span class="number">6</span>]; tmp8=B[d][k+<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">            B[d][k+<span class="number">4</span>]=tmp1;  B[d][k+<span class="number">5</span>]=tmp2; B[d][k+<span class="number">6</span>]=tmp3; B[d][k+<span class="number">7</span>]=tmp4;</span><br><span class="line">            <span class="comment">//这两行的顺序很重要，不能颠倒，否则会导致大量的冲突不命中</span></span><br><span class="line">            B[<span class="number">4</span>+d][k]=tmp5; B[<span class="number">4</span>+d][k+<span class="number">1</span>]=tmp6; B[<span class="number">4</span>+d][k+<span class="number">2</span>]=tmp7; B[<span class="number">4</span>+d][k+<span class="number">3</span>]=tmp8;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=k+<span class="number">4</span>;i&lt;k+<span class="number">8</span>;i++)&#123;  <span class="comment">//后四行后四列，按4x4块的模式转置</span></span><br><span class="line">            tmp1=A[i][j+<span class="number">4</span>]; tmp2=A[i][j+<span class="number">5</span>]; tmp3=A[i][j+<span class="number">6</span>];  tmp4=A[i][j+<span class="number">7</span>];</span><br><span class="line">            B[j+<span class="number">4</span>][i]=tmp1; B[j+<span class="number">5</span>][i]=tmp2; B[j+<span class="number">6</span>][i]=tmp3;  B[j+<span class="number">7</span>][i]=tmp4;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终运行效率如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func 0 (Transpose submission): hits:9066, misses:1179, evictions:1147</span><br></pre></td></tr></table></figure>



<h4 id="61x67"><a href="#61x67" class="headerlink" title="61x67"></a>61x67</h4><p>可以发现，当列数由64变为67时，数组中不同元素在cache中对应的组也会发生变化。</p>
<p>下面取前8行第一个元素，分析它们在不同矩阵中所属缓存组的变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在64x64矩阵中                         &#x2F;&#x2F;在61x67矩阵中</span><br><span class="line">A[0][0]---&gt;saddr&#x3D;4                     A[0][0]-----&gt;saddr&#x3D;4</span><br><span class="line">A[1][0]---&gt;saddr&#x3D;12                    A[1][0]-----&gt;saddr&#x3D;11</span><br><span class="line">A[2][0]---&gt;saddr&#x3D;20                    A[2][0]-----&gt;saddr&#x3D;19</span><br><span class="line">A[3][0]---&gt;saddr&#x3D;28                    A[3][0]-----&gt;saddr&#x3D;26</span><br><span class="line">A[4][0]---&gt;saddr&#x3D;4                     A[4][0]-----&gt;saddr&#x3D;2</span><br><span class="line">A[5][0]---&gt;saddr&#x3D;12                    A[5][0]-----&gt;saddr&#x3D;10</span><br><span class="line">A[6][0]---&gt;saddr&#x3D;20                    A[6][0]-----&gt;saddr&#x3D;17</span><br><span class="line">A[7][0]---&gt;saddr&#x3D;28                    A[7][0]-----&gt;saddr&#x3D;25</span><br></pre></td></tr></table></figure>

<p>所属缓存组的变化会直接影响到冲突不命中的情况，当元素的所属组不同时，就能够更加充分的利用cache的空间，我们就能够使用更大的分块处理数据，并且能够得到一个较低的miss数。</p>
<p>通过分析得知，在61x67矩阵中，我们可以像32x32矩阵那样一次处理8x8的分块，并且不会发生大量的冲突不命中（64x64则会发生大量冲突），所以我们可以先试着对其进行8x8的分块，最右侧剩余(61%8=5)的部分单独处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;M;j+=<span class="number">8</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(j==<span class="number">56</span>)&#123;</span><br><span class="line">         tmp1=A[i][j];  tmp2=A[i][j+<span class="number">1</span>];  tmp3=A[i][j+<span class="number">2</span>];  </span><br><span class="line">         tmp4=A[i][j+<span class="number">3</span>];  tmp5=A[i][j+<span class="number">4</span>];</span><br><span class="line">         B[j][i]=tmp1;  B[j+<span class="number">1</span>][i]=tmp2;  B[j+<span class="number">2</span>][i]=tmp3;  </span><br><span class="line">         B[j+<span class="number">3</span>][i]=tmp4; B[j+<span class="number">4</span>][i]=tmp5;</span><br><span class="line">      &#125;</span><br><span class="line">      tmp1=A[i][j];  tmp2=A[i][j+<span class="number">1</span>];  tmp3=A[i][j+<span class="number">2</span>];  tmp4=A[i][j+<span class="number">3</span>];</span><br><span class="line">      tmp5=A[i][j+<span class="number">4</span>];  tmp6=A[i][j+<span class="number">5</span>];  tmp7=A[i][j+<span class="number">6</span>];  tmp8=A[i][j+<span class="number">7</span>];</span><br><span class="line">      B[j][i]=tmp1;  B[j+<span class="number">1</span>][i]=tmp2;  B[j+<span class="number">2</span>][i]=tmp3;  B[j+<span class="number">3</span>][i]=tmp4;</span><br><span class="line">      B[j+<span class="number">4</span>][i]=tmp5;  B[j+<span class="number">5</span>][i]=tmp6; B[j+<span class="number">6</span>][i]=tmp7;   B[j+<span class="number">7</span>][i]=tmp8;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>性能测试结果如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Summary for official submission (func 0): correctness&#x3D;1 misses&#x3D;1852</span><br></pre></td></tr></table></figure>

<p>可以发现，我们只是简单的做了个8x8的分块，就达到了要求，看来这个测试点还是比较水的- -</p>
<p>最终测试结果:</p>
<p><img src="C:\Users\25344\AppData\Roaming\Typora\typora-user-images\image-20200717173441806.png" alt="image-20200717173441806"></p>

    </div>
    <!--文末结束语-->
    
        <div style="text-align:center;color: #ccc;font-size:24px;"> --- 本文结束 <i class="fas fa-heart"></i> The End --- </div>
    
    <!--页脚广告-->
    
    <v-divider></v-divider>
    
    <div class="post-nav">             
        
            <v-btn text class="font-weight-bold" href="/2020/08/30/csapp-shellLab/">
                <v-icon>chevron_left</v-icon>
                csapp-shellLab
            </v-btn> 
        
          
            <v-btn text class="float-right font-weight-bold" href="/2020/08/30/csapp-bombLab/">      
                csapp-bomblab
                <v-icon>chevron_right</v-icon>
            </v-btn>
        
    </div>
</v-card>



        
                            <div id="mobile-footer" class="d-block d-md-none">
                                <v-divider></v-divider>
                                <div id="mobile-footer-content">
                                    <span>Theme: <a target="_blank" rel="noopener" href="https://github.com/kb1000fx/hexo-theme-insulin">Insulin</a> &nbsp; Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a></span><br>
                                    <span> &copy; 2015 - 2020 wwow</span>
                                </div>
                            </div>                   
                        </v-col>                                            
                    </v-row>
                </v-container>
            </v-content>
        </v-app>
    </div>
    
<script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script>
<script src="https://cdn.jsdelivr.net/npm/vuetify@2.2.30"></script>

<script src="/js/main.js"></script>




    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




    <script src="https://cdn.jsdelivr.net/npm/mermaid@8.4.8/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({
        startOnLoad: true,
        theme: "default"
    });</script>







</body>
</html>