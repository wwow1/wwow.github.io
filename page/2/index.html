<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="努力可能会成功，但不努力真的很舒服">
<meta property="og:type" content="website">
<meta property="og:title" content="wwow&#39;s blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="wwow&#39;s blog">
<meta property="og:description" content="努力可能会成功，但不努力真的很舒服">
<meta property="og:locale">
<meta property="article:author" content="wwow">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>wwow's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">wwow's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/10/mit-6-824-4a-shardmaster/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="wwow">
      <meta itemprop="description" content="努力可能会成功，但不努力真的很舒服">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wwow's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/10/mit-6-824-4a-shardmaster/" class="post-title-link" itemprop="url">MIT-6.824-lab4A-The Shard Master</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-10 22:22:25" itemprop="dateCreated datePublished" datetime="2020-04-10T22:22:25+08:00">2020-04-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-04 22:33:02" itemprop="dateModified" datetime="2020-09-04T22:33:02+08:00">2020-09-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mit6-824/" itemprop="url" rel="index"><span itemprop="name">mit6.824</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://github.com/wwow1/MIT-6.824">https://github.com/wwow1/MIT-6.824</a></p>
<p>在lab4中，我们将要搭建一个基于分片的kv存储系统，这个系统的工作流程稍微有一点复杂，我看了好几遍说明才看懂- -，同时也参考了一些网上的说明。</p>
<p>简而言之分片（shard）就是将我们要保存的数据分割成多份，然后将这些分片分发给下层的不同个raft集群，每一个raft集群负责多个分片的保存和响应对应的数据操作，同时为了管理这些不同的raft集群，在多个raft集群之上还需要增加一个用于管理分片和集群配置的raft集群，这个集群称为shardmaster</p>
<p>大家也许会想问分片是按照什么方法进行分割的呢？我认为具体的方法是由使用者决定的，在lab4中，由于保存的key-value全都是string变量，同时分片数量确定为10个，所以分配规则为 int(key[0])%10</p>
<p><img src="https://s1.ax1x.com/2020/09/04/wA8dIA.png" alt="wA8dIA.png"></p>
<p>这是我在网上看到的一个非常简单易懂的图片说明，取自<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6e8d33c3c799">https://www.jianshu.com/p/6e8d33c3c799</a></p>
<p>在lab4A中，我们只需要完成shardmaster部分，不涉及具体的分片数据管理</p>
<p>我们主要需要在shardmaster中为上层服务器提供4种服务，分别是</p>
<p>Join：将新的raft集群加入到配置中，同时需要保证在新raft集群加入后，集群中的分片分配是平均合理的</p>
<p>Leave：将先前存在于配置中的raft集群排出到集群之外，同样的，在新的集群中也要实现分片分配的平均合理</p>
<p>Move：将指定的分片分配给指定的某个raft集群</p>
<p>Query：给定一个配置号，返回对应编号的配置信息，如果配置号为-1或大于存在的所有配置号就返回最新的配置信息</p>
<p>这4个功能的具体参数和说明都在6.824的网站上有，这里只是简略的说明功能，在实现的时候还是要认真的查看要求和参数</p>
<p><strong>Client部分</strong></p>
<p>我们首先开始实现shardmaster的client，shardmaster的client中，对于4个功能的client端的调用已经完善，我们不需要更改，主要是做Clerk的初始化和Clerk变量的添加，这里可以仿照lab3的做法，首先为了防止请求重复执行，我们需要一个opnum来为当前发送的请求加上编号，同时为了支持多client操作，我们需要为每个clerk生成一个clientId。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Clerk <span class="keyword">struct</span> &#123;</span><br><span class="line">	servers []*labrpc.ClientEnd</span><br><span class="line">	opnum <span class="keyword">int</span></span><br><span class="line">	mu 		sync.Mutex</span><br><span class="line">	clientId <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Common部分</strong></p>
<p>然后我们需要修改common.go中的RPC结构变量，只需要在每个–Args中添加Opnum和ClientId就行，非常简单，这里就不贴图了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">	Num    <span class="keyword">int</span>              <span class="comment">// config number</span></span><br><span class="line">	Shards [NShards]<span class="keyword">int</span>     <span class="comment">// shard -&gt; gid</span></span><br><span class="line">	Groups <span class="keyword">map</span>[<span class="keyword">int</span>][]<span class="keyword">string</span> <span class="comment">// gid -&gt; servers[]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然提到了common.go，我们就来说一说配置结构Config，首先Num是用于标识当前的Config编号（从1开始），然后是记录分片所属的Shards数组，Shards数组有10个int值，在我们的lab中，使用到的数据被分为10个分片，而Shards则表示分片号和当前管理它们的集群的集群号gid的映射关系</p>
<p><strong>Server部分</strong></p>
<p>最后我们要填写server中的内容，首先是ShardMaster的结构，为了确定Start的log是否apply成功，我们需要加入applyMsg；为了保存每一次apply的结果，需要加入applyCheck；为了保存从头到尾的全部配置信息，我们需要加入configs</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ShardMaster <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu      sync.Mutex</span><br><span class="line">	me      <span class="keyword">int</span></span><br><span class="line">	rf      *raft.Raft</span><br><span class="line">	applyCh <span class="keyword">chan</span> raft.ApplyMsg</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Your data here.</span></span><br><span class="line">	applyMsg <span class="keyword">map</span>[<span class="keyword">int64</span>]<span class="keyword">map</span>[<span class="keyword">int</span>]Msg</span><br><span class="line">	applyCheck <span class="keyword">map</span>[<span class="keyword">int64</span>]<span class="keyword">map</span>[<span class="keyword">int</span>]Config</span><br><span class="line">	configs []Config <span class="comment">// indexed by config num</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们来一一完善Join，Leave，Move，Query这4个RPC</p>
<p>在lab3中，对于client的RPC请求Get和PutAppend，我们首先将它们start给下层的raft，在raft确保一致性之后，再apply到上层，由上层进行具体apply操作。</p>
<p>这里也是一样，我们要将这4种请求传入raft，在raft中保证了一致性之后，再回到当前执行它们</p>
<p>需要确认传入到raft中的结构，在lab3和lab4中都命名为Op</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Op <span class="keyword">struct</span> &#123;</span><br><span class="line">	Operation <span class="keyword">string</span>   <span class="comment">//&quot;join&quot; &quot;leave&quot; &quot;move&quot; &quot;query&quot;</span></span><br><span class="line">	Opnum <span class="keyword">int</span></span><br><span class="line">	Args	<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	ClientId <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要需要说明一个Args，它必须为一个interface{}类型，因为Join，Leave，Move，Query的参数各不相同，只有interface{}才能够接纳它们</p>
<p>然后在各自函数中将需要使用到的变量打包进入Op，所有内容大致相同，唯一不一样的就是Args，要根据传入的参数来打包</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sm *ShardMaster)</span> <span class="title">Join</span><span class="params">(args *JoinArgs, reply *JoinReply)</span></span> &#123;</span><br><span class="line">	Tmp:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>][]<span class="keyword">string</span>)</span><br><span class="line">	<span class="keyword">for</span> k,s:=<span class="keyword">range</span> args.Servers&#123;</span><br><span class="line">		Tmp[k]=<span class="built_in">make</span>([]<span class="keyword">string</span>,<span class="built_in">len</span>(s))</span><br><span class="line">		<span class="built_in">copy</span>(Tmp[k],s)</span><br><span class="line">	&#125;</span><br><span class="line">	op:=Op&#123;<span class="string">&quot;Join&quot;</span>,args.Opnum,Tmp,args.ClientId&#125;</span><br><span class="line">	tmpReply:=sm.StartLog(op)</span><br><span class="line">	reply.WrongLeader=tmpReply.WrongLeader</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sm *ShardMaster)</span> <span class="title">Leave</span><span class="params">(args *LeaveArgs, reply *LeaveReply)</span></span> &#123;</span><br><span class="line">	op:=Op&#123;<span class="string">&quot;Leave&quot;</span>,args.Opnum,args.GIDs,args.ClientId&#125;</span><br><span class="line">	tmpReply:=sm.StartLog(op)</span><br><span class="line">	reply.WrongLeader=tmpReply.WrongLeader</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sm *ShardMaster)</span> <span class="title">Move</span><span class="params">(args *MoveArgs, reply *MoveReply)</span></span> &#123;</span><br><span class="line">	LogArgs:=MoveLogArgs&#123;args.Shard,args.GID&#125;</span><br><span class="line">	op:=Op&#123;<span class="string">&quot;Move&quot;</span>,args.Opnum,LogArgs,args.ClientId&#125;</span><br><span class="line">	tmpReply:=sm.StartLog(op)</span><br><span class="line">	reply.WrongLeader=tmpReply.WrongLeader</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sm *ShardMaster)</span> <span class="title">Query</span><span class="params">(args *QueryArgs, reply *QueryReply)</span></span> &#123;</span><br><span class="line">	op := Op&#123;<span class="string">&quot;Query&quot;</span>, args.Opnum, args.Num, args.ClientId&#125;</span><br><span class="line">	tmpReply:=sm.StartLog(op)</span><br><span class="line">	reply.WrongLeader=tmpReply.WrongLeader</span><br><span class="line">	reply.Config=tmpReply.Configuration</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在填充了Op结构之后，就将其传入StartLog函数中，这个函数用于统一调用raft.Start函数，StartLog的具体实现基本可以照搬lab3中Get和Append的实现方法。</p>
<p>之后我们需要编写server中的Apply函数，这里的实现也是基本照搬lab3的内容，实际上思路也差不多，但是不同的是在apply的具体执行时，要跳转到对应的RPChandler函数进行具体的处理</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> op.Operation==<span class="string">&quot;Join&quot;</span>&#123;</span><br><span class="line">	servers:=(op.Args).(<span class="keyword">map</span>[<span class="keyword">int</span>][]<span class="keyword">string</span>)</span><br><span class="line">	sm.JoinHandler(servers)</span><br><span class="line">	sm.applyCheck[op.ClientId][op.Opnum]=Config&#123;&#125;</span><br><span class="line">	_,ok=sm.applyCheck[op.ClientId][op.Opnum]</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> op.Operation==<span class="string">&quot;Leave&quot;</span>&#123;</span><br><span class="line">	GIDs:=(op.Args).([]<span class="keyword">int</span>)</span><br><span class="line">	sm.LeaveHandler(GIDs)</span><br><span class="line">	sm.applyCheck[op.ClientId][op.Opnum]=Config&#123;&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> op.Operation==<span class="string">&quot;Move&quot;</span>&#123;</span><br><span class="line">	moveMsg:=(op.Args).(MoveLogArgs)</span><br><span class="line">	sm.MoveHandler(moveMsg)</span><br><span class="line">	sm.applyCheck[op.ClientId][op.Opnum]=Config&#123;&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> op.Operation==<span class="string">&quot;Query&quot;</span>&#123;</span><br><span class="line">	num:=(op.Args).(<span class="keyword">int</span>)</span><br><span class="line">	sm.applyCheck[op.ClientId][op.Opnum]=sm.QueryHandler(num)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;unkonwn operation type &quot;</span>+op.Operation)&#125;</span><br><span class="line"><span class="comment">//Apply中的部分代码</span></span><br></pre></td></tr></table></figure>

<p>最后我们需要一一编写RPC Handler函数</p>
<p>我们先从简单的开始，首先是QueryHandler，如果传入的参数num为-1或者大于当前最大的config.num，就返回最后一个config，否则就返回对应下标的config</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sm *ShardMaster)</span> <span class="title">QueryHandler</span><span class="params">(num <span class="keyword">int</span>)</span> <span class="title">Config</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> num==<span class="number">-1</span> || num&gt;=<span class="built_in">len</span>(sm.configs)&#123;</span><br><span class="line">		<span class="keyword">return</span> sm.configs[<span class="built_in">len</span>(sm.configs)<span class="number">-1</span>]</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> sm.configs[num]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是MoveHandler函数，首先我们创建一个新的config，然后将上一个config的内容全部复制过来，唯一要改动的就是Shard[args.Shard]要改为指定的args.GID</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sm *ShardMaster)</span> <span class="title">MoveHandler</span><span class="params">(args MoveLogArgs)</span></span>&#123;</span><br><span class="line">	lastConfig:=<span class="built_in">len</span>(sm.configs)<span class="number">-1</span></span><br><span class="line">	newConfig:=Config&#123;&#125;</span><br><span class="line">	newConfig.Num=lastConfig+<span class="number">1</span></span><br><span class="line">	newConfig.Groups=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>][]<span class="keyword">string</span>)</span><br><span class="line">	<span class="keyword">for</span> k,v:=<span class="keyword">range</span> sm.configs[lastConfig].Groups&#123;</span><br><span class="line">		newConfig.Groups[k]=<span class="built_in">make</span>([]<span class="keyword">string</span>,<span class="built_in">len</span>(v))</span><br><span class="line">		<span class="built_in">copy</span>(newConfig.Groups[k],v)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;NShards;i++&#123;</span><br><span class="line">		<span class="keyword">if</span> i==args.Shard&#123;</span><br><span class="line">			newConfig.Shards[i]=args.GID</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			newConfig.Shards[i]=sm.configs[lastConfig].Shards[i]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	sm.configs=<span class="built_in">append</span>(sm.configs,newConfig)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就是比较麻烦的LeaveHandler和JoinHandler，因为它们在更改集群成员的同时，需要对Shards进行再分配，并且要求在移动分片尽量少的情况下保证分片分配的平均。所以我们就需要思考对应的分片分配策略</p>
<p><strong>LeaveHandler</strong></p>
<p>1.首先将确定要保留的Group移到新的config中，这些保留的Group所维护的分片不应改变（尽量少移动分片），同时将这些Group计入remainGroupCircle数组（gid数组）中，并使用remainShard（gid-&gt; shard num) 记录它们现在维护的分片数量</p>
<p>2.根据remainShard的值从小到大给remainGroupCircle数组排序，然后将被移除的Group所维护的分片按照remainGroupCircle中的顺序循环分配给保留的Group们</p>
<p>稍微解释一下第二个步骤，由于我们确定上一次配置中的分片分配是平均的，所以保留的Group们所负责的分片数量应该是平均的，那么我们只需要将剩余的分片也平均分配就行了。</p>
<p>但是这里的平均只是相对的，对于10个分片，我们要将它分配给4个Group，那么2（gid100)，2(gid101)，3(gid102)，3(gid103)就是一种较为平均的分配方式，假设gid100退出集群，那么为了维持平均，我们不应该将这两个分片分给gid102和gid103，这将造成2（gid101），4（gid102），4（gid103）这种不平均的局面，而应该优先考虑把分片分配给分配数量最少的gid101，这也是为什么在分配前要根据remainShard排序的原因</p>
<p><strong>JoinHandler</strong></p>
<p>1.将新加入的Groups和保留的Groups一起加入新集群，同时记录新加入的Group个数newGroupnum以及保留的Group个数remainGroupnum</p>
<p>2.计算每个Group现在负责的分片数并保留到数组remainShard（gid-&gt;shard num)，计算出在新的配置中每个集群应负责的分片数量assignShards（只能整除），以及在计算assignShards中由于整除而被“漏网”的分片数leftShards</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assignShards:=NShards/(remainGroupnum+newGroupnum)</span><br><span class="line">leftShards:=NShards-assignShards*(remainGroupnum+newGroupnum)</span><br></pre></td></tr></table></figure>

<p>3.用remainShard减去assignShards</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这段代码与我的实际代码顺序不太一样，但是思路相同</span></span><br><span class="line"><span class="keyword">for</span> k,v:=<span class="keyword">range</span> sm.configs[lastConfig].Groups&#123;</span><br><span class="line">   remainShard[k]-=assignShards</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样remainShards的意思就转变为每个Group要分发给新Group的分片数，但这还不准确，还有leftShards要处理，为了实现移动尽量少的分片，所以leftShards我们就保留在旧Group上</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据remainShard逆序排列remainGroup，表示分出分片多的Group应该优先减少分发数</span></span><br><span class="line"></span><br><span class="line">sort(remainGroup,remainShard,<span class="literal">false</span>)</span><br><span class="line">ptr=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> leftShards&gt;<span class="number">0</span>&#123;</span><br><span class="line">	remainShard[remainGroup[ptr]]--</span><br><span class="line"><span class="comment">//每次自减表示要分出的分片减少1个</span></span><br><span class="line">	ptr=(ptr+<span class="number">1</span>)%<span class="built_in">len</span>(remainGroup)</span><br><span class="line">	leftShards--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.每个旧Group根据remainShard为新Group循环分发分片，同时也将自己维护的分片信息写入新的配置中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;NShards;i++&#123;</span><br><span class="line">	<span class="keyword">if</span> remainShard[sm.configs[lastConfig].Shards[i]]&gt;<span class="number">0</span> &amp;&amp; assignShards&gt;<span class="number">0</span>&#123;  <span class="comment">//为新Group分发分片</span></span><br><span class="line">		newConfig.Shards[i]=newGroup[circlePtr]</span><br><span class="line">		circlePtr=(circlePtr+<span class="number">1</span>)%newGroupnum</span><br><span class="line">		remainShard[sm.configs[lastConfig].Shards[i]]--</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;   <span class="comment">//将属于旧Group的分片信息搬运到新配置中</span></span><br><span class="line">	        newConfig.Shards[i]=sm.configs[lastConfig].Shards[i]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此为止，lab4A的内容就结束啦，lab4A的难度还是较低的，因为很多地方的实现都可以仿照lab3A来做，唯一需要思考的应该只有Join和Leave的分片分配策略，接下来我们就要进去6.824的最后一部分lab4B，大家也要做好心理准备哈，4B的难度可就不像4A这么友善了（我太菜了- -</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/10/mit-6-824-lab3b-kvraft/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="wwow">
      <meta itemprop="description" content="努力可能会成功，但不努力真的很舒服">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wwow's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/10/mit-6-824-lab3b-kvraft/" class="post-title-link" itemprop="url">MIT-6.824-lab3B-kvraft</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-10 10:45:39" itemprop="dateCreated datePublished" datetime="2020-04-10T10:45:39+08:00">2020-04-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-30 12:45:50" itemprop="dateModified" datetime="2020-08-30T12:45:50+08:00">2020-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mit6-824/" itemprop="url" rel="index"><span itemprop="name">mit6.824</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://github.com/wwow1/MIT-6.824">https://github.com/wwow1/MIT-6.824</a></p>
<p>在lab3B的实验中，我们需要为3A的key-value服务添加日志压缩功能，在lab2C中，为了使server在重启时能够恢复之前的状态，我们对Raft中的几个持久化变量以及log进行了持久化保存，但是随着server的不断运行，其Raft中log的内容也不断增加，这将会导致我们在持久化log内容的时候耗费大量的存储空间。为了改进这一情况，我们需要在kvraft中增加能够持久性保存当前状态的Snapshot，当kvraft的当前状态存入Snapshot后，我们就可以使Raft丢弃快照之前的log达到节省空间的目的。</p>
<p>在lab3B的测试中，将会传入一个MaxRaftState变量，它记录了当前允许的Raft持久化数据的最大值，当Raft持久化数据的容量大于MaxRaftState时，我们的kvraft就需要保存一个快照，并只是Raft丢弃旧的日志条目</p>
<p>这里有一点需要注意的是，在lab3B之前，我们都是使用Slice来保存Raft log的，但是使用Slice无法实现“丢弃旧的日志”这一功能，因为丢弃旧的日志后，新的日志的下标并不会重新从0开始计数，假设当前快照对应的最后一个LogIndex=n，那么下一个传入的log的index应该为n+1。所以在这里，我首先将保存log的容器改为map。</p>
<p>我本来以为将log改为map存储很简单，只需要修改对应的变量就行，但是还是遇到了一些小问题，例如Slice是支持多个线程同步访问的，但是map就不行，所以需要将代码中使用到log的部分加上锁。这里给大家推荐另外一种方法，直接使用sync.Map，这个数据结构会在使用时自动实现上锁的功能，就不需要在每次访问log的时候都去一一加锁。（一开始我也使用了Sync.Map,但是由于当时没弄懂gob.Register，所以在RPC调用的时候，传入的log直接变空值了，于是我就放弃了它- -）</p>
<p>这里特别提醒一下，如果大家使用LastLogIndex=len（rf.log）-1这个句子来得到LastLogIndex的话，那么一定要记得修改，因为换用map，同时加入了discard log功能后，len（rf.log）-1得到的值将小于真实的LastLogIndex。我建议还是使用遍历map的方法.</p>
<p>在完成了将log容器从Slice过度到Map之后，我们就可以开始编写Snapshot的相关代码了</p>
<p><strong>1.Snapshot结构</strong></p>
<p>首先我们需要确认，哪些数据需要被保存在Snapshot中？</p>
<p>既然是通过Snapshot保存状态，那么当前保存的kv.DB信息肯定需要加入其中，然后还需要ApplyNum来保证在重启后不会发生request dup，最后是LastIncludedIndex和LastIncludedTerm保存Snapshot包含的最后一个log的Index和Term，通过这两个信息来指示Raft丢弃旧的log</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SnapShot <span class="keyword">struct</span>&#123;</span><br><span class="line">	State <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>  <span class="comment">//key-&gt;value</span></span><br><span class="line">	ApplyNum <span class="keyword">map</span>[<span class="keyword">int64</span>]<span class="keyword">int</span>   <span class="comment">//clientId-&gt;opnum</span></span><br><span class="line">	LastIncludedIndex <span class="keyword">int</span></span><br><span class="line">	LastIncludedTerm <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.周期性地检查Raft持久化状态的长度（CheckLogLength)</strong></p>
<p>我使用了一个CheckLogLength的函数来周期性的检测Raft状态的长度，一旦发现Raft状态长度超过了MaxRaftState，就需要保存一个新的Snapshot，需要提醒的就是map的赋值不能直接使用=，而是需要跑一个循环将每一个数据一一进行复制。</p>
<p>还有一个问题就是Snapshot中的LastIncludedIndex和LastIncludedTerm要如何确认？我使用了两个新的变量kv.commitIndex和kv.commitTerm来记录被kvraft apply的最后一个raft log，所以需要在apply()函数中增加代码来更新commitIndex和commitTerm</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> op.Index&gt;kv.commitIndex&#123; <span class="comment">//in apply()</span></span><br><span class="line">	kv.commitIndex=op.Index</span><br><span class="line">	kv.commitTerm=op.Term</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在每次保存Snapshot的时候，就将当前的kv.commitIndex和kv.commitTerm作为LastIncludedIndex和LastIncludeTerm存入新的Snapshot中</p>
<p>在记录完Snapshot后，需要调用Raft中的函数丢弃旧log</p>
<p><strong>3.使用Snapshot恢复状态（RestoreSnapshot）</strong></p>
<p>在Server启动时，我们需要调用一个RestoreSnapshot函数来使用已经保存的Snapshot去恢复kvraft的状态。函数内容也很简单，把Snapshot中的数据解码之后复制给kvraft中对应的变量就行</p>
<p>到此为止，我们在kvraft程序中的修改就大致结束了，然后需要转移到raft中完成剩余的内容</p>
<p><strong>4.Raft根据kvraft提供的信息丢弃旧log（DiscardLog）</strong></p>
<p>由kvraft中的CheckLogLength调用raft中的DiscardLog函数来丢弃旧log</p>
<p>调用者应该需要提供LastIncludedIndex以及LastIncludedTerm，DiscardLog根据LastIncludedIndex对自己的log进行一轮遍历，丢弃所有index&lt;LastIncludedIndex的log，同时在Raft中也需要添加LastIncludedIndex和LastIncludedTerm两个变量（具体用处后面会说），说明一下这里更新lastApplied的操作其实是多余的，当时编写的时候没有去除掉。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=LastIncludedIndex;i++&#123; <span class="comment">//in discardLog()</span></span><br><span class="line">	_,ok:=rf.log[i]</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		<span class="built_in">delete</span>(rf.log,i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">rf.lastIncludedIndex=LastIncludedIndex</span><br><span class="line">rf.lastIncludedTerm=LastIncludedTerm</span><br><span class="line">rf.lastApplied=max(rf.lastApplied,rf.lastIncludedIndex)</span><br><span class="line">rf.persist()</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Raft <span class="keyword">struct</span> &#123;   # <span class="built_in">new</span> Raft <span class="keyword">struct</span></span><br><span class="line">	mu        sync.Mutex   <span class="comment">// Lock to protect shared access to this peer&#x27;s state</span></span><br><span class="line">	peers     []*labrpc.ClientEnd <span class="comment">// RPC end points of all peers</span></span><br><span class="line">	persister *Persister          <span class="comment">// Object to hold this peer&#x27;s persisted state</span></span><br><span class="line">	me        <span class="keyword">int</span>                 <span class="comment">// this peer&#x27;s index into peers[]</span></span><br><span class="line">	applyCh <span class="keyword">chan</span> ApplyMsg</span><br><span class="line"></span><br><span class="line">	electionTimeout <span class="keyword">int</span></span><br><span class="line">	leaderId <span class="keyword">int</span></span><br><span class="line">	t *time.Timer</span><br><span class="line">	currentTerm <span class="keyword">int</span>   <span class="comment">//persistent state</span></span><br><span class="line">	votedFor <span class="keyword">int</span></span><br><span class="line">	log		<span class="keyword">map</span>[<span class="keyword">int</span>]Entry</span><br><span class="line">	<span class="comment">//lastIncludedTerm int</span></span><br><span class="line">	lastIncludedIndex <span class="keyword">int</span></span><br><span class="line">	lastIncludedTerm <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	commitIndex <span class="keyword">int</span> <span class="comment">//volatile state on all servers</span></span><br><span class="line">	lastApplied <span class="keyword">int</span></span><br><span class="line">	lastLogIndex <span class="keyword">int</span></span><br><span class="line">	outdate  <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">	nextIndex []<span class="keyword">int</span><span class="comment">//valatile state on leader</span></span><br><span class="line">	matchIndex []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	preSnapShotIndex []<span class="keyword">int</span></span><br><span class="line">	killCh	<span class="keyword">chan</span> <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在完成了前面4个内容之后，一个基本的日志压缩功能就实现了。但是大家也许会发现一个很严重的问题。假设现在Raft leader有50个log，并且这50个log都被压缩为Snapshot了，那么此时它的rf.log应该是空的，如果这时候有新的follower加入集群或者是某些follower刚才掉线了如今重新加入集群，那么大概率它们的log没有达到这50个，但是我们的leader由于执行了日志压缩，leader的log已经是空的了，那leader肯定没办法通过AppendEntries为这些“掉队”的follower发送它们缺少的log，那这不就会造成不一致了吗？</p>
<p>为了解决这个问题，我们还需要在raft中实现InstallSnapshotRPC，允许leader通过这个RPC发送它的Snapshot给follower，只要follwer直接保存了leader的Snapshot，那么它就不用请求缺失的log，而是直接跳跃到了leader的状态。</p>
<p><strong>5.leader使用InstallSnapshotRPC向follower发送新的Snapshot（InstallSnapshot）</strong></p>
<p>首先定义InstallSnapshotRPC的Args和reply</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> InstallSnapshotArgs <span class="keyword">struct</span>&#123;</span><br><span class="line">	Term <span class="keyword">int</span></span><br><span class="line">	LeaderId <span class="keyword">int</span></span><br><span class="line">	LeaderSnapShot []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> InstallSnapshotReply <span class="keyword">struct</span>&#123;</span><br><span class="line">	Term <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要内容是leader的Snapshot数据，其次是LeaderId和Term，这几个变量的用处和lab2中的VoteRequestRPC和AppendEntriesRPC中作用一样，这里就不多说了。</p>
<p>然后我们要编写InstallSnapshotRPC handler，首先RPC的标准部分，判断agrs.term和rf.term，然后…….（RPC基本操作）</p>
<p>之后我们需要对LeaderSnapshot进行解码，这里主要是为了得到Snapshot中的leader.LastIncludedIndex（这里的leader是伪代码，表示leader的成员变量，下同），因为InstallSnapshotRPC的调用和实现都是在raft中，没有与上层kvraft进行交互，所以要得到Snapshot中的LastIncludedIndex只能通过直接解码得到。</p>
<p>然后进行一个判断，当前follower的lastIncludedIndex是否小于LeaderSnapshot的（代码中的tmp.LastIncludedIndex）：</p>
<p>如果不小于，说明这个follower已经拥有跟LeaderSnapshot一样新的Snapshot了，那么函数直接返回</p>
<p>如果小于，那么需要使用LeaderSnapshot更新follower的Snapshot，首先将LeaderSnapshot通过ApplyCh传入kvraft层，让kvraft应用这个Snapshot，并且调用SavaSnapshot保存这个新的Snapshot。之后修改自己的LastIncludedIndex和LastIncludedTerm。</p>
<p>我们还需要根据follower当前的log信息决定如何丢弃旧log，首先判断rf.log[tmp.LastIncludedIndex].Term==tmp.LastIncludedTerm（tmp是指解码后的数据），如果条件为true，说明对于follower而言，它在LastIncludedIndex之前的log都是正确的，那么只需要丢弃在这之前的log就行；如果条件为false，说明不能保证LastIncludedIndex之前，甚至这之后的log是否正确，那么旧需要丢弃全部的log。如果需要丢弃全部log，我们也需要使用LastIncludedIndex来修改rf.lastLogIndex和rf.commitIndex</p>
<p>最后需要修改lastApplied的信息，这一点比较重要，更新了Snapshot相当于整个follower apply了所有LastIncludedIndex之前的log。反之不修改lastApplied的话，下一次apply的时候会apply nil（因为对应下标的log是空的）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RPC handler的主要部分</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> rf.lastIncludedIndex&lt;tmp.LastIncludedIndex&#123;</span><br><span class="line"><span class="comment">//replace the old snapshot and apply the snapshot to kvraft</span></span><br><span class="line">	rf.applyCh&lt;-ApplyMsg&#123;tmp.LastIncludedIndex,<span class="literal">nil</span>,tmp.LastIncludedTerm,<span class="literal">true</span>,args.LeaderSnapShot&#125;</span><br><span class="line">	rf.persister.SaveSnapshot(args.LeaderSnapShot)</span><br><span class="line">	rf.mu.Lock()</span><br><span class="line">	rf.lastIncludedIndex=tmp.LastIncludedIndex</span><br><span class="line">	rf.lastIncludedTerm=tmp.LastIncludedTerm</span><br><span class="line">	<span class="keyword">if</span> rf.log[tmp.LastIncludedIndex].Term==tmp.LastIncludedTerm&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%v clear log before %v\n&quot;</span>,rf.me,tmp.LastIncludedIndex)</span><br><span class="line">		<span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=tmp.LastIncludedIndex;i++&#123;</span><br><span class="line">			_,ok:=rf.log[i]</span><br><span class="line">			<span class="keyword">if</span> ok &#123;</span><br><span class="line">				<span class="built_in">delete</span>(rf.log,i)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%v clear all log entries\nlastIncludedIndex=%v\n&quot;</span>,rf.me,tmp.LastIncludedIndex)</span><br><span class="line">		rf.log=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]Entry)</span><br><span class="line">		rf.log[<span class="number">0</span>]=Entry&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;</span><br><span class="line">		rf.lastLogIndex=tmp.LastIncludedIndex</span><br><span class="line">		rf.commitIndex=tmp.LastIncludedIndex</span><br><span class="line">	&#125;</span><br><span class="line">	rf.persist()</span><br><span class="line">	rf.mu.Unlock()</span><br><span class="line">	rf.lastApplied=max(tmp.LastIncludedIndex,rf.lastApplied)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6.决定发送InstallSnapshotRPC的时机</strong></p>
<p>决定发送InstallSnapshotRPC的时间点非常重要，如果一个follower没有leader.LastIncludedIndex之前的log，但是leader仍然向它发送了AppendEntriesRPC，那么这个follower不会得到中间这一段它缺失的log，但是却会更新它的commitIndex，那么它的applyEntry函数就会更具下标来apply这些缺失的log（也就是nil），造成错误。</p>
<p>根据以上例子我们首先判断知道，如果需要发送InstallSnapshotRPC，那么它一定要在AppendEntriesRPC之前，所以我们首先在Start函数中加入一段发送InstallSnapshotRPC的代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在start()中判断是否发送RPC</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> rf.lastIncludedIndex&gt;rf.matchIndex[server]&#123;  <span class="comment">//install Snapshot</span></span><br><span class="line">	ok:=rf.sendInstallSnapshot(server)</span><br><span class="line">	<span class="keyword">if</span> ok&#123;</span><br><span class="line">		rf.mu.Lock()</span><br><span class="line">		rf.matchIndex[server]=max(rf.lastIncludedIndex,rf.matchIndex[server])</span><br><span class="line">		rf.nextIndex[server]=max(rf.lastIncludedIndex+<span class="number">1</span>,rf.nextIndex[server])</span><br><span class="line">		rf.mu.Unlock()</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于leader而言，它并不能准确的知道每个follwer log的具体情况，那么就使用matchIndex来作为follower log的更新情况，如果leader.lastIncludedIndex&gt;leader.matchIndex[server]，那么说明这个follower需要更新Snapshot，那么就对它发送InstallSnapshot，如果RPC成功那么就需要修改对应的matchIndex和nextIndex。 如果RPC失败，那么我们就应该直接返回，而不应该向下走，否则会导致apply nil（上面提到过这种情况）</p>
<p>在Start添加了InstallSnapshotRPC后，这里还有一点不足，就是如果上层的kvraft没有新的请求，在Start不被调用时，follower就无法通过leader的InstallSnapshotRPC在更新自己，所以我决定在HeartBeat中也加入发送InstallSnapshotRPC的判断。（程序段内容同上）</p>
<p><strong>7.kvraft应用被apply的Snapshot</strong></p>
<p>在InstallSnapshot中我们将新的Snapshot传入applyCh，那么在kvraft处，也需要编写函数来处理这个请求。由于在ApplyMsg中有一个UseSnapshot的bool量来标识当前请求是否是Snapshot，所以我们只需要在kvraft的apply()函数处增加一处判断和对应的处理程序就行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server中apply Snapshot</span></span><br><span class="line"><span class="keyword">if</span> op.UseSnapshot==<span class="literal">true</span>&#123;  </span><br><span class="line">	fmt.Printf(<span class="string">&quot;useSnapShot index:%v\n&quot;</span>,op.Index)</span><br><span class="line">	_=kv.RestoreSnapShot(op.Snapshot)</span><br><span class="line">	<span class="keyword">continue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在apply Snapshot的时候想到了一个问题，从raft apply的Snapshot是否一定要调用RestoreSnapshot？ 假如当前kvraft的状态更新，那么应用了这个Snapshot不就出错了吗？虽然可以知道一开始Leader发送InstallSnapshotRPC的时候就是认为这个follower不含有该Snapshot对应的log，但是这个想法也许并不准确（根据matchIndex来判断是否发送RPC），所以为了防止应用Snapshot出错，我又在RestoreSnapshot中增加了一层条件保护</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kvraft：RestoreSnapshot中的条件保护</span></span><br><span class="line"><span class="keyword">if</span> kv.commitIndex&gt;tmp.LastIncludedIndex&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们前面提到了kvraft中的commitIndex指的是已经应用的log Index，那么如果它的值大于Snapshot中的LastIncludedIndex，就说明当前kvraft的状态比Snapshot中的状态更新。到这里</p>
<p><strong>8.对原有raft代码的修改</strong></p>
<p>完成了以上步骤之后，看似已经完成了lab3B，其实不然，真正的debug之路才刚刚开始（心态爆炸），在加入了discard log这一内容之后，我们原有的raft代码将不再适用于此，需要做许多改进和保护，否则根本跑不动= =</p>
<p>首先是对RequestVoteRPC的修改</p>
<p>我们知道，在RequestVoteRPC中，follower向candidate的条件是</p>
<p>1.candidate.lastLogTerm&gt;follower.LastLogTerm</p>
<p>2.candidate.LastLogTerm=follower.LastLogTerm &amp;&amp; candidate.LastLogIndex&gt;=follower.LastLogIndex</p>
<p>这里就需要考虑一种情况，follower或者Candidate的log因为更新Snapshot而被全部清空，那么我们就不能像原来一样使用rf.log[rf.lastLogIndex].Term来得到它们的LastLogTerm，因为这样得到的Term一定为0，这样就会导致出错，在这种情况下正确的做法应该是使用lastIncludedTerm来作为LastLogTerm参与判断（这也是为什么我们在raft中要保存这个变量的原因）</p>
<p>那么在发送RequestVoteRPC之前，就需要对follower传入RPC的LastLogTerm做一个保护</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送RequestVoteRPC前，对Candidate.LastLogIndex做保护</span></span><br><span class="line"><span class="keyword">if</span> rf.lastIncludedIndex&gt;=rf.lastLogIndex&#123;</span><br><span class="line">	lastLogIndex=rf.lastIncludedIndex</span><br><span class="line">	lastLogTerm=rf.lastIncludedTerm</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	lastLogIndex=rf.lastLogIndex</span><br><span class="line">	lastLogTerm=rf.log[rf.lastLogIndex].Term</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一方面，在执行RequestVote时，也需要对follower的LastLogIndex做保护</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//效果同上，只是写法略微不同</span></span><br><span class="line">lastLogTerm:=max(rf.log[rf.lastLogIndex].Term,rf.lastIncludedTerm) </span><br></pre></td></tr></table></figure>

<p>然后是对AppendEntriesRPC的修改</p>
<p>首先是AppendEntries中的一致性判断，一个leader在刚上位时，它的matchIndex[all]=0，但其他follower的log大概率不是空的（也许经过更新Snapshot的方法导致log变空，但它的新log下标并不是重新从1开始），那么Leader发送的AppendEntries中PrevLogIndex=1；假设follower经历了一次Snapshot，它的log中只保存了index&gt;10的log，那么按照之前的做法，我们会得到follower.log[1].Term=0（因为follower下标为1的log已经被丢弃了），这时leader会认为这个follower的日志跟自己的不一致，那么就引发了错误（这会造成死循环，因为leader不存在term=0的log，它们永远不会匹配成功）</p>
<p>为了解决这种情况，我们应该要在AppendEntriesRPC的一致性判断中加入一个条件。</p>
<p>即如果args.PrevLogIndex&lt;rf.lastIncludedIndex，那么就应当认为这个follower在PrevLogIndex之前的log全部与leader一致（保存为Snapshot的log的一致性已经被确认过了）</p>
<p>在完成了AppendEntries的一致性判断后，我们还需要更改prevLogIndex，否则后续的Append过程会由于 rf.log[prevLogIndex+1].Term≠leader.log[prevLogIndex,导致follower的log被全部清空，所以在执行append之前需要修改一下prevLogIndex</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//确保在后续append过程中，不会有空log参与判断</span></span><br><span class="line">prevLogIndex:=max(args.PrevLogIndex,max(rf.lastIncludedIndex,args.LeaderLastIncludedIndex))</span><br></pre></td></tr></table></figure>

<p>在完成以上修改后，我们发现一个共性，那就是这些问题都是由于更新Snapshot时丢弃了旧Log，但raft仍然使用discardLog.Term，导致出错。</p>
<p>那么我们是不是想一些更简单的做法，比如在一个新的leader上任时，使它的所有<strong>matchIndex=leader.LastIncludedIndex</strong>，这样传入AppendEntriesRPC的prevLogIndex对应的log就不会是空值了。</p>
<p>到这里，lab3B的解析终于结束了，事实我在整个lab中，花费在lab3B的时间应该是最多的（一部分原因是因为那段时间划水严重），不断的debug，每天看着满屏的日志信息都头大，但是最终还是把遇到的bug一个个解决掉了（可能？），建议大家在遇到头大的bug的时候不要硬刚，可以做点其他事情（无限活力！！！）放松一下，不然很容易陷入焦躁，但是却完全改不出bug的困境中。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/12/mit6-824-lab3-kvraft/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="wwow">
      <meta itemprop="description" content="努力可能会成功，但不努力真的很舒服">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wwow's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/12/mit6-824-lab3-kvraft/" class="post-title-link" itemprop="url">MIT-6.824-lab3A-kvraft</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-12 11:52:05" itemprop="dateCreated datePublished" datetime="2020-03-12T11:52:05+08:00">2020-03-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-30 12:46:24" itemprop="dateModified" datetime="2020-08-30T12:46:24+08:00">2020-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mit6-824/" itemprop="url" rel="index"><span itemprop="name">mit6.824</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://github.com/wwow1/MIT-6.824">github地址：https://github.com/wwow1/MIT-6.824</a></p>
<p>lab3的任务是在lab2完成的Raft上构建容错的key-value存储服务。本质上就是使用lab3对应的Put，Append，Get命令来维护一个图，但是在维护过程中使用的这三条命令需要通过Raft来保证一致性。</p>
<h3 id="Part-A-Key-value-service-without-log-compaction"><a href="#Part-A-Key-value-service-without-log-compaction" class="headerlink" title="Part A: Key/value service without log compaction"></a>Part A: Key/value service without log compaction</h3><p>在PartA中我们首先需要完善位于kvraft/client.go与kvraft/server.go中的Put，Append，Get三个RPC，Put用于替换数据库中特定键的值，Append用于将值附加到键原先的值上，Get用于获取键的当前值（当一个键不存在时，Append的作用与Put相同）</p>
<p><strong>client部分:</strong></p>
<p>第一步是完成client.go中的内容，在client端我们需要编写RPC调用函数，这样client就能通过对应的函数向server发送RPC来进行数据操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Clerk <span class="keyword">struct</span> &#123;</span><br><span class="line">	servers []*labrpc.ClientEnd</span><br><span class="line">	opnum <span class="keyword">int</span> <span class="comment">//give each operation a num to prevent it from being executed many times</span></span><br><span class="line">	leaderId  <span class="keyword">int64</span></span><br><span class="line">	mu sync.Mutex</span><br><span class="line">	clientId <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是我的clerk结构，除了已经给定的servers变量以外，使用opnum记录使用者发送的每一次命令（Put，Append，Get），这样在server端可以通过opnum来辨别该命令是否已经执行（Append命令的重复执行就会导致数据错误）</p>
<p>leaderId用于记录server节点的leader编号，这样就不需要每一次发送RPC时重复迭代寻找leader。</p>
<p>mu用于添加互斥锁。clientId为自己的编号，在lab3A中会出现多个client向server发出请求的情况，每一个client的opnum都是从0开始递增，为了防止它们命令的错乱，所以需要clientId来表示client的编号，然后在server处对每一个client的opnum做维护。</p>
<p><strong>注意点</strong>:在raft中当RPC发送失败时会使用一个循环使它的RPC成功之前重复发送该RPC，在client中我也设置了这样的机制，但是这里需要做一些改动，否则会发生死锁</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ok:=ck.servers[ck.leaderId].Call(<span class="string">&quot;RaftKV.PutAppend&quot;</span>,&amp;args,&amp;reply)</span><br><span class="line"><span class="keyword">for</span> !ok&#123;</span><br><span class="line">	ck.leaderId=nrand()%(<span class="keyword">int64</span>(<span class="built_in">len</span>(ck.servers))) <span class="comment">//partition,the server unreachable</span></span><br><span class="line">        ok=ck.servers[ck.leaderId].Call(<span class="string">&quot;RaftKV.PutAppend&quot;</span>,&amp;args,&amp;reply)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在每一次RPC发送失败后，都需要把leaderId使用随机数(或者用循环迭代）的方式改变，与raft不同，这里使client向server发送RPC请求，但是在partition测试中，会出现某几个server断开的情况，此时如果在每次RPC失败后不充值leaderId，会导致不断向断开的server发送请求，而真正的leader却接受不到请求的死锁</p>
<p><strong>Server部分:</strong></p>
<p>第二步我们需要编写server.go中的代码，这一部分主要要完成的内容就是server端的Get和PutAppend的函数，已经对于raft提交的log（也就是Get和Put，Append的请求）的处理。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RaftKV <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu      sync.Mutex</span><br><span class="line">	me      <span class="keyword">int</span></span><br><span class="line">	rf      *raft.Raft</span><br><span class="line">	applyCh <span class="keyword">chan</span> raft.ApplyMsg</span><br><span class="line"></span><br><span class="line">	commitIndex <span class="keyword">int</span></span><br><span class="line">	commitTerm <span class="keyword">int</span></span><br><span class="line">	maxraftstate <span class="keyword">int</span> <span class="comment">// snapshot if log grows this big</span></span><br><span class="line">	applyNum  <span class="keyword">map</span>[<span class="keyword">int64</span>]<span class="keyword">int</span> <span class="comment">//记录start调用的命令序列号</span></span><br><span class="line">	DB <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">	applyMsg <span class="keyword">map</span>[<span class="keyword">int64</span>](<span class="keyword">map</span>[<span class="keyword">int</span>]Msg)</span><br><span class="line">	applyCheck <span class="keyword">map</span>[<span class="keyword">int64</span>]<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span></span><br><span class="line">	killCh	<span class="keyword">chan</span> <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Msg <span class="keyword">struct</span>&#123;</span><br><span class="line">	command Op</span><br><span class="line">	index <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PutAppend和Get的RPC处理函数的结构是大致相似的，我的函数流程大致为:</p>
<p>1.调用rf.GetState查看当前server是否leader，如果不是leader就返回</p>
<p>2.查看applyCheck，如果当前applyCheck[clientId][opnum]的值存在的话说明当前请求已经被执行过了，这时我们只要将执行结果直接返回就行</p>
<p>3.调用rf.start(op)将log加入raft（这里的op是自定义结构，具体内容由自己填写)并将start返回的index作为CommandIndex保存</p>
<p>4.设定一个时间（我设置2s），在这一段时间内，不断的循环访问applyMsg[client][opnum]来确认刚才提交的请求是否已经被raft apply并且被server执行。当定时结束后若请求仍未被执行，就将wrongLeader置为true并且返回</p>
<p>5.在得到applyMsg[clientId][opnum]后，将applyMsg中的成员变量command以及index分别与op和CommandIndex做比较（确定apply的log是我们刚才提交的），如果都相同的话就可以访问applyCheck[clientId][opnum]得到答案返回；如果不是全部相同就将wrongLeader置为true并返回</p>
<p>最后是Apply部分的内容，这个函数需要在StartKVServer被调用时就开始并发执行，它用于响应raft提交到applyCh中的log（也就是请求），其大致流程:</p>
<p>1.开启一个循环 for msg:=range kv.applyCh，不断接受applyCh中的log</p>
<p>2.将msg.Command断言为Op类型 （Command是interface{}，需要断言才能将它认定为Op类型使用）</p>
<p>3.查询applyCheck[clientId][opnum]，如果它的值存在说明这个请求已经被执行过，直接continue</p>
<p>4.根据Command.Operation判断请求类型（Get，Put，Append），然后对kv.DB做对应数据操作，如果是Get请求则将结果写入applyCheck[client][opnum]，否则就对applyCheck[client][opnum]写入空串（写入空串和不写不一样）</p>
<p>5.将Command和msg.Index作为Msg类型变量存入applyMsg[clientId][opnum]，用于判断提交和apply的log是否一致</p>
<p>以上部分就是lab3A的主要内容和实现思路，在3A部分中的坑其实不多，按照给定的要求来做基本上不会遇到什么坑，但还是要提醒大家一下，在独写成员变量时最后都加上锁来保险，特别是访问applyCheck，applyMsg，DB这几个图结构的时候，如果不加锁很容易造成同步独写导致程序异常。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/14/mit-6-824-raft%EF%BC%88%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%B2%E8%A7%A3%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="wwow">
      <meta itemprop="description" content="努力可能会成功，但不努力真的很舒服">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wwow's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/14/mit-6-824-raft%EF%BC%88%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%B2%E8%A7%A3%EF%BC%89/" class="post-title-link" itemprop="url">MIT-6.824-lab2-raft（实验内容+测试用例讲解）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-14 17:39:59" itemprop="dateCreated datePublished" datetime="2020-02-14T17:39:59+08:00">2020-02-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-04 22:32:42" itemprop="dateModified" datetime="2020-09-04T22:32:42+08:00">2020-09-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mit6-824/" itemprop="url" rel="index"><span itemprop="name">mit6.824</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://github.com/wwow1/MIT-6.824">github: https://github.com/wwow1/MIT-6.824（课程实验是按照17年的内容做的）</a></p>
<p>（给大家分享另外一篇关于lab2测试用例的文章，我认为写的很好。<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/1df5b7227719">https://www.jianshu.com/p/1df5b7227719  )</a></p>
<p>前几天终于完成了6.824的lab2，做lab2的时候能明显的感觉到lab2的难度和lab1相比还是有较大提升的，在搜索相关信息的时候也能感觉到，写lab1的blog很多，但写lab2的blog就少得多。写这篇文章主要是给在lab2中遇到困难和瓶颈的同学提供一些思路，还有就是对于实验的测试用例做一个讲解，在lab2中调试占据了实验的很大一部分时间，在调试的过程中如果能够明白测试的内容，也能更加高效的debug。</p>
<p>lab2的任务是根据Raft的论文来实现Raft协议，所以在做lab2之前大家一定要认真的去看Raft的paper，具体的理解Raft的一些机制。对于英语不好的同学也可以参考Raft论文的中文翻译。同时课程主页上也提供了曾经6.824课程助教的博客，博客中提供了许多大家可能犯的错误，在开始实验之前大家务必要花时间去看，这上面的建议和易错点真的非常有用！！！！！</p>
<p><a target="_blank" rel="noopener" href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md">Raft中文翻译:https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md</a></p>
<p>Part A</p>
<p>第一部分的任务是实现领导选举和心跳机制，这一部分比较简单。实验要求在raft.go中编写你的代码，在raft.go中也提供了不同函数的用途以及目前是否需要填写信息。PartA的内容只需要<strong>严格按照Raft论文的Figure2</strong>来做就行。</p>
<p>这里首先要完善Raft结构的内容，还有用于RPC调用的AppendEntriesArgs，AppendEntriesReply，RequestVoteArgs，RequestVoteReply结构体，同时要编写RequestVote和AppendEntries的具体内容，前者是用于领导选举的投票，后者是用于心跳，RequestVote在这一部分不需要加入”up to date”的内容，因为PartA未涉及到日志的内容。而AppendEntries目前只用于心跳，所以只需要在被调用时重置election timeout就行了。</p>
<p>在RPC部分完成后，需要完善Make函数(用于初始化一个节点)，同时在每一个节点中设置election timeout，每一个节点一开始都是follower，当固定时间内未收到心跳或未向candidate投票，则由follower转为candidate，同时发起选举，选举结束后确定下一步的状态（在发起选举后的行为在论文中的Figure2中写的非常详细，照着写就行）</p>
<p>测试1：TestInitialElection2A</p>
<p>使用三个节点，首先确认集群中是否由leader存在（不存在则报错），然后获取集群当前的term，在一小段时间后，再次获取集群的term，在此期间没有任何错误发生，所以前后两次的term应该相同（不同则报错）</p>
<p>测试2：TestReElection2A</p>
<p>使用三个节点，首先确定集群中的leader存在（不存在则报错）记为leader1，然后将leader从集群中断开，这时再次确认集群中是否选举出了新的leader（不存在则报错）</p>
<p>使leader1重返集群，这时再次判断集群中的leader是否存在（不存在则报错），记为leader2，然后将leader2以及另一个server从集群中断开，这时集群中目前只有1个节点，且它的身份为follwer，则这时集群中的1个节点无法选举得到leader（如果集群中存在leader则报错）</p>
<p>使leader2重返集群，集群中存在2个节点，则应该存在leader（不存在则报错）</p>
<p>Part B</p>
<p>第二部分算是lab2中最复杂的一块，同时也非常容易出错。这一部分的任务是实现添加日志，提交日志的功能。与PartA相同，主要是尽可能地按照Figure2的内容做，但是与PartA不同的地方在于，PartB中存在一些Figure2中没有细说的corner case。</p>
<p>我们首先还是完善RPC部分的内容（因为这一部分的内容相对比较独立，且Figure2描述的很清晰），首先是RPC的结构中要加入与log有关的变量，对于RequestVote的处理，只需要在投票前增加一个“as up to date as me”的判断就行（具体内容看paper5.4.1）对于AppendEntries的处理也是按照Figure2的内容来做就行（这一块有一些小问题在后续的测试讲解部分会说到）。</p>
<p>然后是Start函数的填写，该函数是由客户端调用的，每一次调用Start传入一个command，如果当前函数的处理者不是leader则直接返回，如果是leader则开启一个goroutine向所有follower发送AppendEntries来添加日志条目，注意Start函数不应该等待添加日志条目的过程，而应该快速的返回，所以这里要使用goroutine。</p>
<p>最后，还应该拥有日志的提交功能和应用功能，当某个日志条目（该日志条目必须是在本周期被加入日志中）被复制到过半数的server上时，应该将该日志条目提交，在日志条目提交后，还应该被添加到ApplyCh中（“应用”）。对于这两个功能的实现，我的做法是在一个节点被Make时开启一个goroutine来持续性地检测和Apply条目。在节点被选举为leader时，开启一个goroutine来持续性的检测和commit条目（注意只有leader需要检测并commit，follower们在接受AppendEntries的请求时会根据leader的情况来更新自己的commitIndex）</p>
<p>易错点</p>
<p>1.在修改volatile类的变量时（如commitIndex,lastApplied)，要记得加锁，否则很容易尝试错误且难以发现。（例如Start中将条目加入leader的log时要上锁，不然就会出错）。</p>
<p>2.Start中在RPC发送失败时会重复发送直到成功为止，但要防止出现当前节点已经不是leader但是仍然持续发送AppendEntries的情况。</p>
<p>3.leader发送的RPC请求可能乱序，即先发送的RPC后收到，但后发送的RPC先收到。</p>
<p>4.即使是心跳，也要进行prevLog的一致性检查</p>
<p>5.在prevLog能够正确时，每一次AppendEntries RPC应该要将leader的<strong>全部条目</strong>（当前传入的）赋给server。添加日志时nextIndex的值只是一个“试探”，而不应该将它作为新增日志的具体下标。当client<strong>同时</strong>发送5个command给leader时，这五条command使用的nextIndex必定是相同的（nextIndex在AppendEntries返回时才会修改）这种情况下，如果将nextIndex作为下一条新增条目的下标就会造成覆盖。如果不依赖nextIndex，而是在每一次Append调用中都将传入的Log全部更新到server上就不会出问题。</p>
<p>6.<strong>在prevLog正确的情况下</strong>，如果server的Log长度比AppendEntriesArgs中的Log更长的话，切记不能截断多出的部分。这是由于RPC乱序，含有更多条目的AppendEntries先改变了server的Log。如果这里截断server的Log的话，相当于把正确的Log给删除了，且后续它们可能不会再出现（因为含有它们的AppendEntries已经完成了）  </p>
<p>测试3：TestBasicAgree2B</p>
<p>使用5个节点，向集群发送5条命令，查看这五条命令是否被所有节点apply到applyCh中</p>
<p>测试4：TestFailAgree2B</p>
<p>使用3个节点，首先发送一条命令（101），这条命令应该被所有节点接受并apply。</p>
<p>然后将一个server断开，再连续发送4条命令（102，103，104，105）到集群中，这些命令应该被集群中剩下的2个节点接受并apply。</p>
<p>将断开的那个节点恢复，然后发送两条命令（106，107），这两条命令应该被所有节点接受并提交。</p>
<p>（事实上，对于每个节点而言，最终它的日志中都应该包含从101~107的所有命令，即使是曾经从集群中断开也一样）</p>
<p>测试5：TestFailNoAgree2B</p>
<p>使用5个节点，首先发送一条命令（10），每个节点都应接受并apply。</p>
<p>然后将3个follower断开，然后再提交一条命令（20）给集群，这条命令不会被提交。</p>
<p>再将3个follower恢复。再发送一条命令（30），这条命令应该被5个节点都接受并apply，且它的index必须是2或3。</p>
<p>最后再提交一条命令（1000），它也应该被5个节点接受并apply。</p>
<p>（一开始被断开的3个follower之间会选举出一个新leader（称保留在集群中的leader为老leader），在它们返回集群时，两个leader将会比对各自的term，term高的人成为集群最终的leader，如果新leader的term大（不发生故障情况），那么命令（30）的index应该是2；如果老leader的term大，那么命令（30）的index应该是3）</p>
<p>测试6：TestConcurrentStarts2B</p>
<p>使用3个节点，连续快速地发送五个命令（100~104）到集群中，然后查看它们被apply的顺序和Start时返回的次序是否相同，简而言之就是它们能否被顺序提交。</p>
<p>测试7：TestRejoin2B</p>
<p>使用3个节点，设它们为A，B，C，假设A最先成为leader，向集群提交了第一个命令（101），它应该被所有节点接收并apply</p>
<p>断开A，然后向A发送3个命令（102，103，104），由于只有A得到了这3个命令，所以它们不会被提交</p>
<p>A断开后，B与C中选出一个新的leader，这里假设是B，向B发送命令（103），B与C都将接受并apply它</p>
<p>断开B，恢复A，这时在集群中的是A和C，由于选举限制，C会成为leader（必定），然后向C发送命令（104），A与C都会接受并apply它，同时C会对A的日志进行调整。（这时A的日志内容为{101，103，104}）</p>
<p>恢复B，最后发送一条命令（105）到集群中，它将所有节点接受并apply</p>
<p>测试8：TestBackup2B</p>
<p>（这一个测试的命令内容都由随机数生成，但是在debug的时候建议把它们改成固定的数值，否则由于生成随机数都非常大，在打印日志的时候会眼花缭乱）</p>
<p>使用5个节点，假设为A，B，C，D，E，假设A先成为leader，首先发送一条命令（随机数生成，但这里使用我指定的数方便说明），命令（0）</p>
<p>断开C，D，E，向保留在集群中的A与B发送50条命令（-1~-50），由于只有两个节点接受到这50条命令，所以它们不会被提交</p>
<p>将A，B断开，C，D，E恢复，假设恢复后C成为了新的leader，向C，D，E发送50条命令（1~50），这些命令会被C，D，E提交</p>
<p>将D断开，向剩下的C，E发送50条命令（-51~-100），只有两个节点收到这50条命令，所以它们不会被提交</p>
<p>将剩下的节点都断开，恢复A，B，D，然后D会成为leader（选举限制），向A，B，D发送50条命令（51~100），这些命令会被A，B，D提交</p>
<p>将所有节点连接到集群中，发送一条命令（200），它会被全部节点提交</p>
<p><strong>易错情况:</strong></p>
<p>在Rejoin和Backup都可能出现一种很麻烦的情况。以Backup为例，在最后所有节点恢复后，假设A为leader（由于选举限制，只有ABD可能成为leader），这时log[A]={0，1，2，…，50，51，52，…，100}，那么它的commitIdex=101</p>
<p>在C恢复时，log[C]={0，1，2…，50，-51，-52，…，-100}，它的commitIndex=51</p>
<p>C在恢复后会接受到A发送的第一次<strong>心跳(不会把leader的log给follower，只会检查prevlog并且更新commitIndex）</strong>，由于保存在A中的nextIndex[C]&lt;51（即使不是，也会因为nextIndex一直回退，最终变成这样），则prevLog检测正确，<strong>C会根据A的commitIndex更新自己的commitIndex</strong>，然后C的commitIndex=101</p>
<p>之后C就会将本不应该被提交的命令（-50~-100）提交，从而造成“commit index=52 server=C -51 != serverA 51”的错误</p>
<p>造成这个错误最大的原因就是对于重返集群的节点，心跳只会检测prevLog而不会检测整个Log是否与当前leader同步（因为心跳不会传入Log信息），但是心跳又会更新commitIndex（如果在心跳中去除这个功能，前面的测试会出错，造成“one failed to reach argeement”），所以造成了错误。</p>
<p>一开始想到既然是心跳导致的commitIndex错误更新，那么在心跳中不做commitIndex的更新，只在AppendEntryRPC中更新就行啦！但实际上不行…因为对于最后一条log entry而言，它在被发送给follower后，还需要更新commitIndex才能够apply，但是如果我们只在AppendEntryRPC中更新commitIndex的话，这最后一条log entry的commitIndex就不可能被更新（它是最后一条entry，不会再有AppendEntryRPC发送给follower了）</p>
<p>我的解决方法是对重返集群的节点增加一个outdate标记，当outdate标记为真时</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//outdate==true</span></span><br><span class="line"><span class="keyword">if</span> prevLogIndex &gt; rf.commitIndex&#123;</span><br><span class="line">	rf.commitIndex=min(min(prevLogIndex,args.LeaderCommit),rf.lastLogIndex)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>造成错误的原因就是在不一致的条件下更新commitIndex，而在这里我们能保证一致性的就是prevLogIndex及其之前的log，那么我们就用它来更新commitIndex。另一方面，由于HeartBeat会不断改变传入的prevLogIndex的值，所以即使在outdate=true的情况下，follower的commitIndex也会逐步跟上leader（但是效率较低）  </p>
<p>outdate为假时，就跟原先一样</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//outdate==false</span></span><br><span class="line">rf.commitIndex=min(rf.lastLogIndex,args.LeaderCommit)</span><br></pre></td></tr></table></figure>

<p>那么如何检测重返集群的节点呢？我的做法分为两方面，第一是当节点发现自己的term低于其他节点时，就执行outdate=true；第二是当节点的leaderId=-1（这种情况表示它不知道当前leader是谁），也执行outdate=true</p>
<p>上述做法可能会将一直在集群中的节点也打上outdate标记，但这并不影响，在outdate标记存在时，follower也可以通过prevLogIndex和leader.commitIndex来更新自己的commitIndex</p>
<p>appendEntriesRPC</p>
<p>测试9：TestCount2B</p>
<p>这个测试主要是要求RPC的使用次数不能太多，只要election timeout正确，不产生太多选票瓜分，并且心跳间隔符合要求就能通过。</p>
<p>Part C</p>
<p>集群中的节点随时可能crash, 所以我们将一些数据: Log，currentTerm， votedFor，主要编写readPersist和persist方法。在Make方法被调用时立即恢复之前持久化保存的数据。</p>
<p>在Log，currentTerm，votedFor这几个需要持久化的数据改变时调用persist方法更新数据，在Make方法中使用readPersist读取持久化的数据</p>
<p>后续几个关于Figure8和Unreliable的测试主要是在2B的基础上完善逻辑，如果之前写的程序逻辑没问题，其实就可以直接通过。</p>
<p>唯一要注意的一点是，<strong>在AppendEntryRPC中需要加入一个优化，否则有一个测试点会一直卡着过不去。</strong></p>
<p>详细优化情况参照<a target="_blank" rel="noopener" href="https://thesquareplanet.com/blog/students-guide-to-raft/">https://thesquareplanet.com/blog/students-guide-to-raft/</a></p>
<p>这是MIT6.824某个助教写的guide，里面记录了一些大多数学习者都会遇到的corner case及其解决方法，大家如果在哪里卡住了可以参照一下</p>
<p>为了大家方便，我直接将其中有关2C的优化点给截图下来。</p>
<p><img src="https://s1.ax1x.com/2020/09/04/wA8rxf.png" alt="wA8rxf.png"></p>
<p>LAB 2C 有关AppendEntryRPC内部的优化点</p>
<p>当我们在AppendEntryRPC中发现Leader传入的prevLog和follower冲突时，我们就会返回，并在leader中回退prevLogIndex，我们原先的做法就是一次回退一步；但是这样会比较慢，如果leader和follower的Log之间差异过大的话，我们需要发送多次AppendEntry来回退prevLogIndex。为了加速回退过程，我们在每次回退的时候，可以回退到上一个term提交的log处，具体的处理方式在上图中说的比较详细。</p>
<p>总结</p>
<p>在做lab2的时候才真正感受到了分布式系统debug真是太痛苦了，我这个菜鸡就只能用print把状态信息打出来慢慢分析，甚至有些错误是概率性发生的，这跟单机调试完全不一样。但是在完成了这个实验之后也很有成就感。（虽然程序还有很多date race，以后有时间在改把= =）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/23/mapreduce%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="wwow">
      <meta itemprop="description" content="努力可能会成功，但不努力真的很舒服">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wwow's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/23/mapreduce%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Mapreduce读书笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-23 19:19:57" itemprop="dateCreated datePublished" datetime="2020-01-23T19:19:57+08:00">2020-01-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-04 22:33:22" itemprop="dateModified" datetime="2020-09-04T22:33:22+08:00">2020-09-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mit6-824/" itemprop="url" rel="index"><span itemprop="name">mit6.824</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>1.介绍</p>
<p>MapReduce是一个用于处理大数据集的编程框架，它能够使没有任何分布式开发经验的程序员也能够使用大型分布式系统来进行数据处理。对于大多数使用者而言，他们只需要根据自己的需要编写MapReduce中的map函数和reduce函数就能够很容易的实现大规模并行化计算，同时MapReduce模型也提供了一定程度的错误处理。</p>
<p>2.编程模型</p>
<p>MapReduce编程模型的原理是：利用一个输入key/value pair集合来产生一个输出的key/value pair集合。MapReduce库的用户用两个函数表达这个计算：Map和Reduce。</p>
<p>用户编写的map函数得到一个输入的key/value pair，然后产生一系列中间的key/value pair。然后Mapreduce库会将所有具有相同key值的中间value值集合起来传递给reduce函数</p>
<p>用户编写的reduce函数得到一个输入的key值和一个与key值向对应的value值的集合。reduce函数将这些值合并起来，产生一个较小的value值的集合作为结果（每次reduce调用一般只产生0或1个输出value值)</p>
<p>3.实现</p>
<p>3-1执行流程</p>
<p><img src="https://s1.ax1x.com/2020/09/04/wA80PI.png" alt="wA80PI.png"></p>
<p>1.MapReduce库会将输入数据划分为M份（每份一般为16~64MB，可设置参数调整）然后将会把程序复制到集群中的每一台机器中</p>
<p>2.在所有机器中，会存在一个Master，而其他机器都被称为worker，Master会为worker分配任务。共有M个map任务以及R个reduce任务需要被分配。master将会为每个空闲的worker分配一个map任务或reduce任务。（worker在一个时刻只能执行一个任务，但每个worker一般需要顺序的执行多个任务）</p>
<p>3.被分配map任务的worker（称之为 map worker）将会读取对应的输入文件块，它从输入文件块中提取出一个key-value pair集合，并且将这个集合传入用户定义的Map函数。由Map函数产生的中间key-value pair集合将会暂时缓存在内存中</p>
<p>4.缓存在内存中的中间key-value pair会周期性地被分区函数划分为R份，并将其写入到Map worker的本地磁盘中。这些中间key-value pair的存储地址与长度将会被发送给Master，Master在之后的过程中需要将这些数据的地址发送给reduce worker</p>
<p>5.当一个worker被Master分配执行reduce任务后（称它为reduce worker），它将通过RPC（远程过程调用）读取存储在map worker磁盘上的中间key-value pair，在将这些数据全部读入后，reduce worker会将这些中间key-value pair根据key值进行一次排序，这样能够便于得到拥有相同key值的中间key-value pair。</p>
<p>6.在排序后，reduce worker将传递一个key值以及一个与该key值相对应的value集合（这里的key和value都是map函数生成的中间key-value pair中的内容）给用户定义的Reduce函数，Reduce函数的输出将被添加到最终输出文件中（由全局文件系统管理，而不是像map过程一样保存在本地)</p>
<p>7.当所有map任务和reduce任务完成，Master将唤醒用户程序，这时，MapReduce的调用就结束了。</p>
<p>3-2 Master的数据结构</p>
<p>Master中存储了每个map任务以及reduce任务的状态(闲置，处理中，完成)以及每一个worker机器的状态（是否处于空闲状态）</p>
<p>同时，Master还需要保存Map任务产生的中间key-value pair的保存地址，对于每一个已经完成的map任务而言，Master需要保存该map任务存储数据的R个地址和大小（每一个map任务的输出内容被划分为R份保存)这些被Master保存的地址信息将会被发送到reduce worker</p>
<p>4.容错</p>
<p>1.worker故障</p>
<p>Master会周期性的ping每一个worker，如果在确定的时间内，被ping的worker没有响应则认为这个worker故障了。因为map任务的输出结果是保存在本地的，如果该worker故障了，后续的reduce worker将无法获取需要的中间文件，所以所有被故障worker执行过的map任务需要交由其他worker再次执行。而reduce任务则没有这样的要求，它的输出结果并不是保存在本地。对于故障worker正在执行的任务而言，只需要将这个任务交由其他worker执行就可以了。</p>
<p>2.Master故障</p>
<p>周期性的将Master节点的信息保存，如果Master故障了，只需要从内存中copy出一个新的Master就行了。但是在论文中介绍，对于Master节点的故障，原作者采用的是直接结束程序的方法来向使用者反应错误。</p>
<p>5.数据存储</p>
<p>（在论文发表时)网络带宽是较为稀缺的资源，也最容易成为MapReduce的性能瓶颈，所以我们希望能够尽量少的使用网络资源，转而尽量使用本地读取的方式提高程序的性能。MapReduce将输入数据划分为多个64MB的blocks，然后将这些blocks以及它们的复制（一般复制3份）保存在构成集群的机器上。MapReduce会将map任务尽量分配给具有对应输入数据(或是存有输入数据复制）的机器上，如果这一点无法做到，它也会将map任务分配到与存有对应输入数据处于同一个交换网络中的其他机器上，尽可能的节约网络带宽资源。</p>
<p>6.任务粒度</p>
<p>我们将map阶段分为M份，reduce阶段分为R份。事实上M和R的数值要远大于集群中的机器数量。对于每一个机器而言，它需要执行多个任务来保证负载均衡以及加速在机器故障时系统的恢复速度。</p>
<p>对于M和R的取值也是有一定标准的，R的取值一般由用户指定，因为每一个reduce任务都会生成一个独立的输出文件。同时在实际的使用时，我们也会选取合适的M使得每一个任务都处理大约16~64MB的数据（这样上述的本地存储优化策略才最有效)，对于R而言，一般将R值设置为集群中worker机器数量的一个小的倍数值。</p>
<p>7.备用任务</p>
<p>在map阶段以及reduce阶段即将完成时，时常会出现在执行最后几个任务时消耗了大量时间导致整个程序的执行时间被拖长的情况，这可能由多种原因引起，如磁盘出错。所以MapReduce设置了备用任务，在map阶段或reduce阶段即将结束时，Master会向部分空闲的worker发送还未完成的任务（会导致最后几个未完成的任务由多个worker共同执行），在多个执行相同任务的worker中，只要由一个完成了该任务，则Master视为该任务完成。这样大大提高了MapReduce的执行效率。</p>
<p>8.使用技巧</p>
<p>1.分区函数：它被用于划分map函数生成的中间key-value pair，对于缺省的分区函数，会默认使用hash的方法划分中间数据，但用户也可以自己编写分区函数来指定具体的数据划分方式。</p>
<p>2.顺序保证：在给定的划分中，中间key-value pair将会按照key值递增的方式排序。</p>
<p>3.合并函数：它的作用是在map worker本地先进行一次中间数据的合并，类似于reduce的作用，合并函数和reduce函数最大的区别是合并函数的输出结果是作为输出文件传递给reduce函数进行后续的处理，而reduce函数的输出会被写入到最终输出文件中。</p>
<p>（中间略去了几点我没怎么使用到，并且理解不太好的内容）</p>
<p>4.跳过损坏记录：有时代码中出现了bug导致Map或Reduce函数在执行过程中出错，导致整个MapReduce无法完成。正常来说我们需要先修复bug再运行程序。但有时找出bug需要耗费大量的时间，另一方面也许这个bug在当前阶段是可以接受的。这时MapReduce提供了一种执行模式，在这个模式下MapReduce会检测代码那些部分出错了，并且跳过这一步部分暂不处理。</p>
<p>在执行Map或Reduce操作前，MapReduce库通过全局变量保存记录序号（我的理解应该就是代码的行列数？）如果用户程序触发了错误，消息处理函数会“用最后一口气”向master发送处理的最后一条记录的序号。当master发现在某个记录出多次失败时，就认为这条记录需要被跳过，在下次重新执行这个任务时会跳过这条记录</p>
<p>5.本地执行：在分布式系统中调试bug时非常困难的，MapReduce提供了本地版本的库，可以使整个MapReduce过程都在本地计算机上顺序执行，这样用户可以在本地上控制MapReduce操作的执行，能够更好的调试程序。</p>
<p>6.状态信息：Master可以显示一组状态信息，用户可以监控各种信息。包括了计算执行的进度，例如完成的任务数，正在处理的任务数，处理的百分比等。更进一步的，最顶层的状态页面还会显示那些worker失效了，并显示它们失效时执行的Map和Reduce任务，这些信息在debug时也会提供很大帮助。</p>
<p>7.计数器：MapReduce库使用计数器统计不同事件的发生次数，例如以及处理的单词数，被索引的文档数等。</p>
<p>（论文之后的内容主要是MapReduce的性能分析以及一些相关工作的介绍，对于目前的我而言这些内容没有太大意义，并且我认为这些内容直接阅读原论文效果会更好，所以就不整理出来了。）</p>
<p>9.总结</p>
<p>MapReduce作为一个编程框架对于没有大规模分布式系统开发经验的使用者是非常友好的，它向使用者隐去了底层分布式系统的细节，用户只需要根据自己的需要填写Map函数和Reduce函数就能够直接开始进行大规模数据的处理，同时，MapReduce也提供了一定的性能优化以及基本的容错机制。对于我这样的分布式系统学习者而言，MapReduce也是一个很好的学习资料能够让我们理解一个分布式系统的运行过程以及构建系统中需要考虑的因素。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/22/mit6-824-lab1-mapreduce/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="wwow">
      <meta itemprop="description" content="努力可能会成功，但不努力真的很舒服">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wwow's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/22/mit6-824-lab1-mapreduce/" class="post-title-link" itemprop="url">MIT-6.824 lab1-mapreduce</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-22 22:34:30" itemprop="dateCreated datePublished" datetime="2020-01-22T22:34:30+08:00">2020-01-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-30 12:43:34" itemprop="dateModified" datetime="2020-08-30T12:43:34+08:00">2020-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mit6-824/" itemprop="url" rel="index"><span itemprop="name">mit6.824</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://github.com/wwow1/MIT-6.824">github: https://github.com/wwow1/MIT-6.824</a></p>
<p>最近几天开始学习MIT6.824的分布式系统课程，现在刚完成了lab1部分的内容，就跟大家分享一下lab1的内容以及一些坑。总体而言，lab1的内容还是相对简单的，但是由于我对于go语言较为陌生，对于go的标准库也不熟悉，所以在语言这方面踩了很多坑。</p>
<p>前两个部分我们将在sequential模式下顺序执行程序。而在后面几个部分的实验中将在distributed模式下并发执行。</p>
<p>Part I: Map/Reduce input and output</p>
<p>第一部分的任务是要我们填写在common_map.go中的doMap()函数以及common_reduce.go中的doReduce()函数。</p>
<p>doMap()函数首先读入输入文件inFile的内容，再将文件名以及文件内容作为输入调用Map函数，然后创建R(在文件中为nReduce)个中间文件用于保存Map函数输出的中间键值对，这R个文件的文件名通过函数reduceName生成。最后通过调用ihash函数将所有中间键值对按key值分配到R个文件中(注意这里要求使用json格式写入)</p>
<p>doReduce()函数首先要读入对应的M(在文件中为nMap)个中间文件的数据，然后对这些数据按照它们的key值进行排序，将具有相同key值的键值对集合起来作为参数调用reduce函数，最后将每一个reduce函数的输出写入输出文件outFile中(读出和写入都要注意json格式)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doMap</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	jobName <span class="keyword">string</span>, // the name of the MapReduce job</span></span></span><br><span class="line"><span class="function"><span class="params">	mapTaskNumber <span class="keyword">int</span>, // which <span class="keyword">map</span> task this is</span></span></span><br><span class="line"><span class="function"><span class="params">	inFile <span class="keyword">string</span>,</span></span></span><br><span class="line">	nReduce int, // the number of reduce task that will be run (&quot;R&quot; in the paper)</span><br><span class="line">	mapF <span class="function"><span class="keyword">func</span><span class="params">(file <span class="keyword">string</span>, contents <span class="keyword">string</span>)</span> []<span class="title">KeyValue</span>,</span></span><br><span class="line">) &#123;</span><br><span class="line">	data,err:=ioutil.ReadFile(inFile)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;File reading error&quot;</span>,err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	immediaKV :=mapF(inFile,<span class="keyword">string</span>(data))</span><br><span class="line">	FileGroup := <span class="built_in">make</span>([]*json.Encoder, nReduce)</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt; nReduce;i++ &#123;</span><br><span class="line">		name:=reduceName(jobName,mapTaskNumber,i)</span><br><span class="line">		file,err:=os.Create(name)</span><br><span class="line">		<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;File create error&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">defer</span> file.Close()</span><br><span class="line">		&#125;</span><br><span class="line">		enc := json.NewEncoder(file)</span><br><span class="line">		FileGroup[i]=enc</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _,kv:=<span class="keyword">range</span>(immediaKV) &#123;</span><br><span class="line">		err:=FileGroup[ihash(kv.Key)%nReduce].Encode(&amp;kv)</span><br><span class="line">		<span class="keyword">if</span> err!=<span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;File write error&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doReduce</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	jobName <span class="keyword">string</span>, // the name of the whole MapReduce job</span></span></span><br><span class="line"><span class="function"><span class="params">	reduceTaskNumber <span class="keyword">int</span>, // which reduce task this is</span></span></span><br><span class="line"><span class="function"><span class="params">	outFile <span class="keyword">string</span>, // write the output here</span></span></span><br><span class="line">	nMap int, // the number of map tasks that were run (&quot;M&quot; in the paper)</span><br><span class="line">	reduceF <span class="function"><span class="keyword">func</span><span class="params">(key <span class="keyword">string</span>, values []<span class="keyword">string</span>)</span> <span class="title">string</span>,</span></span><br><span class="line">) &#123;</span><br><span class="line">	KVmap:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]([]<span class="keyword">string</span>))</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;nMap;i++ &#123;</span><br><span class="line">		name:=reduceName(jobName,i,reduceTaskNumber)</span><br><span class="line">		file,_:=os.Open(name)</span><br><span class="line">		dec:=json.NewDecoder(file)</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">var</span> tmp KeyValue</span><br><span class="line">			err:=dec.Decode(&amp;tmp)</span><br><span class="line">			<span class="keyword">if</span> err!=<span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			KVmap[tmp.Key]=<span class="built_in">append</span>(KVmap[tmp.Key],tmp.Value)</span><br><span class="line">		&#125;</span><br><span class="line">		file.Close()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> KeySort []<span class="keyword">string</span></span><br><span class="line">	<span class="keyword">for</span> k,_:=<span class="keyword">range</span>(KVmap)&#123;</span><br><span class="line">		KeySort=<span class="built_in">append</span>(KeySort,k)</span><br><span class="line">	&#125;</span><br><span class="line">	sort.Strings(KeySort)</span><br><span class="line">	output,err:=os.Create(outFile)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	enc:=json.NewEncoder(output)</span><br><span class="line">	<span class="keyword">for</span> _,v:=<span class="keyword">range</span>(KeySort) &#123;</span><br><span class="line">		err = enc.Encode(KeyValue&#123;v, reduceF(v, KVmap[v])&#125;)</span><br><span class="line">		<span class="keyword">if</span> err!=<span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	output.Close()</span><br></pre></td></tr></table></figure>

<p>Part II: Single-worker word count</p>
<p>第二部分的任务是编写位于main/wc.go文件中的mapF()和reduceF()函数，要求能够对输入文件的每一个单词的出现次数进行统计。</p>
<p>mapF()函数输入的key值是要处理文件的文件名，value值是文件内容，只需要调用strings.FieldsFunc函数将value值划分为一个单词数组，最后将单词数组改写为KeyValue数组。(这里提示一下，FieldsFunc函数的划分使用 isLetter函数而不是 isSpace函数）</p>
<p>reduceF()函数则非常简单，将输入的value数组使用strconv库转换为整形进行累加，累加完毕后再将数字转换为字符串返回。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapF</span><span class="params">(filename <span class="keyword">string</span>, contents <span class="keyword">string</span>)</span> []<span class="title">mapreduce</span>.<span class="title">KeyValue</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ans []mapreduce.KeyValue</span><br><span class="line">	<span class="keyword">var</span> keyList []<span class="keyword">string</span>=strings.FieldsFunc(contents,<span class="function"><span class="keyword">func</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span> &#123;<span class="keyword">return</span> !unicode.IsLetter(r)&#125;)</span><br><span class="line">	<span class="keyword">for</span> _,key:=<span class="keyword">range</span>(keyList) &#123;</span><br><span class="line">		ans=<span class="built_in">append</span>(ans,mapreduce.KeyValue&#123;key,<span class="string">&quot;1&quot;</span>&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reduceF</span><span class="params">(key <span class="keyword">string</span>, values []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ans <span class="keyword">int</span>=<span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _,times:=<span class="keyword">range</span>(values) &#123;</span><br><span class="line">		tmp,_:=strconv.Atoi(times)</span><br><span class="line">		ans+=tmp</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> strconv.Itoa(ans)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Part Ⅲ：Distributing MapReduce tasks</p>
<p>第三部分要求完成mapreduce/schedule.go中的schedule()函数，schedule()函数的任务是向每一个worker并行的分发任务(在map阶段是map任务，reduce阶段就是reduce任务)，要注意一般而言任务的数量是多于worker的数量的，这意味着每一个worker都要执行多个任务，但在某一个时刻，每个worker都只能执行一个任务，这就需要schedule函数来规划具体的任务分配。schedule函数通过call函数（定义在mapreduce/common_rpc.go）来向不同的worker分配任务。同时只有在全部任务执行完毕时schedule函数才会返回。（Part Ⅲ和Part Ⅳ的代码一并给出)</p>
<p>Part Ⅳ：Handling worker failures</p>
<p>第四部分要求对mapreduce进行简单的错误处理，在第三部分的基础上改进schedule函数，要求能够对于worker出错的情况进行处理。处理机制比较简单，只需要将出错的worker排出工作列表，同时将执行失败的任务分发给其他worker再次执行就可以了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">(jobName <span class="keyword">string</span>, mapFiles []<span class="keyword">string</span>, nReduce <span class="keyword">int</span>, phase jobPhase, registerChan <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ntasks <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> n_other <span class="keyword">int</span> <span class="comment">// number of inputs (for reduce) or outputs (for map)</span></span><br><span class="line">	<span class="keyword">switch</span> phase &#123;</span><br><span class="line">	<span class="keyword">case</span> mapPhase:</span><br><span class="line">		ntasks = <span class="built_in">len</span>(mapFiles)</span><br><span class="line">		n_other = nReduce</span><br><span class="line">	<span class="keyword">case</span> reducePhase:</span><br><span class="line">		ntasks = nReduce</span><br><span class="line">		n_other = <span class="built_in">len</span>(mapFiles)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Schedule: %v %v tasks (%d I/Os)\n&quot;</span>, ntasks, phase, n_other)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> completedTask <span class="keyword">int</span>=<span class="number">0</span></span><br><span class="line">	<span class="keyword">var</span> Taskchan=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,ntasks)</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;ntasks;i++&#123; <span class="comment">//用管道当作队列来储存待处理的任务号</span></span><br><span class="line">		Taskchan&lt;-i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> FirstTaskMark <span class="keyword">bool</span>=<span class="literal">false</span></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">var</span> closeMark <span class="keyword">bool</span>=<span class="literal">false</span></span><br><span class="line">	<span class="keyword">for</span> addr:=<span class="keyword">range</span>(registerChan) &#123;</span><br><span class="line">		<span class="keyword">if</span>(addr==<span class="string">&quot;close&quot;</span>)&#123; <span class="comment">//任务结束</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">string</span>)</span></span> &#123;  <span class="comment">//要传入参数，否则会出现在同一个worker上执行多个任务的情况</span></span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			<span class="keyword">for</span> completedTask &lt; ntasks &#123;</span><br><span class="line">				<span class="keyword">var</span> now <span class="keyword">int</span>=&lt;-Taskchan</span><br><span class="line">				<span class="keyword">var</span> tmp=DoTaskArgs&#123;jobName,mapFiles[now],phase,now,n_other&#125;</span><br><span class="line">				ok:=call(v, <span class="string">&quot;Worker.DoTask&quot;</span>, &amp;tmp, <span class="literal">nil</span>)</span><br><span class="line">				<span class="keyword">if</span> ok &#123;</span><br><span class="line">					<span class="keyword">if</span> !FirstTaskMark&#123;</span><br><span class="line">						FirstTaskMark=<span class="literal">true</span></span><br><span class="line">					&#125;</span><br><span class="line">					completedTask++</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123; <span class="comment">//worker出错，将当前执行的任务加入任务队列，同时返回函数（相当于弃置该worker）</span></span><br><span class="line">					<span class="keyword">if</span> now==<span class="number">0</span> &amp;&amp; FirstTaskMark &#123;</span><br><span class="line">					&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">						Taskchan&lt;-now</span><br><span class="line">						<span class="keyword">return</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> !closeMark &#123;</span><br><span class="line">				registerChan&lt;-<span class="string">&quot;close&quot;</span> <span class="comment">//传递结束信号</span></span><br><span class="line">				<span class="built_in">close</span>(Taskchan)  <span class="comment">//关闭管道，防止等待</span></span><br><span class="line">				closeMark=<span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(addr)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Schedule: %v phase done\n&quot;</span>, phase)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回顾自己Part Ⅲ和Part Ⅳ的代码，发现代码非常的冗余，加了太多特判。我在网上查找到另外一种更加简洁的解决方案，在这里也一并贴出</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mr *Master)</span> <span class="title">schedule</span><span class="params">(phase jobPhase)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ntasks <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> nios <span class="keyword">int</span> <span class="comment">// number of inputs (for reduce) or outputs (for map)</span></span><br><span class="line">    <span class="keyword">switch</span> phase &#123;</span><br><span class="line">    <span class="keyword">case</span> mapPhase:</span><br><span class="line">        ntasks = <span class="built_in">len</span>(mr.files)</span><br><span class="line">        nios = mr.nReduce</span><br><span class="line">    <span class="keyword">case</span> reducePhase:</span><br><span class="line">        ntasks = mr.nReduce</span><br><span class="line">        nios = <span class="built_in">len</span>(mr.files)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Schedule: %v %v tasks (%d I/Os)\n&quot;</span>, ntasks, phase, nios)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ntasks; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(taskNum <span class="keyword">int</span>, nios <span class="keyword">int</span>, phase jobPhase)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                <span class="keyword">var</span> args DoTaskArgs</span><br><span class="line"></span><br><span class="line">                worker := &lt;-registerChan</span><br><span class="line">                args.JobName = jobName</span><br><span class="line">                args.File = files[taskNum]</span><br><span class="line">                args.Phase = phase</span><br><span class="line">                args.TaskNumber = taskNum</span><br><span class="line">                args.NumOtherPhase = nios</span><br><span class="line"></span><br><span class="line">                ok := call(worker, <span class="string">&quot;Worker.DoTask&quot;</span>, &amp;args, <span class="built_in">new</span>(<span class="keyword">struct</span>&#123;&#125;))</span><br><span class="line">                <span class="keyword">if</span> ok &#123;</span><br><span class="line">                    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                        registerChan &lt;- worker</span><br><span class="line">                    &#125;()</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(i, n_other, phase)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Schedule: %v phase done\n&quot;</span>, phase)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Part V：Inverted index generation</p>
<p>最后一个部分要求我们填写位于main/ii.go中的mapF()和reduceF()函数，完成倒排索引。倒排索引的意思是根据给定的部分内容或关键字，索引得到这一部分内容或关键字的文档出处。我觉得倒排索引最典型的应用就是搜索引擎，根据用户输入的关键词来查找文档以及网页信息。但在这部分实验中我们要完成的内容非常简单。首先mapF函数将输入的文件内容划分为多个word，然后将每一个划分出的word作为key值，输入文件名作为value值创建Key-value pair作为中间值。reduceF函数则需要剔除相同的value值(因为我们只需要知道这个word出现在哪些文件，不需要知道该word在这个文件中具体的出现次数），然后对剩余的value进行计数，同时将value(文件名)保存，最后将所有value保存在一个字符串里返回。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapF</span><span class="params">(document <span class="keyword">string</span>, value <span class="keyword">string</span>)</span> <span class="params">(res []mapreduce.KeyValue)</span></span> &#123;</span><br><span class="line">	words:=strings.FieldsFunc(value,<span class="function"><span class="keyword">func</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span>&#123;<span class="keyword">return</span> !unicode.IsLetter(r)&#125;)</span><br><span class="line">	<span class="keyword">for</span> _,word:=<span class="keyword">range</span>(words) &#123;</span><br><span class="line">		res=<span class="built_in">append</span>(res,mapreduce.KeyValue&#123;word,document&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reduceF</span><span class="params">(key <span class="keyword">string</span>, values []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="comment">//防止重复计数，需要map</span></span><br><span class="line">    <span class="keyword">var</span> check=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">var</span> tmp []<span class="keyword">string</span></span><br><span class="line">    <span class="keyword">for</span> _,file:=<span class="keyword">range</span>(values) &#123;</span><br><span class="line">    	_,ok:=check[file]</span><br><span class="line">    	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">    		check[file]=<span class="number">1</span></span><br><span class="line">    		tmp=<span class="built_in">append</span>(tmp,file)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	sort.Strings(tmp)</span><br><span class="line">	length:=<span class="built_in">len</span>(tmp)</span><br><span class="line">	<span class="keyword">var</span> res <span class="keyword">string</span>=strconv.Itoa(length)+<span class="string">&quot; &quot;</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;length;i++ &#123;</span><br><span class="line">		res+=tmp[i]</span><br><span class="line">		<span class="keyword">if</span> i!=length<span class="number">-1</span> &#123;</span><br><span class="line">			res+=<span class="string">&quot;,&quot;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结</p>
<p>在做lab1之前读了mapreduce的论文，第一次读英文论文花了好长时间(还借助了中文翻译的文档)，但是完成了之后还是很开心的，感觉自己变强了！！！（其实没有），在做lab1的时候花了很多时间卡在了go的一些语法以及标准库函数的使用上，并且在测试程序的时候也在WSL上面踩了坑，在WSL上的diff命令似乎收到编码格式的影响，导致明明结果对了但是diff却认为我的输出和标准输出不一样，最后还是换了虚拟机才跑通…不过最后也算是比较顺利的完成了lab1(指导书里的hint真的非常有用，要认真看！！)，希望在寒假结束之前能够完成lab2吧~</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/06/csp-%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E7%AA%97%E5%8F%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="wwow">
      <meta itemprop="description" content="努力可能会成功，但不努力真的很舒服">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wwow's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/06/csp-%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E7%AA%97%E5%8F%A3/" class="post-title-link" itemprop="url">CSP-消息传递窗口</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-06 21:47:38" itemprop="dateCreated datePublished" datetime="2019-12-06T21:47:38+08:00">2019-12-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-30 11:59:23" itemprop="dateModified" datetime="2020-08-30T11:59:23+08:00">2020-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【题目描述】<br>老师给了 T 份 MPI 的样例代码，每份代码都实现了 n 个进程通信。这些进程标号 从 0 到 n − 1，每个进程会顺. 序. 执. 行. 自己的收发指令，如:“S x”，“R x”。“S x”表示向 x 号进程发送数据，“R x”表示从 x 号进程接收数据。每一对收发命令必须匹配执行才 能生效，否则会“死锁”。<br>举个例子，x 号进程先执行发送命令“S y”，y 号进程必. 须. 执行接送命令“R x”，这 一对命令才执行成功。否则 x 号进程会一直等待 y 号进程执行对应的接收命令。反之， 若 y 号进程先执行接收命令“R x”，则会一直等待 x 号进程执行发送命令“S y”，若 x 号进程一直未执行发送命令“S y”，则 y 号进程会一直等待 x 号进程执行对应的发送 命令。上述这样发送接收命令不匹配的情况都会造成整个程序出现“死锁”。另外，x 号.进.程.不.会.执.行.“S x”或.“R x”，即.不.会.从.自.己.的.进.程.收.发.消.息.。<br>现在老师请你判断每份样例代码是否会出现“死锁”的情况。每个进程的指令最少 有 1 条，最多有 8 条，这些指令按顺序执行，即第一条执行完毕，才能执行第二条，依 次到最后一条。<br>【输入格式】<br>从标准输入读入数据。<br>输入第一行两个正整数 T, n，表示有 T 份样例代码，实现了 n 个进程通信。 接下来有 T × n 行，每行有若干个(1 − 8 个)字符串，相邻之间有一个空格隔开，<br>表示相应进程的收发指令。不存在非法指令。对于第 2 + i, 0 ≤ i ≤ (T × n − 1) 行，表示 第 i ÷ n(商)份代码的 i ??? n(余数)号进程的收发指令。<br>(比如，“S1”表示向 1 号进程发送消息，“R1”表示从 1 号进程接收消息。细节请 参考样例。)<br>【输出格式】<br>输出到标准输出。<br>输出共 T 行，每行一个数字，表示对应样例代码是否出现“死锁”的情况。1 表示 死锁，0 表示不死锁。<br>第 16 次 CCF CSP 认证<br>【题目背景】</p>
<h3 id="【样例-1-输入】"><a href="#【样例-1-输入】" class="headerlink" title="【样例 1 输入】"></a>【样例 1 输入】</h3><p>3 2<br>R1 S1<br>S0 R0<br>R1 S1<br>R0 S0<br>R1 R1 R1 R1 S1 S1 S1 S1<br>S0 S0 S0 S0 R0 R0 R0 R0</p>
<h3 id="【样例-1-输出】"><a href="#【样例-1-输出】" class="headerlink" title="【样例 1 输出】"></a>【样例 1 输出】</h3><p>0 1 0</p>
<h3 id="【样例-1-解释】"><a href="#【样例-1-解释】" class="headerlink" title="【样例 1 解释】"></a>【样例 1 解释】</h3><p>消息传递接口(mpi)<br>第 1 份代码中，(1)0 号进程执行的“R1”和 1 号进程执行的“S0”成功执行;(2) 0 号进程执行的“S1”和 1 号进程执行的“R0”成功执行，所以未发生“死锁”，程序 顺利运行。<br>第 1 份代码中，(1)0 号进程执行的“R1”和 1 号进程执行的“R0”一直在等待 发送命令，进入“死锁”状态。</p>
<h3 id="【样例-2-输入】"><a href="#【样例-2-输入】" class="headerlink" title="【样例 2 输入】"></a>【样例 2 输入】</h3><p>2 3<br>R1 S1<br>R2 S0 R0 S2<br>S1 R1<br>R1<br>R2 S0 R0<br>S1 R1</p>
<h3 id="【样例-2-输出】"><a href="#【样例-2-输出】" class="headerlink" title="【样例 2 输出】"></a>【样例 2 输出】</h3><p>0 1</p>
<h2 id="【样例-2-解释】"><a href="#【样例-2-解释】" class="headerlink" title="【样例 2 解释】"></a>【样例 2 解释】</h2><p>第 1 份代码中，(1)2 号进程执行的“S1”和 1 号进程执行的“R2”成功执行;(2) 0 号进程执行的“R1”和 1 号进程执行的“S0”成功执行;(3)0 号进程执行的“S1” 和 1 号进程执行的“R0”成功执行;(4)1 号进程执行的“S2”和 2 号进程执行的<br>“R1”成功执行;所以未发生“死锁”，程序顺利运行。<br>第 1 份代码中，(1)2 号进程执行的“S1”和 1 号进程执行的“R2”成功执行;(2)<br>0 号进程执行的“R1”和 1 号进程执行的“S0”成功执行;(3)1 号进程执行的“R0” 和 2 号进程执行的“R1”一直在等待发送命令;进入“死锁”状态。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>最简单的方法就是暴力模拟，对于每一个收发指令都从头到尾遍历一遍数据，但是在数据量大的情况下，这样的匹配效率非常低，但是好在这一题的测试数据比较水，直接采用暴力的方法应该也能够得到大部分分数，进行适度优化也许能直接AC= =</p>
<p>但是我使用的是另一种做法，可以算是对于暴力做法进行了优化，最终时间上也确实加快了很多，先贴上关键代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">int match()&#123;   &#x2F;&#x2F;使用邻接表的形式存储所有进程的收发指令</span><br><span class="line">    int i&#x3D;0; int tmp&#x3D;0; int target&#x3D;0; bool opr;</span><br><span class="line">    while(i&lt;n)&#123;  &#x2F;&#x2F;从上到下开始匹配</span><br><span class="line">        if(!length[i])&#123;  &#x2F;&#x2F;当该进程的信号已经全部发送完毕时跳过</span><br><span class="line">            i++;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp&#x3D;l[i].front(); &#x2F;&#x2F;取指令</span><br><span class="line">        opr&#x3D;tmp%10;  &#x2F;&#x2F;这里解释一下，我对指令信息做了处理</span><br><span class="line">        tmp&#x2F;&#x3D;10;   &#x2F;&#x2F;我将目标号乘10，最低的各位只存0或1，0表示发信息，1表示收信息，这样做的好处就是可以直接将指令转换为数字存储，并且在下面匹配的时候比较方便。举例R1008,在邻接表中为10081.</span><br><span class="line">        if(!length[tmp])&#123;  &#x2F;&#x2F;查看目标进程，如果目标进程以及没有指令要发</span><br><span class="line">            return 1;   &#x2F;&#x2F;那么匹配失败，一定会出现死锁</span><br><span class="line">        &#125;</span><br><span class="line">        target&#x3D;l[tmp].front();</span><br><span class="line">        if(target&#x3D;&#x3D;i*10+(!opr))&#123; &#x2F;&#x2F;匹配</span><br><span class="line">            l[i].pop_front();</span><br><span class="line">            length[i]--;</span><br><span class="line">            l[tmp].pop_front(); &#x2F;&#x2F;如果匹配成功，将两个匹配的信号从队列</span><br><span class="line">            length[tmp]--;&#x2F;&#x2F;中弹出，！！！！同时将当前的标记i跳到更小的</span><br><span class="line">            i&#x3D;min(i,tmp);&#x2F;&#x2F;地方继续从上到下匹配</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            i++;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">        if(length[i])</span><br><span class="line">            return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大体的思路在代码注释中以及解释了，大家也许还有疑惑的就是为什么每一次匹配成功之后，i都要向上跳转，这里就是相对于纯暴力法的优化，对于普通的暴力而言，每一次完成匹配之后都要从第一个进程开始继续寻找一对匹配收发指令，但事实上完全没有必要，下面给出具体解释：</p>
<p>假设目前匹配到第i个进程，假设它的首信号为Rj(不重要)，现在发现第j个进程的首信号为Si，那么他们能够进行匹配，假设i&lt;j，那么在它们匹配结束之后，如果还存在能够匹配的一对收发指令，那么这一对首发指令各自出现的进程号分别有以下几种情况:</p>
<p>1.一个出现在1<del>(i-1)号进程中，一个出现在i</del>n号进程中</p>
<p>2.两个都出现在i~n号进程中</p>
<p>即使j&lt;i，上面的情况也是类似的</p>
<p>那么我们可以知道，在i&lt;j的前提下，下一对能匹配的收发指令中至少有一条会出现在i之后的进程中，那么我们从i开始继续往下匹配，就一定不会错过这一对匹配的收发指令。这样就不用从第1号进程开始重新匹配，大大节约了时间。</p>
<p>下面贴出完整的AC代码:328ms,2.632MB</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#define MAX 10001</span><br><span class="line">using namespace std;</span><br><span class="line">int T,n;</span><br><span class="line">list&lt;int&gt; l[MAX];</span><br><span class="line">int length[MAX]&#x3D;&#123;0&#125;;</span><br><span class="line">int match()&#123;</span><br><span class="line">    int i&#x3D;0; int tmp&#x3D;0; int target&#x3D;0; bool opr;</span><br><span class="line">    while(i&lt;n)&#123;</span><br><span class="line">        if(!length[i])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp&#x3D;l[i].front();</span><br><span class="line">        opr&#x3D;tmp%10;</span><br><span class="line">        tmp&#x2F;&#x3D;10;</span><br><span class="line">        if(!length[tmp])&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        target&#x3D;l[tmp].front();</span><br><span class="line">        if(target&#x3D;&#x3D;i*10+(!opr))&#123;</span><br><span class="line">            l[i].pop_front();</span><br><span class="line">            length[i]--;</span><br><span class="line">            l[tmp].pop_front();</span><br><span class="line">            length[tmp]--;</span><br><span class="line">            i&#x3D;min(i,tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            i++;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">        if(length[i])</span><br><span class="line">            return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    cin&gt;&gt;T&gt;&gt;n;</span><br><span class="line">    getchar();</span><br><span class="line">    for(int i&#x3D;0;i&lt;T;i++)&#123;</span><br><span class="line">        for(int j&#x3D;0;j&lt;n;j++)&#123;</span><br><span class="line">            string keep;</span><br><span class="line">            getline(cin,keep);</span><br><span class="line">            stringstream  ss(keep);</span><br><span class="line">            string tmp;</span><br><span class="line">            while(ss&gt;&gt;tmp) &#123;</span><br><span class="line">                int a &#x3D; atoi(&amp;(tmp[1]));</span><br><span class="line">                a *&#x3D; 10;</span><br><span class="line">                if (tmp[0] &#x3D;&#x3D; &#39;R&#39;) &#x2F;&#x2F;if R 1，else S 0</span><br><span class="line">                    a++;</span><br><span class="line">                l[j].push_back(a);</span><br><span class="line">                length[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;,match());</span><br><span class="line">        for(int j&#x3D;0;j&lt;n;j++)&#123;</span><br><span class="line">            l[j].clear();</span><br><span class="line">            length[j]&#x3D;0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/07/csp-url%E6%98%A0%E5%B0%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="wwow">
      <meta itemprop="description" content="努力可能会成功，但不努力真的很舒服">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wwow's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/07/csp-url%E6%98%A0%E5%B0%84/" class="post-title-link" itemprop="url">CSP-2018-3-3 URL映射</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-07 14:10:24" itemprop="dateCreated datePublished" datetime="2019-10-07T14:10:24+08:00">2019-10-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-30 11:59:12" itemprop="dateModified" datetime="2020-08-30T11:59:12+08:00">2020-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>　　URL 映射是诸如 Django、Ruby on Rails 等网页框架 (web frameworks) 的一个重要组件。对于从浏览器发来的 HTTP 请求，URL 映射模块会解析请求中的 URL 地址，并将其分派给相应的处理代码。现在，请你来实现一个简单的 URL 映射功能。<br>　　本题中 URL 映射功能的配置由若干条 URL 映射规则组成。当一个请求到达时，URL 映射功能会将请求中的 URL 地址按照配置的先后顺序逐一与这些规则进行匹配。当遇到第一条完全匹配的规则时，匹配成功，得到匹配的规则以及匹配的参数。若不能匹配任何一条规则，则匹配失败。<br>　　本题输入的 URL 地址是以斜杠 / 作为分隔符的路径，保证以斜杠开头。其他合法字符还包括大小写英文字母、阿拉伯数字、减号 -、下划线 _ 和小数点 .。例如，/person/123/ 是一个合法的 URL 地址，而 /person/123? 则不合法（存在不合法的字符问号 ?）。另外，英文字母区分大小写，因此 /case/ 和 /CAse/ 是不同的 URL 地址。<br>　　对于 URL 映射规则，同样是以斜杠开始。除了可以是正常的 URL 地址外，还可以包含参数，有以下 3 种：<br>　　字符串 <str>：用于匹配一段字符串，注意字符串里不能包含斜杠。例如，abcde0123。<br>　　整数 <int>：用于匹配一个不带符号的整数，全部由阿拉伯数字组成。例如，01234。<br>　　路径 <path>：用于匹配一段字符串，字符串可以包含斜杠。例如，abcd/0123/。<br>　　以上 3 种参数都必须匹配非空的字符串。简便起见，题目规定规则中 <str> 和 <int> 前面一定是斜杠，后面要么是斜杠，要么是规则的结束（也就是该参数是规则的最后一部分）。而 <path> 的前面一定是斜杠，后面一定是规则的结束。无论是 URL 地址还是规则，都不会出现连续的斜杠。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>　　输入第一行是两个正整数 <em>n</em> 和 <em>m_，分别表示 URL 映射的规则条数和待处理的 URL 地址个数，中间用一个空格字符分隔。<br>　　第 2 行至第 _n</em>+1 行按匹配的先后顺序描述 URL 映射规则的配置信息。第 <em>i</em>+1 行包含两个字符串 <em>pi</em> 和 <em>ri_，其中 _pi</em> 表示 URL 匹配的规则，<em>ri</em> 表示这条 URL 匹配的名字。两个字符串都非空，且不包含空格字符，两者中间用一个空格字符分隔。<br>　　第 <em>n</em>+2 行至第 <em>n</em>+<em>m</em>+1 行描述待处理的 URL 地址。第 <em>n</em>+1+<em>i</em> 行包含一个字符串 _qi_，表示待处理的 URL 地址，字符串中不包含空格字符。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输入共 <em>m</em> 行，第 <em>i</em> 行表示 <em>qi</em> 的匹配结果。如果匹配成功，设匹配了规则 <em>pj</em> ，则输出对应的 _rj_。同时，如果规则中有参数，则在同一行内依次输出匹配后的参数。注意整数参数输出时要把前导零去掉。相邻两项之间用一个空格字符分隔。如果匹配失败，则输出 404。<strong>样</strong></p>
<h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>5 4<br>/articles/2003/ special_case_2003<br>/articles/<int>/ year_archive<br>/articles/<int>/<int>/ month_archive<br>/articles/<int>/<int>/<str>/ article_detail<br>/static/<path> static_serve<br>/articles/2004/<br>/articles/1985/09/aloha/<br>/articles/hello/<br>/static/js/jquery.js</p>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><p>year_archive 2004<br>article_detail 1985 9 aloha<br>404<br>static_serve js/jquery.js</p>
<h2 id="数据规模"><a href="#数据规模" class="headerlink" title="数据规模"></a>数据规模</h2><p>1 ≤ <em>n</em> ≤ 100，1 ≤ <em>m</em> ≤ 100。<br>　　所有输入行的长度不超过 100 个字符（不包含换行符）。<br>　　保证输入的规则都是合法的。</p>
<p>一道标准的暴力字符匹配题，但是由于CSP进行的是OI赛制，无法实时的了解自己的分数，这类的模拟题要拿到满分还是有一定的难度。</p>
<p>一开始我的做法是第一遍进行匹配，然后将每一条URL地址的参数放入数组oprend进行存储，等到这一条URL地址确定找到匹配的规则的时候，再将oprend数组中的参数全部输出，同时要对oprend数组进行清空供下一条URL地址存放参数。</p>
<p>但提交后只得到50分，提交了几次也找不到问题到底出在哪里（我被洛谷直接给样例的行为惯坏了……）</p>
<p>然后我去网上找了一找题解，突然发现了一种码量骤减并且相对我原先方法更加巧妙的解法。大致思路是:</p>
<p>1.使用匹配函数match(j,i,false)，表示将第j条规则与第i条地址进行匹配，而第三个bool参数表示，当该参数为false时，我们只进行匹配，与上一种方法不同的是匹配过程中，不需要存储参数，我们只需要知道地址和规则是否匹配就可以了。</p>
<p>2.在上一次match返回true表示匹配成功的时候，先输出匹配成功的规则代名词，然后再次调用match(j,i,true)，这一次我们已经知道第j条规则和第i条地址是能够成功匹配的，那么在匹配过程中遇到地址中的参数时，我们就将其输出。</p>
<p>改进后代码简洁了许多，我们不需要在匹配的时候多开一个参数数组来存储参数，也不需要在每一次匹配结束后清空参数数组，但是显而易见的是，每一次匹配成功的时候都要多进行一次match，大致的时间复杂度为O(nm+m)，这一次代码提交后得到了100分(但我觉得就正确性而言两种方法其实差不多…)。</p>
<h2 id="附上AC代码"><a href="#附上AC代码" class="headerlink" title="附上AC代码:"></a>附上AC代码:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#define MAX 110</span><br><span class="line">using namespace std;</span><br><span class="line">int n, m;</span><br><span class="line">char branch;</span><br><span class="line">string keep[MAX];</span><br><span class="line">string shName[MAX];</span><br><span class="line">string mate[MAX];</span><br><span class="line">bool match(int a, int b, bool flag) &#123;  </span><br><span class="line">	int i &#x3D; 0, j &#x3D; 0;</span><br><span class="line">	int length_a &#x3D; keep[a].size();</span><br><span class="line">	int length_b &#x3D; mate[b].size();</span><br><span class="line">	while (i &lt; length_a &amp;&amp; j &lt; length_b) &#123;</span><br><span class="line">		if (keep[a][i] &#x3D;&#x3D; &#39;&lt;&#39;) &#123;    &#x2F;&#x2F;当遇到参数时进入</span><br><span class="line">			i++;</span><br><span class="line">			branch &#x3D; keep[a][i];</span><br><span class="line">			while (keep[a][i] !&#x3D; &#39;&gt;&#39;) &#123;  &#x2F;&#x2F;直接跳出&lt;&gt;</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">			i++;</span><br><span class="line">			if(flag)</span><br><span class="line">				cout &lt;&lt; &quot; &quot;;</span><br><span class="line">			if (branch &#x3D;&#x3D; &#39;i&#39;) &#123;  &#x2F;&#x2F;参数为&lt;int&gt;</span><br><span class="line">				bool targ &#x3D; false;</span><br><span class="line">				while (mate[b][j] !&#x3D; &#39;&#x2F;&#39; &amp;&amp; j &lt; length_b) &#123;</span><br><span class="line">					if (mate[b][j]&lt;&#39;0&#39; || mate[b][j]&gt;&#39;9&#39;) &#123;</span><br><span class="line">						return false;</span><br><span class="line">					&#125;</span><br><span class="line">					if (mate[b][j] !&#x3D; &#39;0&#39;) &#123;  &#x2F;&#x2F;去除前置0</span><br><span class="line">						targ &#x3D; true;</span><br><span class="line">					&#125;</span><br><span class="line">					if (targ &amp;&amp; flag) &#123;    &#x2F;&#x2F;输出数字</span><br><span class="line">						printf(&quot;%c&quot;, mate[b][j]);</span><br><span class="line">					&#125;</span><br><span class="line">					j++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else if (branch &#x3D;&#x3D; &#39;s&#39;) &#123;   &#x2F;&#x2F;当参数为&lt;str&gt;时</span><br><span class="line">				while (mate[b][j] !&#x3D; &#39;&#x2F;&#39; &amp;&amp; j &lt; length_b) &#123;</span><br><span class="line">					if ((mate[b][j] &gt;&#x3D; &#39;A&#39; &amp;&amp; mate[b][j] &lt;&#x3D; &#39;Z&#39;) || (mate[b][j] &gt;&#x3D; &#39;a&#39; &amp;&amp; mate[b][j] &lt;&#x3D; &#39;z&#39;) || mate[b][j] &#x3D;&#x3D; &#39;-&#39; || mate[b][j] &#x3D;&#x3D; &#39;.&#39; || mate[b][j] &#x3D;&#x3D; &#39;_&#39; || (mate[b][j] &gt;&#x3D; &#39;0&#39; &amp;&amp; mate[b][j] &lt;&#x3D; &#39;9&#39;)) &#123;</span><br><span class="line">						if (flag) &#123;</span><br><span class="line">							printf(&quot;%c&quot;, mate[b][j]);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					else &#123;</span><br><span class="line">						return false;</span><br><span class="line">					&#125;</span><br><span class="line">					j++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else if (branch &#x3D;&#x3D; &#39;p&#39;) &#123;   &#x2F;&#x2F;当参数为&lt;path&gt;时</span><br><span class="line">				while (j &lt; length_b) &#123;</span><br><span class="line">					if (mate[b][j] &#x3D;&#x3D; &#39;&#x2F;&#39; || (mate[b][j] &gt;&#x3D; &#39;A&#39; &amp;&amp; mate[b][j] &lt;&#x3D; &#39;Z&#39;) || (mate[b][j] &gt;&#x3D; &#39;a&#39; &amp;&amp; mate[b][j] &lt;&#x3D; &#39;z&#39;) || mate[b][j] &#x3D;&#x3D; &#39;-&#39; || mate[b][j] &#x3D;&#x3D; &#39;.&#39; || mate[b][j] &#x3D;&#x3D; &#39;_&#39; || (mate[b][j] &gt;&#x3D; &#39;0&#39; &amp;&amp; mate[b][j] &lt;&#x3D; &#39;9&#39;)) &#123;</span><br><span class="line">						if (flag) &#123;</span><br><span class="line">							printf(&quot;%c&quot;, mate[b][j]);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					else &#123;</span><br><span class="line">						return false;</span><br><span class="line">					&#125;</span><br><span class="line">					j++;</span><br><span class="line">				&#125;</span><br><span class="line">				return true;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			if (keep[a][i] !&#x3D; mate[b][j]) &#123;</span><br><span class="line">				return false;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				i++;</span><br><span class="line">				j++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return (i &#x3D;&#x3D; length_a &amp;&amp; j &#x3D;&#x3D; length_b); &#x2F;&#x2F;地址和规则的匹配必须同时结束才算成功</span><br><span class="line">&#125;</span><br><span class="line">bool isValid(char a) &#123;</span><br><span class="line">	return (a &#x3D;&#x3D; &#39;&#x2F;&#39; || (a &gt;&#x3D; &#39;A&#39; &amp;&amp; a &lt;&#x3D; &#39;Z&#39;) || (a &gt;&#x3D; &#39;a&#39; &amp;&amp; a &lt;&#x3D; &#39;z&#39;) || a &#x3D;&#x3D; &#39;-&#39; || a &#x3D;&#x3D; &#39;.&#39; || a &#x3D;&#x3D; &#39;_&#39; || (a &gt;&#x3D; &#39;0&#39; &amp;&amp; a &lt;&#x3D; &#39;9&#39;));</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; keep[i];</span><br><span class="line">		cin &gt;&gt; shName[i];</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;</span><br><span class="line">		cin &gt;&gt; mate[i];</span><br><span class="line">		&#x2F;&#x2F; judge the vality</span><br><span class="line">		bool mark &#x3D; true;</span><br><span class="line">		int length &#x3D; mate[i].size();</span><br><span class="line">		for (int j &#x3D; 0; j &lt; length; j++) &#123;</span><br><span class="line">			if (!isValid(mate[i][j])) &#123;</span><br><span class="line">				mark &#x3D; false;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (!mark) &#123;</span><br><span class="line">			cout &lt;&lt; &quot;404\n&quot;;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		bool a &#x3D; false;</span><br><span class="line">		for (int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;</span><br><span class="line">			if (match(j, i, false)) &#123;   &#x2F;&#x2F;确定匹配是否成功</span><br><span class="line">				a &#x3D; true;</span><br><span class="line">				cout &lt;&lt; shName[j];</span><br><span class="line">				match(j, i, true);  &#x2F;&#x2F;输出参数</span><br><span class="line">				printf(&quot;\n&quot;);</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (!a) &#123;                  当匹配全部失败的时候输出404</span><br><span class="line">			cout &lt;&lt; &quot;404\n&quot;; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/05/p5520-yloi2019-%E9%9D%92%E5%8E%9F%E6%A8%B1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="wwow">
      <meta itemprop="description" content="努力可能会成功，但不努力真的很舒服">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wwow's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/05/p5520-yloi2019-%E9%9D%92%E5%8E%9F%E6%A8%B1/" class="post-title-link" itemprop="url">P5520 [yLOI2019] 青原樱</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-05 23:06:24" itemprop="dateCreated datePublished" datetime="2019-10-05T23:06:24+08:00">2019-10-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-30 12:01:08" itemprop="dateModified" datetime="2020-08-30T12:01:08+08:00">2020-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://www.luogu.org/problem/P5520?contestId=20125">https://www.luogu.org/problem/P5520?contestId=20125</a></p>
<p><strong>方法一:动态规划</strong></p>
<p>这题一开始的想法是用dp来求出可种植的所有方案，然后排列组合m支幼苗</p>
<p>设dp[i][j]表示已经放了i个幼苗其中第i个幼苗放在第j个位置的方案数，状态转移方程为:</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2019/10/image.png"></p>
<p>但是在编写过程中要讲dp[1][j]以及dp[0][0]先处理好，否则上述公式会出现错误。</p>
<p>可以看出dp过程中共有n*m个状态，每个状态转移的复杂度都是O(n)，总复杂度为O(n²m)，这个复杂度在后面两个大数据的测试点中会TLE，并且dp的二维数组过大也会OLE，所以使用dp方案只能获得混一点分。</p>
<p><strong>方法二:组合数学</strong></p>
<p>在dp失败后我们可以考虑使用组合数学的方法。</p>
<p>在这里我们首先要分类讨论： 一.最后一个位子不放幼苗的情况。 二.最后一个位子放幼苗的情况</p>
<p>首先讨论最后一个位子不放幼苗的情况，由于任意两个幼苗之间不能相邻，我们可以假设每一个幼苗后有一个空格作为它的”挂件”，这样我们就可以不用考虑幼苗的相邻问题直接进行排列。即在(n-m)个格子中放入m个幼苗，则方案数共有:</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2019/10/image-2.png"></p>
<p>然后讨论最后一个位子放置幼苗的情况，除了最后一个位置固定放置幼苗外，其他条件与前一种情况相似，则可供放置的格子有(n-1)-(m-1)=n-m，需要放置的幼苗有(m-1)个，但最终的排列还是m种，则方案数有:</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2019/10/image-3.png"></p>
<p>由代数恒等式:</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2019/10/image-4.png"></p>
<p>得到最终方案数:</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2019/10/image-5.png"></p>
<p>该方案的时间复杂度仅为O(n)。</p>
<p><strong>AC代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int type, n, m, p;</span><br><span class="line">	cin &gt;&gt; type &gt;&gt; n &gt;&gt; m &gt;&gt; p;</span><br><span class="line">	long long ans &#x3D; 1;</span><br><span class="line">	for (int i &#x3D; n-2*m+2; i &lt;&#x3D; n-m+1; i++) &#123;</span><br><span class="line">		ans &#x3D;  (ans * i) % p;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%lld\n&quot;, ans);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/04/%E7%BB%BC%E8%AE%BE%E2%85%A0-linux%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E9%99%90%E9%87%8F%E7%9B%91%E6%8E%A7%E7%A8%8B%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="wwow">
      <meta itemprop="description" content="努力可能会成功，但不努力真的很舒服">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wwow's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/04/%E7%BB%BC%E8%AE%BE%E2%85%A0-linux%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E9%99%90%E9%87%8F%E7%9B%91%E6%8E%A7%E7%A8%8B%E5%BA%8F/" class="post-title-link" itemprop="url">综设Ⅰ-Linux系统下的文件系统限量监控程序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-04 21:50:33" itemprop="dateCreated datePublished" datetime="2019-10-04T21:50:33+08:00">2019-10-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-30 12:03:15" itemprop="dateModified" datetime="2020-08-30T12:03:15+08:00">2020-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%B6%E5%AE%83/" itemprop="url" rel="index"><span itemprop="name">其它</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>前置学习资料与要求</strong></p>
<p>使用VMware安装一个虚拟机(建议安装Ubuntu，直接到官网下载最新的版本)</p>
<p><a target="_blank" rel="noopener" href="https://www.linuxprobe.com/chapter-02.html">https://www.linuxprobe.com/chapter-02.html</a> (简单学习linux系统的基本命令，大概了解他们的作用，再需要使用的时候再翻看文档）</p>
<p><a target="_blank" rel="noopener" href="https://www.linuxprobe.com/chapter-04.html">https://www.linuxprobe.com/chapter-04.html   (学会使用vim编辑器，尽量也学习一下Shell脚本的编写方法）</a></p>
<p><a target="_blank" rel="noopener" href="https://www.linuxprobe.com/chapter-05.html">https://www.linuxprobe.com/chapter-05.html   (主要看</a>5.2文件权限和归属)  </p>
<p><strong>实验内容与要求</strong></p>
<p>在UNIX操作系统下用C语言或shell语言编写一个对用户使用文件系统（磁盘）空间的限量监控程序。通过菜单设置可选择指定用户在指定的文件系统下的存储空间和文件数量的使用限量。当程序监控到指定用户的使用量超限时，就向该用户提示警告信息，当用户的使用量降低时，停止警告提示并恢复正常。</p>
<p><strong>实现方法</strong></p>
<p>在网上找到类似的linux磁盘监视和警告脚本大多都是用shell语言来实现的，我想如果找不到用C来解决的方法的话，可能大家需要花一些时间去看一看shell脚本的语法(不用担心，大多与C相似，中间穿插一些linux系统的命令)</p>
<p>1. <a target="_blank" rel="noopener" href="https://yq.aliyun.com/articles/39223">https://yq.aliyun.com/articles/39223</a>（linux监控磁盘空间和使用情况,需要了解一下df命令，下面给出学习链接)</p>
<p>2.我想到一个方法，可以通过使用inode(文件索引节点，下方给出介绍链接)来完成任务。 首先编写脚本，当该磁盘下有新的文件创建时，查看该文件的inode节点，inode节点会记录它对应文件的大小和所有者，当我们发现该文件为limited user的文件时，就将该文件的大小记录下来，并专门开一个变量num和memory分别记录limited user在该磁盘下使用的存储空间和文件数量。当计算到超标的时候就打印警告，当使用量降低的时候就停止警告。</p>
<p>这个方法也许还是要使用shell脚本来实现，因为我现在不太明白C语言怎么去导入和处理操作系统的信息(也许有同学知道的可以反馈给大家)</p>
<p><strong>其他资料</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-filesystem.html">https://www.runoob.com/linux/linux-filesystem.html  (linux中磁盘操作命令，df,du,fdisk）</a></p>
<p> <a target="_blank" rel="noopener" href="https://blog.csdn.net/xuz0917/article/details/79473562">https://blog.csdn.net/xuz0917/article/details/79473562  (innode文件索引节点的介绍)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="wwow"
      src="/uploads/avatar.png">
  <p class="site-author-name" itemprop="name">wwow</p>
  <div class="site-description" itemprop="description">努力可能会成功，但不努力真的很舒服</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wwow</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
