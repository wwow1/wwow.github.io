<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="努力不一定会成功，但不努力真的很舒服">
<meta property="og:type" content="website">
<meta property="og:title" content="wwow&#39;s blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="wwow&#39;s blog">
<meta property="og:description" content="努力不一定会成功，但不努力真的很舒服">
<meta property="og:locale">
<meta property="article:author" content="wwow">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>wwow's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">wwow's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/30/csapp-shellLab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="wwow">
      <meta itemprop="description" content="努力不一定会成功，但不努力真的很舒服">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wwow's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/30/csapp-shellLab/" class="post-title-link" itemprop="url">csapp-shellLab</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-30 00:03:34 / 修改时间：11:58:37" itemprop="dateCreated datePublished" datetime="2020-08-30T00:03:34+08:00">2020-08-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/csapp/" itemprop="url" rel="index"><span itemprop="name">csapp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="CSAPP-shell-lab"><a href="#CSAPP-shell-lab" class="headerlink" title="CSAPP-shell lab"></a>CSAPP-shell lab</h3><p>本次实验的内容是完成一个简易的shell程序。</p>
<p>在开始实验之前请大家仔细阅读官网的write up，理解程序的要求以及作者给出的hint。</p>
<p>write up：<a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/3e/shlab.pdf">http://csapp.cs.cmu.edu/3e/shlab.pdf</a></p>
<p>这一次实验的内容和书上第八章的内容联系非常紧密，程序的一部分实现和corner case的书中也有介绍，请在认真阅读第八章（特别是进程控制和信号这两部分）</p>
<p>这一次的shell lab，write up只给出了对程序的大概要求，而具体的一些要求则需要通过我们观察trace文件得到。所以可以从trace01开始，边读trace边改进自己的程序。</p>
<p>官网的压缩包中还包含了tshref可执行文件，类似于cache lab中的csim-ref文件一样，对于每一个trace，tshref提供正确的运行结果。我们的目标就是使得自己编写的tsh文件能够得到和tshref相同的结果。</p>
<p>我们只需要填补tsh.c中空缺的7个函数：</p>
<ol>
<li><p>eval ：主循环，解析输入的命令行</p>
</li>
<li><p>builtin_cmd：辨别并执行内置命令（quit，fg，bg，jobs）</p>
</li>
<li><p>do_bgfg：执行bg和fg内置命令</p>
</li>
<li><p>waitfg：显式等待前台进程执行结束</p>
</li>
<li><p>sigchld_handler：捕获SIGCHLD信号</p>
</li>
<li><p>sigint_handler：捕获SIGINT信号</p>
</li>
<li><p>sigtstp_hander：捕获SIGTSTP信号</p>
</li>
</ol>
<h3 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h3><p>首先填写eval函数，它是我们程序的一个核心，但是关于eval的实现，可以参考书上8.4节给出的样例，但是注意，书上的程序没有考虑关于信号的问题，但是我们不能忽略信号。</p>
<p>根据8.5信号中提到的父子进程竞争，可能导致在父进程addjob之前，子进程就结束，触发对deletejob的调用。为了解决竞争，需要在fork子进程之前，阻塞SIGCHLD信号，直到父进程addjob之后再解除SIGCHLD信号的阻塞。</p>
<p>另一方面，在write up中提到，为了确保SIGINT和SIGTSTP只作用于前台进程，需要在fork之后，修改子进程的进程组号，调用setpgid(0,0)，使得子进程的进程组号等于其进程号，这样就能保证只会有一个进程处于前台进程组。</p>
<p>(默认情况下，子进程会继承父进程的进程组号，所以我们才需要手动修改子进程的进程组号)</p>
<p>下面给出我的eval代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eval</span><span class="params">(<span class="keyword">char</span> *cmdline)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* argv[MAXARGS];</span><br><span class="line">    <span class="keyword">int</span> bg_fg;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">sigset_t</span> mask_all,mask_one,prev_one;</span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line">    sigemptyset(&amp;mask_one);</span><br><span class="line">    sigaddset(&amp;mask_one,SIGCHLD);</span><br><span class="line"></span><br><span class="line">    bg_fg=parseline(cmdline,argv); <span class="comment">//分割读入的命令行</span></span><br><span class="line">    <span class="keyword">if</span>(argv[<span class="number">0</span>]==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(!builtin_cmd(argv))&#123; <span class="comment">//识别并处理内置命令</span></span><br><span class="line">        sigprocmask(SIG_BLOCK,&amp;mask_one,&amp;prev_one);  <span class="comment">//阻塞SIG_CHLD，防止竞争</span></span><br><span class="line">        <span class="keyword">if</span>((pid=fork())==<span class="number">0</span>)&#123;</span><br><span class="line">            setpgid(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">            sigprocmask(SIG_SETMASK,&amp;prev_one,<span class="literal">NULL</span>); <span class="comment">//子进程继承父进程的阻塞集合，需要解除阻塞</span></span><br><span class="line">            <span class="keyword">if</span>(execve(argv[<span class="number">0</span>],argv,environ)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//execve会将子进程的信号处理函数置为默认</span></span><br><span class="line">                <span class="comment">//无需手动将SIGINT和SIGTSTP的处理程序改为默认行为</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found.\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sigprocmask(SIG_BLOCK,&amp;mask_all,<span class="literal">NULL</span>);</span><br><span class="line">        addjob(jobs,pid,bg_fg+<span class="number">1</span>,cmdline);   <span class="comment">//添加作业</span></span><br><span class="line">        sigprocmask(SIG_SETMASK,&amp;prev_one,<span class="literal">NULL</span>); <span class="comment">//解除阻塞</span></span><br><span class="line">        <span class="keyword">if</span>(bg_fg==<span class="number">0</span>)&#123;</span><br><span class="line">            waitfg(pid);  <span class="comment">//等待前台进程结束</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;   </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>,pid2jid(pid),pid,cmdline);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="builtin-command"><a href="#builtin-command" class="headerlink" title="builtin_command"></a>builtin_command</h3><p>这个函数需要判断输入的命令行中是否包含内置命令，如果包含内置命令则应该在主进程中马上执行，如果不包含内置命令则返回。</p>
<p>具体实现较为简单，不做过多说明。</p>
<p>下面给出我的builtin_cmd代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">builtin_cmd</span><span class="params">(<span class="keyword">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;quit&quot;</span>))</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;jobs&quot;</span>))&#123;</span><br><span class="line">        listjobs(jobs);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;bg&quot;</span>) || !<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;fg&quot;</span>))&#123;</span><br><span class="line">        do_bgfg(argv);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;     <span class="comment">/* not a builtin command */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="waitfg"><a href="#waitfg" class="headerlink" title="waitfg"></a>waitfg</h3><p>之后是waitfg函数，主进程通过调用waitfg函数来显式的等待某个子进程（前台进程）执行结束。</p>
<p>这里的实现书上有过相关的讨论，最终决定使用sigsuspend来实现。</p>
<p>下面给出我的waifg代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">sig_atomic_t</span> waitPidMark=<span class="number">0</span>; <span class="comment">//全局变量，用于检测子进程是否结束</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitfg</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">sigset_t</span> wait;</span><br><span class="line">    sigemptyset(&amp;wait);</span><br><span class="line">    waitPidMark=pid;</span><br><span class="line">    <span class="keyword">while</span>(waitPidMark)</span><br><span class="line">        sigsuspend(&amp;wait);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="do-bgfg"><a href="#do-bgfg" class="headerlink" title="do_bgfg"></a>do_bgfg</h3><p>对于内置命令bg和fg，单独使用一个do_bgfg来实现它们。简单来说不管是bg还是fg命令，主要的操作就是向对应的进程组发送SIGCONT命令，然后改变作业的状态。但是根据trace14的信息，我们还需要对命令行中bg，fg的参数做一定的约束，对于不满足约束的参数输出提示信息。</p>
<p>下面给出我的do_bgfg代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkDigit</span><span class="params">(<span class="keyword">char</span>* s)</span></span>&#123;</span><br><span class="line">    <span class="comment">//检测输入的参数是否满足，全为数字，或是%数字的形式</span></span><br><span class="line">	<span class="comment">//如果参数满足则返回1，如果参数不正确则返回0	</span></span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;%&#x27;</span> || (s[<span class="number">0</span>]&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; s[<span class="number">0</span>]&lt;=<span class="string">&#x27;9&#x27;</span>));</span><br><span class="line">    <span class="keyword">else</span>    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]&lt;<span class="string">&#x27;0&#x27;</span> || s[i]&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function">struct <span class="keyword">job_t</span>* <span class="title">str2job</span><span class="params">(<span class="keyword">char</span>* s)</span></span>&#123; </span><br><span class="line">    <span class="comment">//将fg，bg的参数转换为对应的jid或pid</span></span><br><span class="line">    <span class="keyword">int</span> jid;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">jPtr</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;%&#x27;</span>)&#123;</span><br><span class="line">        jid=atoi(&amp;s[<span class="number">1</span>]);</span><br><span class="line">        jPtr=getjobjid(jobs,jid);</span><br><span class="line">        <span class="keyword">if</span>(jPtr==<span class="literal">NULL</span>)&#123;  <span class="comment">//jid不存在</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: No such job\n&quot;</span>,s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        pid=atoi(s);</span><br><span class="line">        jPtr=getjobpid(jobs,pid);</span><br><span class="line">        <span class="keyword">if</span>(jPtr==<span class="literal">NULL</span>)&#123;  <span class="comment">//pid不存在</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%s): No such process\n&quot;</span>,s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jPtr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_bgfg</span><span class="params">(<span class="keyword">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argv[<span class="number">1</span>]==<span class="literal">NULL</span>)&#123;  <span class="comment">//没有输入jid</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s command requires PID or %%jobid argument\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!checkDigit(argv[<span class="number">1</span>]))&#123;  <span class="comment">//输入的jid中含有非数字元素</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span>* <span class="title">jPtr</span>=<span class="title">str2job</span>(<span class="title">argv</span>[1]);</span></span><br><span class="line">    <span class="keyword">if</span>(jPtr==<span class="literal">NULL</span>)  <span class="keyword">return</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;bg&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(kill(-jPtr-&gt;pid,SIGCONT)&lt;<span class="number">0</span>)  <span class="comment">//发送给整个进程组，而不是单个进程</span></span><br><span class="line">            unix_error(<span class="string">&quot;kill bg error:&quot;</span>);</span><br><span class="line">        jPtr-&gt;state=BG;         <span class="comment">//修改作业状态</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>,jPtr-&gt;jid,jPtr-&gt;pid,jPtr-&gt;cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(kill(-jPtr-&gt;pid,SIGCONT)&lt;<span class="number">0</span>) <span class="comment">//发送给整个进程组，而不是单个进程</span></span><br><span class="line">            unix_error(<span class="string">&quot;kill fg error:&quot;</span>);</span><br><span class="line">        jPtr-&gt;state=FG;      <span class="comment">//修改作业状态</span></span><br><span class="line">        waitfg(jPtr-&gt;pid);   <span class="comment">//等待这个前台进程终止</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="sigchld-handler"><a href="#sigchld-handler" class="headerlink" title="sigchld_handler"></a>sigchld_handler</h3><p>对SIGCHLD的信号处理也是本次实验的主要内容，同样可以参照书本的样例代码，并在此之上做进一步的改进。</p>
<p>首先是waitpid，一定要加上WNOHANG和WUNTRACED这两个参数，WNOHANG可以告诉主进程无需挂起等待子进程结束，而WUNTRACED则会在子进程进入暂停状态时，返回信息。</p>
<p>上面的waitfg中使用了一个标志前台进程的全局变量waitPidMark来实现对前台进程的显式等待。在SIGCHLD的处理程序中，每当一个子进程结束时，需要检验这个进程是不是前台进程，如果是的话需要修改waitPidMark，这样waitfg才能知道前台进程已经结束，它应该返回了。</p>
<p>另一方面，对于waitpid的返回值，也需要判断这个进程是结束了还是暂停了，并且针对进程状态输出对应的提示信息。</p>
<p>下面是我的sigchld_handler代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> olderrno=errno;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">int</span> jid;</span><br><span class="line">    <span class="keyword">sigset_t</span> mask_all,prev_all;</span><br><span class="line">    <span class="keyword">pid_t</span> tmpCheck;</span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line">    <span class="comment">//WNOHANG | WUNTRACED必须加上，否则就会将进程挂起等待子进程终止</span></span><br><span class="line">    <span class="comment">//在trace05中会使得后续进程等待很长时间</span></span><br><span class="line">    <span class="keyword">while</span>((tmpCheck=waitpid(<span class="number">-1</span>,&amp;status,WNOHANG | WUNTRACED))&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        sigprocmask(SIG_BLOCK,&amp;mask_all,&amp;prev_all);</span><br><span class="line">        <span class="keyword">if</span>(tmpCheck==fgpid(jobs))    waitPidMark=<span class="number">0</span>;  <span class="comment">//确定终止进程是否是前台进程</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(WIFSTOPPED(status))&#123; <span class="comment">//返回的子进程停止，则在作业集中修改它的状态</span></span><br><span class="line">            jid=pid2jid(tmpCheck);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) stopped by signal %d\n&quot;</span>,jid,tmpCheck,WSTOPSIG(status));</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span>* <span class="title">jPtr</span>=<span class="title">getjobpid</span>(<span class="title">jobs</span>,<span class="title">tmpCheck</span>);</span></span><br><span class="line">            jPtr-&gt;state=ST;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  <span class="comment">//如果返回子进程终止，则从作业集中删除它</span></span><br><span class="line">        <span class="comment">//注意不能只在WIFSIGNALED的条件语句中调用deletejob</span></span><br><span class="line">        <span class="comment">//只要子进程结束了，都应该调用deletejob</span></span><br><span class="line">            <span class="keyword">if</span>(WIFSIGNALED(status))&#123;</span><br><span class="line">                jid=pid2jid(tmpCheck);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) terminated by signal %d\n&quot;</span>,jid,tmpCheck,WTERMSIG(status));</span><br><span class="line">                <span class="comment">//打印出进程终止原因</span></span><br><span class="line">                deletejob(jobs,tmpCheck); <span class="comment">//删除作业</span></span><br><span class="line">            &#125;</span><br><span class="line">            deletejob(jobs,tmpCheck); <span class="comment">//删除作业</span></span><br><span class="line">        &#125;</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        sigprocmask(SIG_SETMASK,&amp;prev_all,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    errno=olderrno;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="sigint-handler和sigtstp-handler"><a href="#sigint-handler和sigtstp-handler" class="headerlink" title="sigint_handler和sigtstp_handler"></a>sigint_handler和sigtstp_handler</h3><p>最后是对SIGINT和SIGTSTP的信号处理函数，这两个信号处理函数的内容很简单也非常相似，所以就放在一起说明了。</p>
<p>这一部分唯一需要注意的是使用kill发送信号时，参数需要使用-pid，而不是pid。因为SIGINT和SIGTSTP需要被发送给整个前台进程组，都不是单个进程。测试程序会检测这方面的内容。</p>
<p>下面是我的sigint_handler和sigtstp_handler代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigint_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> olderrno=errno;</span><br><span class="line">    <span class="keyword">sigset_t</span> mask_all,prev_all;</span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;mask_all,&amp;prev_all);</span><br><span class="line">    <span class="keyword">pid_t</span> fgp=fgpid(jobs);</span><br><span class="line">    <span class="keyword">if</span>(kill(-fgp,SIGINT)&lt;<span class="number">0</span>)&#123;  <span class="comment">//发送给前台进程组</span></span><br><span class="line">        unix_error(<span class="string">&quot;kill sigint error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sigprocmask(SIG_SETMASK,&amp;prev_all,<span class="literal">NULL</span>);</span><br><span class="line">    errno=olderrno;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigtstp_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> olderrno=errno;</span><br><span class="line">    <span class="keyword">sigset_t</span> mask_all,prev_all;</span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;mask_all,&amp;prev_all);</span><br><span class="line">    <span class="keyword">pid_t</span> fgp=fgpid(jobs);</span><br><span class="line">    <span class="keyword">if</span>(kill(-fgp,SIGTSTP)&lt;<span class="number">0</span>)&#123; <span class="comment">//发送给前台进程组</span></span><br><span class="line">        unix_error(<span class="string">&quot;kill sigtstp error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sigprocmask(SIG_SETMASK,&amp;prev_all,<span class="literal">NULL</span>);</span><br><span class="line">    errno=olderrno;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此，shell lab就做完了。本次实验与书本上的内容结合的更加紧密，对于一些机制的实现，书本上都有非常详细的讨论和解释。通过这次实验，让我更加深刻理解了信号的作用，以及一个shell程序的大致执行流程。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/30/csapp-cacheLab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="wwow">
      <meta itemprop="description" content="努力不一定会成功，但不努力真的很舒服">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wwow's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/30/csapp-cacheLab/" class="post-title-link" itemprop="url">csapp-cacheLab</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-30 00:02:59 / 修改时间：11:58:21" itemprop="dateCreated datePublished" datetime="2020-08-30T00:02:59+08:00">2020-08-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/csapp/" itemprop="url" rel="index"><span itemprop="name">csapp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="csapp-cacheLab"><a href="#csapp-cacheLab" class="headerlink" title="csapp-cacheLab"></a>csapp-cacheLab</h2><p>在开始实验时请认真阅读实验的指导书，其中关于实验的注意点和要求都写的非常明确，这些内容在本篇文章中不会提及。</p>
<p><a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/3e/cachelab.pdf">http://csapp.cs.cmu.edu/3e/cachelab.pdf</a></p>
<h4 id="PartA"><a href="#PartA" class="headerlink" title="PartA"></a>PartA</h4><p>第一部分要求我们编写一个cache的模拟器，通过在运行程序时提供参数确定cache的参数(E–&gt;行数，s–&gt;索引位长，b–&gt;存储块的位长)，然后顺序读取测试文件中提供的64位内存地址序列，最后输出在这一过程中的hit,miss,evicts</p>
<p>压缩包中提供了一个二进制文件csim-ref，这个文件就是我们的参照，我们程序的运行结果需要和它完全相同。</p>
<p>首先是存储cache参数的数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">cacheInfo_</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> S;  <span class="comment">//组数</span></span><br><span class="line">    <span class="keyword">int</span> E;  <span class="comment">//行数</span></span><br><span class="line">    <span class="keyword">int</span> B;  <span class="comment">//块大小（字节）</span></span><br><span class="line">    <span class="keyword">int</span> m;  <span class="comment">//物理地址位数，64</span></span><br><span class="line">    <span class="keyword">int</span> s_bit;  <span class="comment">//组索引位数</span></span><br><span class="line">    <span class="keyword">int</span> b_bit;  <span class="comment">//块偏移位数</span></span><br><span class="line">    <span class="keyword">int</span> t_bit;  <span class="comment">//标记位数</span></span><br><span class="line">&#125;cacheInfo;</span><br></pre></td></tr></table></figure>

<p>然后我们需要处理程序的命令行参数，使用getopt函数（writeup里有提示）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>((ch=getopt(argc,argv,<span class="string">&quot;hvs:E:b:t:&quot;</span>))!=<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">            print_help_info();  <span class="comment">//打印对该程序的使用指南</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:</span><br><span class="line">            verbose_flag=<span class="number">1</span>;   <span class="comment">//修改标志位</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">            cacheInfo.s_bit=atoi(optarg);</span><br><span class="line">            cacheInfo.S=<span class="number">1</span>&lt;&lt;cacheInfo.s_bit;  </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">            cacheInfo.E=atoi(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">            cacheInfo.b_bit=atoi(optarg);</span><br><span class="line">            cacheInfo.B=<span class="number">1</span>&lt;&lt;cacheInfo.b_bit;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">            fp=fopen(optarg,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Unknown option: %c\n&quot;</span>,(<span class="keyword">char</span>)optopt);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后需要定义cache的存储内容，为了逻辑清晰可以再定义一个结构来整合这些信息，但是这只是一个小程序，我就直接使用三个二维数组将cache的信息分开存放了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   cache=(<span class="keyword">long</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">long</span>*)*cacheInfo.S);  </span><br><span class="line"><span class="comment">//分配地址空间模拟cache, [索引组][行数]---&gt;标志位</span></span><br><span class="line">   mark=(<span class="keyword">bool</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">bool</span>*)*cacheInfo.S);   </span><br><span class="line"><span class="comment">//对应每一组内每一行的有效位,[索引组][行数]---&gt;有效位</span></span><br><span class="line">   time_tag=(<span class="keyword">int</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*)*cacheInfo.S); </span><br><span class="line"><span class="comment">//时间标记,[索引组][行数]---&gt;时间戳(用于LRU算法的替换依据)</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cacheInfo.S;i++)&#123;                <span class="comment">//初始化</span></span><br><span class="line">       cache[i]=(<span class="keyword">long</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)*cacheInfo.E);</span><br><span class="line">       mark[i]=(<span class="keyword">bool</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">bool</span>)*cacheInfo.E);</span><br><span class="line">       time_tag[i]=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*cacheInfo.E);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cacheInfo.S;i++)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cacheInfo.E;j++)</span><br><span class="line">           mark[i][j]=<span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>然后就是处理实际的地址访问请求的函数，这里我写一些伪代码说明流程，具体实现还是大家自己思考。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(读入一个memory traces)&#123;</span><br><span class="line">	判断它的类型，如果是I(I类指令最前面没有空格，其他指令前面有空格)则不用处理，<span class="keyword">continue</span>;</span><br><span class="line">    </span><br><span class="line">    取出memory traces的内存地址，将其转换为<span class="keyword">long</span></span><br><span class="line">        </span><br><span class="line">    将内存地址划分为组索引saddr和有效位taddr，块内偏移量可以忽略(writeup中有提示)</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">for</span>(遍历cache数组和mark数组)&#123;</span><br><span class="line">    	<span class="keyword">if</span>(mark[saddr][row]=<span class="literal">true</span>,且cache[saddr][row]=taddr) <span class="comment">//cache中保存有对应的内存单元</span></span><br><span class="line">    	then </span><br><span class="line">        	hit++;</span><br><span class="line">        	更新time[saddr][row]的时间戳;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(cache中没有找到对应内存单元)&#123;</span><br><span class="line">    	miss++;</span><br><span class="line">        LRU_replacement();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(memory trace type==M)&#123;</span><br><span class="line">    	hit++;  <span class="comment">//M必定发生2次hit或1次hit+1次miss,将缺的一次hit补上</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后需要完善cache的替换策略，本次实验中只需要实现较为简单的LRU策略，LRU策略会将一个最长时间未被使用的内存块换出cache，为了支持这一点，我们使用一个time_targ二维数组来记录每一个索引组中每一行的时间戳，使用全局的整型变量time，每一次对内存的访问都会使得time变量递增并且更新到time_targ[saddr] [row]。在需要替换内存块时，就遍历对应索引组的所有行，找到time[saddr] [row]最小的那一个替换出cache。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRU_replacement</span><span class="params">(<span class="keyword">long</span> saddr,<span class="keyword">long</span> taddr,<span class="keyword">char</span>* cacheState)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cacheInfo.E;i++)&#123;  <span class="comment">//首先检查有没有空闲的块可以存放读入的内存单元</span></span><br><span class="line">        <span class="keyword">if</span>(!mark[saddr][i])&#123;</span><br><span class="line">            cache[saddr][i]=taddr;</span><br><span class="line">            mark[saddr][i]=<span class="literal">true</span>;</span><br><span class="line">            time_tag[saddr][i]=time++;  <span class="comment">//时间标记，在驱逐的时候会用到它</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> minTime=<span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="keyword">int</span> minIndex=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cacheInfo.E;i++)&#123;   <span class="comment">//cache已满，需要驱逐</span></span><br><span class="line">        <span class="keyword">int</span> stamp=time_tag[saddr][i];</span><br><span class="line">        <span class="keyword">if</span>(stamp&lt;minTime)&#123;  <span class="comment">//寻找时间戳最小的那一行换出</span></span><br><span class="line">            minTime=stamp;</span><br><span class="line">            minIndex=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;evicts taddr=%ld saddr=%ld\n&quot;</span>,cache[saddr][minIndex],saddr);</span><br><span class="line">    cache[saddr][minIndex]=taddr;  </span><br><span class="line">    time_tag[saddr][minIndex]=time++;</span><br><span class="line">    evicts++;</span><br><span class="line">    <span class="built_in">strcat</span>(cacheState,<span class="string">&quot; evicts&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，partA的cache模拟器就完成了。</p>
<h3 id="Part-B"><a href="#Part-B" class="headerlink" title="Part B"></a>Part B</h3><p>这一部分只要是编写矩阵转置函数，并且要求在转置过程中发生尽可能少的miss</p>
<p>用于测试的矩阵有三种规格32x32,64x64,61x67，我们可以针对不同规模的矩阵使用专门的转置模式（不这么做也过不了测试）。</p>
<p>下面是对性能评估和分数的情况。</p>
<p>• 32 × 32: 8 points if m &lt; 300, 0 points if m &gt; 600<br>• 64 × 64: 8 points if m &lt; 1, 300, 0 points if m &gt; 2, 000<br>• 61 × 67: 10 points if m &lt; 2, 000, 0 points if m &gt; 3, 000</p>
<h4 id="32x32"><a href="#32x32" class="headerlink" title="32x32"></a>32x32</h4><p>首先可以看到普通的按行转置的方法在的数据为: hits:870  misses: 1183  evictions: 1151（32x32）</p>
<p>给定的cache参数为s=5,E=1,b=5，即有32个组，每个组一行，每一行存储32个字节的块</p>
<p>要减少miss的情况，主要要解决冲突不命中的情况。</p>
<p>首先，根据每一个行存储32字节的块，可以推出每一个块一次可以读入8个int，那么我们就可以直接使用8个临时变量将块内的8个int值存在寄存器中，防止后续出现冲突导致它们被换出。根据这个想法，我们改进一下示例代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">int</span> tmp1,tmp2,tmp3,tmp4;</span><br><span class="line"><span class="keyword">int</span> tmp5,tmp6,tmp7,tmp8; </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;M;j+=<span class="number">8</span>)&#123;</span><br><span class="line">        tmp1=A[i][j];  tmp2=A[i][j+<span class="number">1</span>];  tmp3=A[i][j+<span class="number">2</span>];  tmp4=A[i][j+<span class="number">3</span>];</span><br><span class="line">        tmp5=A[i][j+<span class="number">4</span>];  tmp6=A[i][j+<span class="number">5</span>];  tmp7=A[i][j+<span class="number">6</span>];  tmp8=A[i][j+<span class="number">7</span>];</span><br><span class="line">        B[j][i]=tmp1;  B[j+<span class="number">1</span>][i]=tmp2;  B[j+<span class="number">2</span>][i]=tmp3;  B[j+<span class="number">3</span>][i]=tmp4;</span><br><span class="line">        B[j+<span class="number">4</span>][i]=tmp5;  B[j+<span class="number">5</span>][i]=tmp6; B[j+<span class="number">6</span>][i]=tmp7;   B[j+<span class="number">7</span>][i]=tmp8;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>试着测试一下这个改进代码的性能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func 0 (Transpose submission): hits:898, misses:1155, evictions:1123</span><br></pre></td></tr></table></figure>

<p>很遗憾，这种运行模式好像没有提高性能。</p>
<p>我在这里卡了一段时间，最后得到的结论是，需要进一步的了解A，B的内存地址与cache的映射，这样才能做更加细致的分析和优化。</p>
<p>查看测试生成的数据trace.f0。在多次运行数据后，我发现多次测试生成的数组A的地址(0x0030a080)和数组B的地址(0x0034a080)都是固定的，那么我们就能够分析它们分别对应于cache中的哪个组，已经对应的标记位。</p>
<p>根据addr(A)=0x0030a080，addr(B)=0x0034a080，可以发现它们都映射到组4，但是都拥有不同的标记位。</p>
<p>具体分析我们上面的改进代码可以发现，每一轮中的8个对数组A的加载操作只会产生至多1次miss，但是每一次对于数组B的8次存储操作都会引发miss和evict。</p>
<p>下面给出 i=0,j=0 和 i=0，j=1这两个情况下，对数组B的存储操作的输出信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//i=0，j=0,冷启动,---&gt;右侧表示该内存地址对于的cache组</span></span><br><span class="line"> S <span class="number">0034</span>a080,<span class="number">4</span> miss evicts --&gt; saddr=<span class="number">4</span></span><br><span class="line"> S <span class="number">0034</span>a100,<span class="number">4</span> miss  --&gt; saddr=<span class="number">8</span></span><br><span class="line"> S <span class="number">0034</span>a180,<span class="number">4</span> miss  --&gt; saddr=<span class="number">12</span></span><br><span class="line"> S <span class="number">0034</span>a200,<span class="number">4</span> miss  --&gt; saddr=<span class="number">16</span></span><br><span class="line"> S <span class="number">0034</span>a280,<span class="number">4</span> miss  --&gt; saddr=<span class="number">20</span></span><br><span class="line"> S <span class="number">0034</span>a300,<span class="number">4</span> miss  --&gt; saddr=<span class="number">24</span></span><br><span class="line"> S <span class="number">0034</span>a380,<span class="number">4</span> miss  --&gt; saddr=<span class="number">28</span></span><br><span class="line"> S <span class="number">0034</span>a400,<span class="number">4</span> miss  --&gt; saddr=<span class="number">0</span></span><br><span class="line">--------------------------------------------------------------------------------------------------</span><br><span class="line"> <span class="comment">//i=0,j=1,--&gt;右侧表示被“驱逐出”cache的内存块的信息()</span></span><br><span class="line"> S <span class="number">0034</span>a480,<span class="number">4</span> miss evicts --&gt; evicts taddr=<span class="number">3368</span> saddr=<span class="number">4</span></span><br><span class="line"> S <span class="number">0034</span>a500,<span class="number">4</span> miss evicts     evicts taddr=<span class="number">3368</span> saddr=<span class="number">8</span></span><br><span class="line"> S <span class="number">0034</span>a580,<span class="number">4</span> miss evicts     evicts taddr=<span class="number">3368</span> saddr=<span class="number">12</span></span><br><span class="line"> S <span class="number">0034</span>a600,<span class="number">4</span> miss evicts     evicts taddr=<span class="number">3368</span> saddr=<span class="number">16</span></span><br><span class="line"> S <span class="number">0034</span>a680,<span class="number">4</span> miss evicts     evicts taddr=<span class="number">3368</span> saddr=<span class="number">20</span></span><br><span class="line"> S <span class="number">0034</span>a700,<span class="number">4</span> miss evicts     evicts taddr=<span class="number">3368</span> saddr=<span class="number">24</span>    </span><br><span class="line"> S <span class="number">0034</span>a780,<span class="number">4</span> miss evicts     evicts taddr=<span class="number">3368</span> saddr=<span class="number">28</span></span><br><span class="line"> S <span class="number">0034</span>a800,<span class="number">4</span> miss evicts     evicts taddr=<span class="number">3369</span> saddr=<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>可以看到第一轮加载入cache的B的内存块，在第二轮循环中全部被替换出cache，根据输出数据，后续的每一轮循环都会发生这种情况。</p>
<p>那么如何在保证对A维持这样高效的读取的同时，减少对B的冲突不命中呢？</p>
<p>这样就需要修改读取顺序，举例说我们第一组读入的是</p>
<p>B[ 0 ] [ 0 ]，B[ 1 ] [ 0 ]，B[ 2 ] [ 0 ]，B[ 3 ] [ 0 ]，B[ 4 ] [ 0 ]，B[ 5 ] [ 0 ]，B[ 6 ] [ 0 ]，B[ 7 ] [ 0 ]</p>
<p>那么假设我们第二轮读入的不是 B[ 8 ] [ 0 ]，B[ 9 ] [ 0 ]….</p>
<p>而是B[ 0 ] [ 1 ]，B[ 1 ] [ 1 ]，B[ 2 ] [ 1 ]，B[ 3 ] [ 1 ]，B[ 4 ] [ 1 ]，B[ 5 ] [ 1 ]，B[ 6 ] [ 1 ]，B[ 7 ] [ 1 ]</p>
<p>这样第二轮对于B的读取就能够全部命中（准确的说不一定是全部命中，有时会与A发生一次冲突)，并且对于A的高效读取策略也能够兼容。</p>
<p>根据以上的思路修改代码循环的顺序，得到以下代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">int</span> tmp1,tmp2,tmp3,tmp4;</span><br><span class="line">    <span class="keyword">int</span> tmp5,tmp6,tmp7,tmp8;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;M;j+=<span class="number">8</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            tmp1=A[i][j];  tmp2=A[i][j+<span class="number">1</span>];  tmp3=A[i][j+<span class="number">2</span>];  tmp4=A[i][j+<span class="number">3</span>];</span><br><span class="line">            tmp5=A[i][j+<span class="number">4</span>];  tmp6=A[i][j+<span class="number">5</span>];  tmp7=A[i][j+<span class="number">6</span>];  tmp8=A[i][j+<span class="number">7</span>];</span><br><span class="line">            B[j][i]=tmp1;  B[j+<span class="number">1</span>][i]=tmp2;  B[j+<span class="number">2</span>][i]=tmp3;  B[j+<span class="number">3</span>][i]=tmp4;</span><br><span class="line">            B[j+<span class="number">4</span>][i]=tmp5;  B[j+<span class="number">5</span>][i]=tmp6; B[j+<span class="number">6</span>][i]=tmp7;   B[j+<span class="number">7</span>][i]=tmp8;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//外循环按列，内循环按行，每一次在A中横着连续读8个int</span></span><br></pre></td></tr></table></figure>

<p>测试后得到性能如下，miss&lt;300，成功通过第一个测试点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func 0 (Transpose submission): hits:1766, misses:287, evictions:255</span><br></pre></td></tr></table></figure>



<h4 id="64x64"><a href="#64x64" class="headerlink" title="64x64"></a>64x64</h4><p>先使用32x32的代码测试一下，最后得到miss&gt;4000，可以知道，同样的代码在不同的矩阵下是无法通用的，根据讲义上的提示，我们可以根据每个测试点量身定做它独有的访问模式来提高缓存命中率。</p>
<p>重新审视一下这个矩阵，会发现由于列数从32扩展至64，使得每一行的元素实际上需要8个缓存组才能装下，这也说明，我们每次跨越一行，实际上跨越了8个缓存组，由于总共只有32个缓存组，所以在连续转换4行后，再转换到第五行时，会发生冲突不命中，将第一行的缓存数据驱逐出去，这就是我们沿用32x32的策略却效率很差的原因。</p>
<p>通过上述分析后，得出当一次只转置连续4个元素时，就不会发生冲突，这样就得到以下代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">int</span> tmp1,tmp2,tmp3,tmp4;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;M;j+=<span class="number">4</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        tmp1=A[i][j];  tmp2=A[i][j+<span class="number">1</span>];  tmp3=A[i][j+<span class="number">2</span>];  tmp4=A[i][j+<span class="number">3</span>];</span><br><span class="line">        B[j][i]=tmp1;  B[j+<span class="number">1</span>][i]=tmp2;  B[j+<span class="number">2</span>][i]=tmp3;  B[j+<span class="number">3</span>][i]=tmp4;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到测试结果如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func 0 (Transpose submission): hits:6546, misses:1651, evictions:1619</span><br></pre></td></tr></table></figure>

<p>可以看到miss的数量大幅下降，但是还未低于1300。</p>
<p>进一步分析，上述方法中，对B的每一个块只发生一次miss，但是对A的每一个块则发生两次miss(前4个元素一次，后四个一次)，那我们也许可以试着让A的每一个块只发生一次miss，即每一次都直接将块中的8个元素读出，前4个元素直接转换，但是后4个不能马上转换（如果立即转换就会发生冲突，参考上面关于32x32模式的低效原因），这时我们可以把它放在B的其他位置，因为我们有32个缓存组，但是实际上同一时间内的使用率却非常低，所以可以将它存放在不会发生冲突的缓存组。</p>
<p>我们计算一下对于一个8x8的块，这种改进的方法是否会优化miss数。</p>
<p>首先考虑一次只读4个元素转置的方法: misses=8(读入B的8个行)+16(每次读入A的半行)=24</p>
<p>再考虑改进后的方法: missed=8(读入B的4个行)+8(每次读入A的一个行)+4(读入用于暂存A中后4列的4个临时块)=20</p>
<p>可以发现效率有小幅提高，尝试写出代码并查看结果是否如我们推测的那样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i,j,k;</span><br><span class="line"><span class="keyword">int</span> tmp1,tmp2,tmp3,tmp4;</span><br><span class="line"><span class="keyword">int</span> tmp5,tmp6,tmp7,tmp8;</span><br><span class="line"><span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;N<span class="number">-8</span>;k+=<span class="number">8</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;M;j+=<span class="number">8</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i=k;i&lt;k+<span class="number">8</span>;i++)&#123;</span><br><span class="line">            tmp1=A[i][j];  tmp2=A[i][j+<span class="number">1</span>];  tmp3=A[i][j+<span class="number">2</span>];  tmp4=A[i][j+<span class="number">3</span>];</span><br><span class="line">            tmp5=A[i][j+<span class="number">4</span>]; tmp6=A[i][j+<span class="number">5</span>]; tmp7=A[i][j+<span class="number">6</span>]; tmp8=A[i][j+<span class="number">7</span>];</span><br><span class="line">            B[j][i]=tmp1;  B[j+<span class="number">1</span>][i]=tmp2;  B[j+<span class="number">2</span>][i]=tmp3;  B[j+<span class="number">3</span>][i]=tmp4;</span><br><span class="line">            </span><br><span class="line">            B[j][i+<span class="number">8</span>]=tmp5;  B[j+<span class="number">1</span>][i+<span class="number">8</span>]=tmp6;  B[j+<span class="number">2</span>][i+<span class="number">8</span>]=tmp7;  B[j+<span class="number">3</span>][i+<span class="number">8</span>]=tmp8; </span><br><span class="line">            <span class="comment">//暂存在B中的空闲位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=k;i&lt;k+<span class="number">8</span>;i++)&#123;  <span class="comment">//将暂存在B中空闲位置的数据转置到正确的位置</span></span><br><span class="line">            tmp1=B[j][i+<span class="number">8</span>]; tmp2=B[j+<span class="number">1</span>][i+<span class="number">8</span>]; tmp3=B[j+<span class="number">2</span>][i+<span class="number">8</span>]; tmp4=B[j+<span class="number">3</span>][i+<span class="number">8</span>];</span><br><span class="line">            B[j+<span class="number">4</span>][i]=tmp1; B[j+<span class="number">5</span>][i]=tmp2;  B[j+<span class="number">6</span>][i]=tmp3; B[j+<span class="number">7</span>][i]=tmp4;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;M;j+=<span class="number">4</span>)&#123; <span class="comment">//转置到最后一个块时，B的其他位置已经全部转置完毕，没有额外的空间暂存</span></span><br><span class="line">    <span class="comment">//只能退化为4x4的方式(一次只读4个元素)</span></span><br><span class="line">    <span class="keyword">for</span>(i=N<span class="number">-8</span>;i&lt;N;i++)&#123;</span><br><span class="line">        tmp1=A[i][j];  tmp2=A[i][j+<span class="number">1</span>];  tmp3=A[i][j+<span class="number">2</span>];  tmp4=A[i][j+<span class="number">3</span>];</span><br><span class="line">        B[j][i]=tmp1;  B[j+<span class="number">1</span>][i]=tmp2;  B[j+<span class="number">2</span>][i]=tmp3;  B[j+<span class="number">3</span>][i]=tmp4;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到测试结果如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func 0 (Transpose submission): hits:10354, misses:1427, evictions:1395</span><br></pre></td></tr></table></figure>

<p>可以看到，miss数大约减少了1/6，和我们分析的大致相同（miss数的减少有偏差是因为我们上述是对非对角线的块分析，对于对角线上的块而言，A，B在缓存中对应的组相同，A和B之间会发生冲突不命中，所以这些块转置时产生的miss数和我们分析的不一样）。</p>
<p>后续由于我实在想不到更好的优化方法了，只好上网查看其他大佬的解法。这里贴出一个大佬的博客，我觉得他写的十分清晰，同时也有相应的图示。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xbb224007/article/details/81103995">https://blog.csdn.net/xbb224007/article/details/81103995</a></p>
<p>对于这种方法的解析可以直接看上面这个博客，相比于我提供的优化方法而言，这个方法更进一步，它不需要读入额外的4个暂存块，而是使用巧妙的方法在块的内部进行暂存和转置，我这里只贴出自己的代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;N;k+=<span class="number">8</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;M;j+=<span class="number">8</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i=k;i&lt;k+<span class="number">4</span>;i++)&#123;   <span class="comment">//前四行,前四列正常转置，后四列翻转后暂存在B的非对应位中</span></span><br><span class="line">            tmp1=A[i][j];  tmp2=A[i][j+<span class="number">1</span>];  tmp3=A[i][j+<span class="number">2</span>];  tmp4=A[i][j+<span class="number">3</span>];</span><br><span class="line">            tmp5=A[i][j+<span class="number">4</span>]; tmp6=A[i][j+<span class="number">5</span>]; tmp7=A[i][j+<span class="number">6</span>]; tmp8=A[i][j+<span class="number">7</span>];</span><br><span class="line">            B[j][i]=tmp1;  B[j+<span class="number">1</span>][i]=tmp2;  B[j+<span class="number">2</span>][i]=tmp3;  B[j+<span class="number">3</span>][i]=tmp4;</span><br><span class="line">            B[j][i+<span class="number">4</span>]=tmp5; B[j+<span class="number">1</span>][i+<span class="number">4</span>]=tmp6; B[j+<span class="number">2</span>][i+<span class="number">4</span>]=tmp7; B[j+<span class="number">3</span>][i+<span class="number">4</span>]=tmp8;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(d=j;d&lt;j+<span class="number">4</span>;d++)&#123;  <span class="comment">//后四行前四列(corner case)</span></span><br><span class="line">            tmp1=A[k+<span class="number">4</span>][d]; tmp2=A[k+<span class="number">5</span>][d]; tmp3=A[k+<span class="number">6</span>][d]; tmp4=A[k+<span class="number">7</span>][d];</span><br><span class="line">            tmp5=B[d][k+<span class="number">4</span>]; tmp6=B[d][k+<span class="number">5</span>]; tmp7=B[d][k+<span class="number">6</span>]; tmp8=B[d][k+<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">            B[d][k+<span class="number">4</span>]=tmp1;  B[d][k+<span class="number">5</span>]=tmp2; B[d][k+<span class="number">6</span>]=tmp3; B[d][k+<span class="number">7</span>]=tmp4;</span><br><span class="line">            <span class="comment">//这两行的顺序很重要，不能颠倒，否则会导致大量的冲突不命中</span></span><br><span class="line">            B[<span class="number">4</span>+d][k]=tmp5; B[<span class="number">4</span>+d][k+<span class="number">1</span>]=tmp6; B[<span class="number">4</span>+d][k+<span class="number">2</span>]=tmp7; B[<span class="number">4</span>+d][k+<span class="number">3</span>]=tmp8;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=k+<span class="number">4</span>;i&lt;k+<span class="number">8</span>;i++)&#123;  <span class="comment">//后四行后四列，按4x4块的模式转置</span></span><br><span class="line">            tmp1=A[i][j+<span class="number">4</span>]; tmp2=A[i][j+<span class="number">5</span>]; tmp3=A[i][j+<span class="number">6</span>];  tmp4=A[i][j+<span class="number">7</span>];</span><br><span class="line">            B[j+<span class="number">4</span>][i]=tmp1; B[j+<span class="number">5</span>][i]=tmp2; B[j+<span class="number">6</span>][i]=tmp3;  B[j+<span class="number">7</span>][i]=tmp4;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终运行效率如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func 0 (Transpose submission): hits:9066, misses:1179, evictions:1147</span><br></pre></td></tr></table></figure>



<h4 id="61x67"><a href="#61x67" class="headerlink" title="61x67"></a>61x67</h4><p>可以发现，当列数由64变为67时，数组中不同元素在cache中对应的组也会发生变化。</p>
<p>下面取前8行第一个元素，分析它们在不同矩阵中所属缓存组的变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在64x64矩阵中                         &#x2F;&#x2F;在61x67矩阵中</span><br><span class="line">A[0][0]---&gt;saddr&#x3D;4                     A[0][0]-----&gt;saddr&#x3D;4</span><br><span class="line">A[1][0]---&gt;saddr&#x3D;12                    A[1][0]-----&gt;saddr&#x3D;11</span><br><span class="line">A[2][0]---&gt;saddr&#x3D;20                    A[2][0]-----&gt;saddr&#x3D;19</span><br><span class="line">A[3][0]---&gt;saddr&#x3D;28                    A[3][0]-----&gt;saddr&#x3D;26</span><br><span class="line">A[4][0]---&gt;saddr&#x3D;4                     A[4][0]-----&gt;saddr&#x3D;2</span><br><span class="line">A[5][0]---&gt;saddr&#x3D;12                    A[5][0]-----&gt;saddr&#x3D;10</span><br><span class="line">A[6][0]---&gt;saddr&#x3D;20                    A[6][0]-----&gt;saddr&#x3D;17</span><br><span class="line">A[7][0]---&gt;saddr&#x3D;28                    A[7][0]-----&gt;saddr&#x3D;25</span><br></pre></td></tr></table></figure>

<p>所属缓存组的变化会直接影响到冲突不命中的情况，当元素的所属组不同时，就能够更加充分的利用cache的空间，我们就能够使用更大的分块处理数据，并且能够得到一个较低的miss数。</p>
<p>通过分析得知，在61x67矩阵中，我们可以像32x32矩阵那样一次处理8x8的分块，并且不会发生大量的冲突不命中（64x64则会发生大量冲突），所以我们可以先试着对其进行8x8的分块，最右侧剩余(61%8=5)的部分单独处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;M;j+=<span class="number">8</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(j==<span class="number">56</span>)&#123;</span><br><span class="line">         tmp1=A[i][j];  tmp2=A[i][j+<span class="number">1</span>];  tmp3=A[i][j+<span class="number">2</span>];  </span><br><span class="line">         tmp4=A[i][j+<span class="number">3</span>];  tmp5=A[i][j+<span class="number">4</span>];</span><br><span class="line">         B[j][i]=tmp1;  B[j+<span class="number">1</span>][i]=tmp2;  B[j+<span class="number">2</span>][i]=tmp3;  </span><br><span class="line">         B[j+<span class="number">3</span>][i]=tmp4; B[j+<span class="number">4</span>][i]=tmp5;</span><br><span class="line">      &#125;</span><br><span class="line">      tmp1=A[i][j];  tmp2=A[i][j+<span class="number">1</span>];  tmp3=A[i][j+<span class="number">2</span>];  tmp4=A[i][j+<span class="number">3</span>];</span><br><span class="line">      tmp5=A[i][j+<span class="number">4</span>];  tmp6=A[i][j+<span class="number">5</span>];  tmp7=A[i][j+<span class="number">6</span>];  tmp8=A[i][j+<span class="number">7</span>];</span><br><span class="line">      B[j][i]=tmp1;  B[j+<span class="number">1</span>][i]=tmp2;  B[j+<span class="number">2</span>][i]=tmp3;  B[j+<span class="number">3</span>][i]=tmp4;</span><br><span class="line">      B[j+<span class="number">4</span>][i]=tmp5;  B[j+<span class="number">5</span>][i]=tmp6; B[j+<span class="number">6</span>][i]=tmp7;   B[j+<span class="number">7</span>][i]=tmp8;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>性能测试结果如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Summary for official submission (func 0): correctness&#x3D;1 misses&#x3D;1852</span><br></pre></td></tr></table></figure>

<p>可以发现，我们只是简单的做了个8x8的分块，就达到了要求，看来这个测试点还是比较水的- -</p>
<p>最终测试结果:</p>
<p><img src="C:\Users\25344\AppData\Roaming\Typora\typora-user-images\image-20200717173441806.png" alt="image-20200717173441806"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/30/csapp-bombLab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="wwow">
      <meta itemprop="description" content="努力不一定会成功，但不努力真的很舒服">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wwow's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/30/csapp-bombLab/" class="post-title-link" itemprop="url">csapp-bomblab</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-30 00:02:15 / 修改时间：11:58:04" itemprop="dateCreated datePublished" datetime="2020-08-30T00:02:15+08:00">2020-08-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/csapp/" itemprop="url" rel="index"><span itemprop="name">csapp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="CSAPP-BombLab"><a href="#CSAPP-BombLab" class="headerlink" title="CSAPP-BombLab"></a>CSAPP-BombLab</h3><p>GDB简要指南:<a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/3e/docs/gdbnotes-x86-64.pdf">http://csapp.cs.cmu.edu/3e/docs/gdbnotes-x86-64.pdf</a></p>
<p>BombLab主要是为了学习如何阅读汇编代码和使用调试工具。</p>
<p>在csapp的网站下载的实验文件有3个，我们需要使用的是bomb文件，以及bomb.c文件，</p>
<p>bomb.c文件是用于方便我们了解实验的流程的。</p>
<p>而bomb则是实验的主要内容，使用objdump将它转为汇编代码，然后根据main函数的执行流程一路追踪程序的走向，这个lab总共有6个phase，每一个phase要求我们输入一个字符串，如果字符串不符合要求炸弹就会爆炸，我们需要通过跟踪观察它们的汇编代码来找到正确的字符串。</p>
<h4 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phase_1</span><span class="params">(<span class="keyword">char</span>* input)</span></span>&#123;</span><br><span class="line">	<span class="comment">//input in %rdi</span></span><br><span class="line">    <span class="keyword">char</span>* cmp=<span class="number">0x402400</span>;</span><br><span class="line">    <span class="keyword">if</span>(strings_not_equal(input,cmp)) <span class="comment">//相等返回0，不等返回1</span></span><br><span class="line">        explode_bomb();  <span class="comment">//答案错误，炸弹爆炸</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将phase_1对应的汇编代码翻译为C程序。</p>
<p>由C程序可知，phase_1将我们输入的字符串和地址为0x402400的字符串相比较，如果不等则失败，相等则成功，所以我们只要调试得到0x402400处的内容就行。</p>
<p>得到第一个答案“Border relations with Canada have never been better.”</p>
<h4 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">0000000000400efc &lt;phase_2&gt;:</span><br><span class="line">  400efc:	55                   	push   %rbp</span><br><span class="line">  400efd:	53                   	push   %rbx</span><br><span class="line">  400efe:	48 83 ec 28          	sub    $0x28,%rsp</span><br><span class="line">  400f02:	48 89 e6             	mov    %rsp,%rsi</span><br><span class="line">  400f05:	e8 52 05 00 00       	callq  40145c &lt;read_six_numbers&gt;</span><br><span class="line">  ;从我们提供的字符串中读入6个数，如果读出数据个数小于6则爆炸;读出数据存放在(%rsp)</span><br><span class="line">  400f0a:	83 3c 24 01          	cmpl   $0x1,(%rsp)</span><br><span class="line">  ;比较第一个数是否是1</span><br><span class="line">  400f0e:	74 20                	je     400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  ;第一个数是1，跳转</span><br><span class="line">  400f10:	e8 25 05 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  ;第一个数不是1，爆炸</span><br><span class="line">  400f15:	eb 19                	jmp    400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  400f17:	8b 43 fc             	mov    -0x4(%rbx),%eax</span><br><span class="line">  400f1a:	01 c0                	add    %eax,%eax</span><br><span class="line">  400f1c:	39 03                	cmp    %eax,(%rbx)</span><br><span class="line">  ;比较第i个数是否是第i-1个数的两倍，如果是则继续，不是则爆炸</span><br><span class="line">  400f1e:	74 05                	je     400f25 &lt;phase_2+0x29&gt;</span><br><span class="line">  400f20:	e8 15 05 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f25:	48 83 c3 04          	add    $0x4,%rbx</span><br><span class="line">  ;判断下一个数是否满足要求</span><br><span class="line">  400f29:	48 39 eb             	cmp    %rbp,%rbx</span><br><span class="line">  ;如果%rbx&#x3D;%rbp,6个数全部符合要求，通过phase2</span><br><span class="line">  400f2c:	75 e9                	jne    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f2e:	eb 0c                	jmp    400f3c &lt;phase_2+0x40&gt;</span><br><span class="line">  400f30:	48 8d 5c 24 04       	lea    0x4(%rsp),%rbx</span><br><span class="line">  400f35:	48 8d 6c 24 18       	lea    0x18(%rsp),%rbp</span><br><span class="line">  ;设置结束位，当%rbx&#x3D;%rbp时，说明字符串符合要求，通过phase2</span><br><span class="line">  400f3a:	eb db                	jmp    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f3c:	48 83 c4 28          	add    $0x28,%rsp</span><br><span class="line">  400f40:	5b                   	pop    %rbx</span><br><span class="line">  400f41:	5d                   	pop    %rbp</span><br><span class="line">  400f42:	c3                   	retq   </span><br></pre></td></tr></table></figure>

<p>从上述解析中可以得出,要求输入6个数，第一个数为1，后续每一个数是前一个数的两倍，则phase_2的答案是“1 2 4 8 16 32”</p>
<h4 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">0000000000400f43 &lt;phase_3&gt;:</span><br><span class="line">  400f43:	48 83 ec 18          	sub    $0x18,%rsp</span><br><span class="line">  400f47:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx</span><br><span class="line">  400f4c:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx</span><br><span class="line">  400f51:	be cf 25 40 00       	mov    $0x4025cf,%esi</span><br><span class="line">  400f56:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  400f5b:	e8 90 fc ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  ;print 0x4025cf得到字符串&quot;%d %d&quot;</span><br><span class="line">  ;要求输入2个整数,如果输入的数的个数不对，炸弹爆炸</span><br><span class="line">  400f60:	83 f8 01             	cmp    $0x1,%eax</span><br><span class="line">  400f63:	7f 05                	jg     400f6a &lt;phase_3+0x27&gt;</span><br><span class="line">  400f65:	e8 d0 04 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f6a:	83 7c 24 08 07       	cmpl   $0x7,0x8(%rsp)</span><br><span class="line">  ;检测输入的第一个数是否大于7，如果是则炸弹爆炸</span><br><span class="line">  400f6f:	77 3c                	ja     400fad &lt;phase_3+0x6a&gt;</span><br><span class="line">  400f71:	8b 44 24 08          	mov    0x8(%rsp),%eax</span><br><span class="line">  400f75:	ff 24 c5 70 24 40 00 	jmpq   *0x402470(,%rax,8)</span><br><span class="line">  ;根据第一个数进行跳转(0x402470存放跳转表)</span><br><span class="line">  ;0x400f7c-&gt;0</span><br><span class="line">  ;0x400fb9-&gt;1</span><br><span class="line">  ;0x400f83-&gt;2</span><br><span class="line">  ;0x400f8a-&gt;3</span><br><span class="line">  ;0x400f91-&gt;4</span><br><span class="line">  ;0x400f98-&gt;5</span><br><span class="line">  ;0x400f9f-&gt;6</span><br><span class="line">  ;0x400fa6-&gt;7</span><br><span class="line">  400f7c:	b8 cf 00 00 00       	mov    $0xcf,%eax</span><br><span class="line">  ;当第一个数为0时跳转到此处</span><br><span class="line">  400f81:	eb 3b                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f83:	b8 c3 02 00 00       	mov    $0x2c3,%eax</span><br><span class="line">  ;当第一个数为2时跳转到此处</span><br><span class="line">  400f88:	eb 34                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f8a:	b8 00 01 00 00       	mov    $0x100,%eax</span><br><span class="line">  ;当第一个数为3时跳转到此处 </span><br><span class="line">  400f8f:	eb 2d                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f91:	b8 85 01 00 00       	mov    $0x185,%eax</span><br><span class="line">  ;当第一个数为4时跳转到此处 </span><br><span class="line">  400f96:	eb 26                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f98:	b8 ce 00 00 00       	mov    $0xce,%eax</span><br><span class="line">  ;当第一个数为5时跳转到此处 </span><br><span class="line">  400f9d:	eb 1f                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f9f:	b8 aa 02 00 00       	mov    $0x2aa,%eax</span><br><span class="line">  ;当第一个数为6时跳转到此处 </span><br><span class="line">  400fa4:	eb 18                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fa6:	b8 47 01 00 00       	mov    $0x147,%eax</span><br><span class="line">  ;当第一个数为7时跳转到此处 </span><br><span class="line">  400fab:	eb 11                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fad:	e8 88 04 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fb2:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  400fb7:	eb 05                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fb9:	b8 37 01 00 00       	mov    $0x137,%eax</span><br><span class="line">  ;当第一个数为1时跳转到此处</span><br><span class="line">  400fbe:	3b 44 24 0c          	cmp    0xc(%rsp),%eax</span><br><span class="line">  ;比较第二个数是否等于%eax，如果不等则爆炸，相等则成功拆弹</span><br><span class="line">  400fc2:	74 05                	je     400fc9 &lt;phase_3+0x86&gt;</span><br><span class="line">  400fc4:	e8 71 04 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fc9:	48 83 c4 18          	add    $0x18,%rsp</span><br><span class="line">  400fcd:	c3                   	retq   </span><br></pre></td></tr></table></figure>

<p>可以看到，选择不同分支可以得到不同的答案（输入字符串时要写十进制数）,选择其中一个组合就可通过phase_3</p>
<table>
<thead>
<tr>
<th align="center">第一个数</th>
<th align="center">第二个数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0xcf(207)</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0x137(311)</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">0x2c3(707)</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">0x100(256)</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">0x185(389)</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">0xce(206)</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">0x2aa(682)</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">0x147(327)</td>
</tr>
</tbody></table>
<h4 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">000000000040100c &lt;phase_4&gt;:</span><br><span class="line">  40100c:	48 83 ec 18          	sub    $0x18,%rsp</span><br><span class="line">  401010:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx</span><br><span class="line">  401015:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx</span><br><span class="line">  40101a:	be cf 25 40 00       	mov    $0x4025cf,%esi</span><br><span class="line">  ;和phase_3中一样，0x4025cf处存放字符串&quot;%d %d&quot;和scanf配合使用读入2个数字</span><br><span class="line">  40101f:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401024:	e8 c7 fb ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  401029:	83 f8 02             	cmp    $0x2,%eax</span><br><span class="line">  ;如果读入的数字不是2个，炸弹爆炸</span><br><span class="line">  40102c:	75 07                	jne    401035 &lt;phase_4+0x29&gt;</span><br><span class="line">  40102e:	83 7c 24 08 0e       	cmpl   $0xe,0x8(%rsp)</span><br><span class="line">  ;如果第一个数小于等于14则继续，否则炸弹爆炸</span><br><span class="line">  ;这里是无符号等于，如果第一个数是负数也会爆炸（将补码当作无符号数看）</span><br><span class="line">  401033:	76 05                	jbe    40103a &lt;phase_4+0x2e&gt;</span><br><span class="line">  401035:	e8 00 04 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  40103a:	ba 0e 00 00 00       	mov    $0xe,%edx</span><br><span class="line">  40103f:	be 00 00 00 00       	mov    $0x0,%esi</span><br><span class="line">  401044:	8b 7c 24 08          	mov    0x8(%rsp),%edi</span><br><span class="line">  ;%rdi-&gt;第一个数 %rsi-&gt;0  %rdx-&gt;0xe  %rcx-&gt;第二个数，进入函数func4</span><br><span class="line">  401048:	e8 81 ff ff ff       	callq  400fce &lt;func4&gt;</span><br><span class="line">  40104d:	85 c0                	test   %eax,%eax</span><br><span class="line">  ;返回值为0则继续，否则炸弹爆炸</span><br><span class="line">  40104f:	75 07                	jne    401058 &lt;phase_4+0x4c&gt;</span><br><span class="line">  401051:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%rsp)</span><br><span class="line">  ;第二个数为0则拆弹成功，否则爆炸</span><br><span class="line">  401056:	74 05                	je     40105d &lt;phase_4+0x51&gt;</span><br><span class="line">  401058:	e8 dd 03 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  40105d:	48 83 c4 18          	add    $0x18,%rsp</span><br><span class="line">  401061:	c3                   	retq   </span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">0000000000400fce &lt;func4&gt;:</span><br><span class="line">  ;这个函数涉及到递归，但是只要输出的答案正确，一次调用就能够返回</span><br><span class="line">  ;随着func4的递归调用，后续函数调用中%rax和%rcx的内容可能有所不同</span><br><span class="line">  ;注释中%rax,%rcx的数值只针对第一次调用的情况</span><br><span class="line">  400fce:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  400fd2:	89 d0                	mov    %edx,%eax</span><br><span class="line">  ;%rax&#x3D;14</span><br><span class="line">  400fd4:	29 f0                	sub    %esi,%eax</span><br><span class="line">  400fd6:	89 c1                	mov    %eax,%ecx</span><br><span class="line">  ;%rcx&#x3D;14</span><br><span class="line">  400fd8:	c1 e9 1f             	shr    $0x1f,%ecx</span><br><span class="line">  ;%rcx&#x3D;0</span><br><span class="line">  400fdb:	01 c8                	add    %ecx,%eax</span><br><span class="line">  400fdd:	d1 f8                	sar    %eax</span><br><span class="line">  ;%eax&#x3D;7</span><br><span class="line">  400fdf:	8d 0c 30             	lea    (%rax,%rsi,1),%ecx</span><br><span class="line">  ;%rcx&#x3D;7</span><br><span class="line">  400fe2:	39 f9                	cmp    %edi,%ecx</span><br><span class="line">  ;比较第一个输入的数和%rcx(7)的大小,如果第一个数大于等于%rcx则跳转到0x400ff2执行</span><br><span class="line">  ;如果第一个数小于%rcx，则将修改%rdx的值，然后递归调用func4</span><br><span class="line">  400fe4:	7e 0c                	jle    400ff2 &lt;func4+0x24&gt;</span><br><span class="line">  400fe6:	8d 51 ff             	lea    -0x1(%rcx),%edx</span><br><span class="line">  400fe9:	e8 e0 ff ff ff       	callq  400fce &lt;func4&gt;</span><br><span class="line">  400fee:	01 c0                	add    %eax,%eax</span><br><span class="line">  400ff0:	eb 15                	jmp    401007 &lt;func4+0x39&gt;</span><br><span class="line">  400ff2:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  400ff7:	39 f9                	cmp    %edi,%ecx</span><br><span class="line">  ;比较第一个输入的数和%rcx(7)的大小,如果第一个数小于等于%rcx则func4调用结束，返回0</span><br><span class="line">  ;如果第一个数大于%rcx，则将修改%rsi的值，然后递归调用func4</span><br><span class="line">  400ff9:	7d 0c                	jge    401007 &lt;func4+0x39&gt;</span><br><span class="line">  400ffb:	8d 71 01             	lea    0x1(%rcx),%esi</span><br><span class="line">  400ffe:	e8 cb ff ff ff       	callq  400fce &lt;func4&gt;</span><br><span class="line">  401003:	8d 44 00 01          	lea    0x1(%rax,%rax,1),%eax</span><br><span class="line">  401007:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">  40100b:	c3                   	retq   </span><br></pre></td></tr></table></figure>

<p>根据上述分析，可以得知fun4用于检验第一个数是否符合要求，根据分析func4一次调用的情况，可以知道当第一个数为7时符合要求，而第二个数则要为0，综上phase_4的答案是“7 0”</p>
<p>对于递归函数func4，我们只考虑了第一次调用就成功返回0的情况，也许通过递归调用，我们能够得到其他答案，为了进一步分析func4，我们将它转化为C程序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func4</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line"><span class="comment">//%rdi-&gt;a   %rsi-&gt;b  %rdx-&gt;c  %rcx-&gt;d</span></span><br><span class="line">	d=c/<span class="number">2</span>+b;</span><br><span class="line">	<span class="keyword">if</span>(d&lt;=a)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a&lt;=d)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">2</span>*func4(a,d+<span class="number">1</span>,c,d)+<span class="number">1</span>;  <span class="comment">//该分支的返回值一定不等于0，不用考虑</span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span>*func4(a,b,d<span class="number">-1</span>,d);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第一次调用时</p>
<p>a=x,b=0,c=14,d=y   (x为我们输入的第一个数，y是我们输入的第二个数)</p>
<p>当x=7时，调用1次func4返回0</p>
<p>当x=3时，调用2次func4返回0</p>
<p>当x=1时，调用3次func4返回0</p>
<p>当x=0时，调用4次func4返回0</p>
<p>其他情况都不能使func4满足要求，所以phase_4的最终答案为</p>
<p>“7，0” 或 “3，0” 或 “1，0” 或 “0，0”</p>
<h4 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">0000000000401062 &lt;phase_5&gt;:</span><br><span class="line">  401062:	53                   	push   %rbx</span><br><span class="line">  401063:	48 83 ec 20          	sub    $0x20,%rsp</span><br><span class="line">  401067:	48 89 fb             	mov    %rdi,%rbx</span><br><span class="line">  40106a:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax</span><br><span class="line">  401071:	00 00 </span><br><span class="line">  401073:	48 89 44 24 18       	mov    %rax,0x18(%rsp)</span><br><span class="line">  ;设置金丝雀值</span><br><span class="line">  401078:	31 c0                	xor    %eax,%eax</span><br><span class="line">  40107a:	e8 9c 02 00 00       	callq  40131b &lt;string_length&gt;</span><br><span class="line">  40107f:	83 f8 06             	cmp    $0x6,%eax</span><br><span class="line">  ;如果读入的字符串长度不等于6则爆炸</span><br><span class="line">  401082:	74 4e                	je     4010d2 &lt;phase_5+0x70&gt;</span><br><span class="line">  401084:	e8 b1 03 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401089:	eb 47                	jmp    4010d2 &lt;phase_5+0x70&gt;</span><br><span class="line">  ;循环从40108b开始，循环变量存放在%rax处</span><br><span class="line">  40108b:	0f b6 0c 03          	movzbl (%rbx,%rax,1),%ecx</span><br><span class="line">  ;将输入字符串的第%rax个字符(ascii码)写入%rcx</span><br><span class="line">  40108f:	88 0c 24             	mov    %cl,(%rsp)</span><br><span class="line">  401092:	48 8b 14 24          	mov    (%rsp),%rdx</span><br><span class="line">  ;将输入字符串的第%rax个字符(ascii码)写入%rdx</span><br><span class="line">  401096:	83 e2 0f             	and    $0xf,%edx</span><br><span class="line">  ;将输入字符串的第%rax个字符(ascii码)与0xf想与后写入%rdx</span><br><span class="line">  401099:	0f b6 92 b0 24 40 00 	movzbl 0x4024b0(%rdx),%edx</span><br><span class="line">  ;根据%rdx的内容访问字符表</span><br><span class="line">  4010a0:	88 54 04 10          	mov    %dl,0x10(%rsp,%rax,1)</span><br><span class="line">  ;将从跳转表中取出的字符传入以rsp+0x10为初值的第%rax个字符处</span><br><span class="line">  4010a4:	48 83 c0 01          	add    $0x1,%rax</span><br><span class="line">  4010a8:	48 83 f8 06          	cmp    $0x6,%rax</span><br><span class="line">  ;当循环执行6次则跳出</span><br><span class="line">  4010ac:	75 dd                	jne    40108b &lt;phase_5+0x29&gt;</span><br><span class="line">  4010ae:	c6 44 24 16 00       	movb   $0x0,0x16(%rsp)</span><br><span class="line">  4010b3:	be 5e 24 40 00       	mov    $0x40245e,%esi</span><br><span class="line">  4010b8:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi</span><br><span class="line">  4010bd:	e8 76 02 00 00       	callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">  ;将rsp+0x10开始的6个字符(循环中从字符表取出的6个字符)和0x40245e的6个字符比较</span><br><span class="line">  ;0x40245e-&gt;&quot;flyers&quot;</span><br><span class="line">  ;如果不等则炸弹爆炸</span><br><span class="line">  4010c2:	85 c0                	test   %eax,%eax</span><br><span class="line">  4010c4:	74 13                	je     4010d9 &lt;phase_5+0x77&gt;</span><br><span class="line">  4010c6:	e8 6f 03 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  4010cb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)</span><br><span class="line">  4010d0:	eb 07                	jmp    4010d9 &lt;phase_5+0x77&gt;</span><br><span class="line">  4010d2:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  ;for循环中，初始化%eax&#x3D;0</span><br><span class="line">  4010d7:	eb b2                	jmp    40108b &lt;phase_5+0x29&gt;</span><br><span class="line">  4010d9:	48 8b 44 24 18       	mov    0x18(%rsp),%rax</span><br><span class="line">  4010de:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax</span><br><span class="line">  ;比对金丝雀值查看是否存在缓冲区溢出</span><br><span class="line">  4010e5:	00 00 </span><br><span class="line">  4010e7:	74 05                	je     4010ee &lt;phase_5+0x8c&gt;</span><br><span class="line">  4010e9:	e8 42 fa ff ff       	callq  400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">  4010ee:	48 83 c4 20          	add    $0x20,%rsp</span><br><span class="line">  4010f2:	5b                   	pop    %rbx</span><br><span class="line">  4010f3:	c3                   	retq   </span><br></pre></td></tr></table></figure>

<p>根据上述的代码分析我们可以知道，这段程序首先会检查我们输入的字符串长度，要求字符串长度为6个字符才能继续执行，然后会根据我们输入的每个<strong>字符的ascii码的低4位</strong>查询位于0x4024b0的字符表，这样可以映射得到新的一串字符(长度同样为6)，最后将其与字符串”flyers”比对，如果相等则拆弹成功。</p>
<p>我们要使映射字符表得到的新字符串等于”flyers”，首先需要知道字符表的内容。</p>
<p>字符表</p>
<table>
<thead>
<tr>
<th align="center">相对于0x4024b0的偏移</th>
<th align="center">字符内容</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">m</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">a</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">d</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">u</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">i</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">e</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">r</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">s</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">n</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">f</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">o</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">t</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">v</td>
</tr>
<tr>
<td align="center">13</td>
<td align="center">b</td>
</tr>
<tr>
<td align="center">14</td>
<td align="center">y</td>
</tr>
<tr>
<td align="center">15</td>
<td align="center">l</td>
</tr>
</tbody></table>
<p>要想根据上表得到”flyers”，我们的六个字符的ascii码的低4位分别位9,f,e,5,6,7</p>
<p>任意取一个高位，假设我们取高4位为6，则对应的ascii码为0x6x（x取上面这6个数）</p>
<p>例如第一个字符就等于0x69–&gt;’ i ‘,以此类推得到字符串为”ionefg”</p>
<p>则字符串”ionefg”为phase_5的一个答案。</p>
<h4 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">00000000004010f4 &lt;phase_6&gt;:</span><br><span class="line">  4010f4:	41 56                	push   %r14</span><br><span class="line">  4010f6:	41 55                	push   %r13</span><br><span class="line">  4010f8:	41 54                	push   %r12</span><br><span class="line">  4010fa:	55                   	push   %rbp</span><br><span class="line">  4010fb:	53                   	push   %rbx</span><br><span class="line">  4010fc:	48 83 ec 50          	sub    $0x50,%rsp</span><br><span class="line">  401100:	49 89 e5             	mov    %rsp,%r13</span><br><span class="line">  401103:	48 89 e6             	mov    %rsp,%rsi</span><br><span class="line">  401106:	e8 51 03 00 00       	callq  40145c &lt;read_six_numbers&gt;</span><br><span class="line">  ;读入6个数</span><br><span class="line">  40110b:	49 89 e6             	mov    %rsp,%r14</span><br><span class="line">  40110e:	41 bc 00 00 00 00    	mov    $0x0,%r12d</span><br><span class="line">  401114:	4c 89 ed             	mov    %r13,%rbp</span><br><span class="line">  401117:	41 8b 45 00          	mov    0x0(%r13),%eax</span><br><span class="line">  40111b:	83 e8 01             	sub    $0x1,%eax</span><br><span class="line">  40111e:	83 f8 05             	cmp    $0x5,%eax</span><br><span class="line">  ;每一个读入的数都要在1~6之间</span><br><span class="line">  401121:	76 05                	jbe    401128 &lt;phase_6+0x34&gt;</span><br><span class="line">  401123:	e8 12 03 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401128:	41 83 c4 01          	add    $0x1,%r12d</span><br><span class="line">  40112c:	41 83 fc 06          	cmp    $0x6,%r12d</span><br><span class="line">  401130:	74 21                	je     401153 &lt;phase_6+0x5f&gt;</span><br><span class="line">  401132:	44 89 e3             	mov    %r12d,%ebx</span><br><span class="line">  401135:	48 63 c3             	movslq %ebx,%rax</span><br><span class="line">  401138:	8b 04 84             	mov    (%rsp,%rax,4),%eax</span><br><span class="line">  40113b:	39 45 00             	cmp    %eax,0x0(%rbp)</span><br><span class="line">  40113e:	75 05                	jne    401145 &lt;phase_6+0x51&gt;</span><br><span class="line">  401140:	e8 f5 02 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401145:	83 c3 01             	add    $0x1,%ebx</span><br><span class="line">  401148:	83 fb 05             	cmp    $0x5,%ebx</span><br><span class="line">  40114b:	7e e8                	jle    401135 &lt;phase_6+0x41&gt;</span><br><span class="line">  40114d:	49 83 c5 04          	add    $0x4,%r13</span><br><span class="line">  401151:	eb c1                	jmp    401114 &lt;phase_6+0x20&gt;</span><br><span class="line">  ;循环判断，要求每一个数与其他数互不相等</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">401153:	48 8d 74 24 18       	lea    0x18(%rsp),%rsi</span><br><span class="line">401158:	4c 89 f0             	mov    %r14,%rax</span><br><span class="line">40115b:	b9 07 00 00 00       	mov    $0x7,%ecx</span><br><span class="line">401160:	89 ca                	mov    %ecx,%edx</span><br><span class="line">401162:	2b 10                	sub    (%rax),%edx</span><br><span class="line">401164:	89 10                	mov    %edx,(%rax)</span><br><span class="line">401166:	48 83 c0 04          	add    $0x4,%rax</span><br><span class="line">40116a:	48 39 f0             	cmp    %rsi,%rax</span><br><span class="line">40116d:	75 f1                	jne    401160 &lt;phase_6+0x6c&gt;</span><br><span class="line">40116f:	be 00 00 00 00       	mov    $0x0,%esi</span><br><span class="line">401174:	eb 21                	jmp    401197 &lt;phase_6+0xa3&gt;</span><br><span class="line">;对于每一个数x，将其转换为7-x</span><br></pre></td></tr></table></figure>



<p>以我的水平只能翻译到这里，后面的访存，跳转操作实在太绕了，我思路完全理不清，所以参考了网上一些大佬的文章，看了看思路，最后勉强理解的整体流程。</p>
<p>下面是后续部分的代码解析（参考:<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/28422249%EF%BC%89">https://zhuanlan.zhihu.com/p/28422249）</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">401176:	48 8b 52 08          	mov    0x8(%rdx),%rdx</span><br><span class="line">40117a:	83 c0 01             	add    $0x1,%eax</span><br><span class="line">40117d:	39 c8                	cmp    %ecx,%eax</span><br><span class="line">40117f:	75 f5                	jne    401176 &lt;phase_6+0x82&gt;</span><br><span class="line">401181:	eb 05                	jmp    401188 &lt;phase_6+0x94&gt;</span><br><span class="line">401183:	ba d0 32 60 00       	mov    $0x6032d0,%edx</span><br><span class="line">401188:	48 89 54 74 20       	mov    %rdx,0x20(%rsp,%rsi,2)</span><br><span class="line">40118d:	48 83 c6 04          	add    $0x4,%rsi</span><br><span class="line">401191:	48 83 fe 18          	cmp    $0x18,%rsi</span><br><span class="line">401195:	74 14                	je     4011ab &lt;phase_6+0xb7&gt;</span><br><span class="line"></span><br><span class="line">401197:	8b 0c 34             	mov    (%rsp,%rsi,1),%ecx</span><br><span class="line">40119a:	83 f9 01             	cmp    $0x1,%ecx</span><br><span class="line">40119d:	7e e4                	jle    401183 &lt;phase_6+0x8f&gt;</span><br><span class="line">40119f:	b8 01 00 00 00       	mov    $0x1,%eax</span><br><span class="line">4011a4:	ba d0 32 60 00       	mov    $0x6032d0,%edx</span><br><span class="line">4011a9:	eb cb                	jmp    401176 &lt;phase_6+0x82&gt;</span><br><span class="line">;将6个数一一做判断，对于第i个数（从0开始）,根据它的大小不同，将不同数存入(rsp+20+8i)中。</span><br><span class="line">;具体映射情况如下</span><br><span class="line">;1-&gt;0x6032d0</span><br><span class="line">;2-&gt;0x6032e0</span><br><span class="line">;3-&gt;0x6032f0</span><br><span class="line">;4-&gt;0x603300</span><br><span class="line">;5-&gt;0x603310</span><br><span class="line">;6-&gt;0x603320</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">4011ab:	48 8b 5c 24 20       	mov    0x20(%rsp),%rbx</span><br><span class="line">4011b0:	48 8d 44 24 28       	lea    0x28(%rsp),%rax</span><br><span class="line">4011b5:	48 8d 74 24 50       	lea    0x50(%rsp),%rsi</span><br><span class="line">4011ba:	48 89 d9             	mov    %rbx,%rcx</span><br><span class="line">4011bd:	48 8b 10             	mov    (%rax),%rdx</span><br><span class="line">4011c0:	48 89 51 08          	mov    %rdx,0x8(%rcx)</span><br><span class="line">4011c4:	48 83 c0 08          	add    $0x8,%rax</span><br><span class="line">4011c8:	48 39 f0             	cmp    %rsi,%rax</span><br><span class="line">4011cb:	74 05                	je     4011d2 &lt;phase_6+0xde&gt;</span><br><span class="line">4011cd:	48 89 d1             	mov    %rdx,%rcx</span><br><span class="line">4011d0:	eb eb                	jmp    4011bd &lt;phase_6+0xc9&gt;</span><br><span class="line">4011d2:	48 c7 42 08 00 00 00 	movq   $0x0,0x8(%rdx)</span><br><span class="line">4011d9:	00 </span><br><span class="line">;这一段代码将我们刚刚存入的(rsp+20)~(rsp+48)六个数字的对应地址进行操作</span><br><span class="line">;假设(rsp+0x20)&#x3D;x,则(x+8)&#x3D;(rsp+0x28)</span><br><span class="line">;依次类推（rsp+n)&#x3D;y,则(y+8)&#x3D;(rsp+n+8)，其中0x20&lt;&#x3D;n&lt;&#x3D;0x48</span><br><span class="line"></span><br><span class="line">;而对于(rsp+0x50)而言，若(rsp+0x50)&#x3D;z,则（z+8)&#x3D;0</span><br></pre></td></tr></table></figure>

<p>文字描述:</p>
<p>栈顶的值为地址+8后寻址到的值为栈里第二个值，第二个值为地址+8后寻址到的值为栈里第三个 值，以此类推，栈里第六个值为地址+8后寻址到的是0.</p>
<p>最后这两段的代码建议自己画图跟着流程走一遍，不然容易被绕晕。</p>
<p>最后一段代码是对上面这段代码执行结果的检验。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">4011da:	bd 05 00 00 00       	mov    $0x5,%ebp</span><br><span class="line">4011df:	48 8b 43 08          	mov    0x8(%rbx),%rax</span><br><span class="line">4011e3:	8b 00                	mov    (%rax),%eax</span><br><span class="line">4011e5:	39 03                	cmp    %eax,(%rbx)</span><br><span class="line">4011e7:	7d 05                	jge    4011ee &lt;phase_6+0xfa&gt;</span><br><span class="line">4011e9:	e8 4c 02 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">4011ee:	48 8b 5b 08          	mov    0x8(%rbx),%rbx</span><br><span class="line">4011f2:	83 ed 01             	sub    $0x1,%ebp</span><br><span class="line">4011f5:	75 e8                	jne    4011df &lt;phase_6+0xeb&gt;</span><br><span class="line">4011f7:	48 83 c4 50          	add    $0x50,%rsp</span><br><span class="line">4011fb:	5b                   	pop    %rbx</span><br><span class="line">4011fc:	5d                   	pop    %rbp</span><br><span class="line">4011fd:	41 5c                	pop    %r12</span><br><span class="line">4011ff:	41 5d                	pop    %r13</span><br><span class="line">401201:	41 5e                	pop    %r14</span><br><span class="line">401203:	c3                   	retq   </span><br><span class="line">;做5次循环判断，%rbx初始存的是栈顶的值</span><br><span class="line">;对这个值+8后作为地址寻址到的值再寻址后得到的值，小于这个值自身作为地址寻址到的值，就可以跳过炸弹</span><br><span class="line">;然后对栈里5组关系都要满足才能通关。</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对最后一段汇编代码进行大致的翻译</span></span><br><span class="line"><span class="comment">//rbx初始化为&quot;栈顶的值&quot;(对(rsp+20)访存)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(*(*(rbx+<span class="number">8</span>))&gt;=*(rbx))</span><br><span class="line">        bomb();</span><br><span class="line">    rbx=*(rbx+<span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一段可以理解为输入的六个数翻转后对应的地址中的值，是按照递减顺序排列的（见下图）</p>
<p>6个地址存的值</p>
<table>
<thead>
<tr>
<th align="center">地址</th>
<th align="center">值</th>
<th align="center">翻转后的值(7-x)</th>
<th align="center">输入值(x)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x6032d0</td>
<td align="center">332</td>
<td align="center">1</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">0x6032e0</td>
<td align="center">168</td>
<td align="center">2</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">0x6032f0</td>
<td align="center">924</td>
<td align="center">3</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">0x603300</td>
<td align="center">691</td>
<td align="center">4</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">0x603310</td>
<td align="center">477</td>
<td align="center">5</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">0x603320</td>
<td align="center">443</td>
<td align="center">6</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>根据要求，我们的输入值的顺序要按照值的大小递减输入，</p>
<p>即phase_6答案为“4 3 2 1 6 5”</p>
<p>程序运行结果:</p>
<p><img src="C:\Users\25344\AppData\Roaming\Typora\typora-user-images\image-20200702003500645.png" alt="image-20200702003500645"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/16/leetcode%E5%91%A8%E8%B5%9B-6-14/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="wwow">
      <meta itemprop="description" content="努力不一定会成功，但不努力真的很舒服">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wwow's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/16/leetcode%E5%91%A8%E8%B5%9B-6-14/" class="post-title-link" itemprop="url">Leetcode周赛 6.14</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-16 17:21:01" itemprop="dateCreated datePublished" datetime="2020-06-16T17:21:01+08:00">2020-06-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-30 12:00:00" itemprop="dateModified" datetime="2020-08-30T12:00:00+08:00">2020-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="5438-制作m束花所需的最少天数"><a href="#5438-制作m束花所需的最少天数" class="headerlink" title="5438.制作m束花所需的最少天数"></a>5438.制作m束花所需的最少天数</h3><p>给你一个整数数组 bloomDay，以及两个整数 m 和 k 。</p>
<p>现需要制作 m 束花。制作花束时，需要使用花园中 <strong>相邻的k朵花</strong> 。</p>
<p>花园中有 n 朵花，第 i朵花会在 bloomDay[i] 时盛开，<strong>恰好</strong> 可以用于 <strong>一束</strong> 花中。</p>
<p>请你返回从花园中摘 m 束花需要等待的最少的天数。如果不能摘到 m 束花则返回 <strong>-1</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p>输入：bloomDay = [1,10,3,10,2], m = 3, k = 1<br>输出：3<br>解释：让我们一起观察这三天的花开过程，x 表示花开，而 _ 表示花还未开。<br>现在需要制作 3 束花，每束只需要 1 朵。<br>1 天后：[x, _, _, _, _]   // 只能制作 1 束花<br>2 天后：[x, _, _, _, x]   // 只能制作 2 束花<br>3 天后：[x, _, x, _, x]   // 可以制作 3 束花，答案为 3</p>
<p><strong>示例 2：</strong></p>
<p>输入：bloomDay = [1,10,3,10,2], m = 3, k = 2<br>输出：-1<br>解释：要制作 3 束花，每束需要 2 朵花，也就是一共需要 6 朵花。而花园中只有 5 朵花，无法满足制作要求，返回 -1 。</p>
<p><strong>示例 3：</strong></p>
<p>输入：bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3<br>输出：12<br>解释：要制作 2 束花，每束需要 3 朵。<br>花园在 7 天后和 12 天后的情况如下：<br>7 天后：[x, x, x, x, _, x, x]<br>可以用前 3 朵盛开的花制作第一束花。但不能使用后 3 朵盛开的花，因为它们不相邻。<br>12 天后：[x, x, x, x, x, x, x]<br>显然，我们可以用不同的方式制作两束花。</p>
<p><strong>示例 4：</strong></p>
<p>输入：bloomDay = [1000000000,1000000000], m = 1, k = 1<br>输出：1000000000<br>解释：需要等 1000000000 天才能采到花来制作花束</p>
<p><strong>示例 5：</strong></p>
<p>输入：bloomDay = [1,10,2,9,3,8,4,7,5,6], m = 4, k = 2<br>输出：9</p>
<p><strong>提示：</strong></p>
<ul>
<li>bloomDay.length == n</li>
<li>1&lt;=n&lt;=10^5</li>
<li>1&lt;=bloomDay[i]&lt;=10^9</li>
<li>1&lt;=m&lt;=10^6</li>
<li>1&lt;=k&lt;=n</li>
</ul>
<p>思路:</p>
<p>这题真的想了非常久，最简单的想法就是按天数递增，每天判断一次是否满足要求，但是一看数据范围就直到这么简单的暴力必然超时。</p>
<p>然后就想着能不能将bloomDay划分出m个子数组，每个数组含k个元素，最终取出这些子数组内的元素最大值，但是这个思路实现起来很困难，因为m*k&lt;bloomDay.size() （多数情况这个式子是满足的，这样的话我们很难确定划分出的这个子数组是否是正确的。</p>
<p>假设一组数据 bloomDay=[8,7,6,1,1,1,6,7,8] m=2, k=3</p>
<p>我们需要从boolmDay数组中划分出2个子数组，每个子数组含3个元素，那么要怎么划分呢？</p>
<p>直觉上来说应该先划分出[1,1,1]，因为它是最小的</p>
<p>但是这样结果就是[1,1,1]和[8,7,6] 或是[1,1,1]和[6,7,8]这两种组合，最终结果都是8</p>
<p>但这一组数据的正确划分应该是[7,6,1]和[1,1,6]，结果是7</p>
<p>从这个例子可以发现，在划分某个子数组过程中，我们难以判断本次划分是否正确，必须等到我们把全部子数组划分结束后才能得到结果，且这个结果还需要与其他划分方式进行比对，取最小值。</p>
<p>要枚举出所有划分子数组的方法是必然会超时的</p>
<p>所以绕了半天好像还是没有越过超时的坎。</p>
<p>最后我是采用二分的思路解决这题的（大概率不是最优</p>
<p>步骤如下:</p>
<p>1.对天数进行二分处理，初始时minday=1，maxday=1e9 （根据1&lt;=bloomDay[i]&lt;=10^9)</p>
<p>mid=minday+（maxday-minday）/2</p>
<p>2.在每一次二分过程中判断在mid这一天之前盛开的花是否能够满足我们的需求</p>
<p>3.如果花的数量满足需要则maxday=mid，如果不满足需要则minday=mid+1，</p>
<p>4.当minday&gt;=maxday时退出二分循环，这时minday就是我们要找的答案</p>
<p>这种做法其实也是一种暴力，只是通过二分的思路将时间消耗降低到了可接受范围之内时间复杂度，空间复杂度</p>
<p>代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;&#x2F;二分搜索</span><br><span class="line">    int minDays(vector&lt;int&gt;&amp; bloomDay, int m, int k) &#123;</span><br><span class="line">        long long sum&#x3D;m*k;</span><br><span class="line">        int len&#x3D;bloomDay.size();</span><br><span class="line">        if(sum&gt;len) return -1;   &#x2F;&#x2F;m*k&gt;len 花的数量不够</span><br><span class="line">        </span><br><span class="line">        int minday&#x3D;1,maxday&#x3D;1e9;</span><br><span class="line">        while(minday&lt;maxday)&#123;</span><br><span class="line">            int mid&#x3D;minday+(maxday-minday)&#x2F;2;</span><br><span class="line">            int ok&#x3D;false;</span><br><span class="line">            int cal&#x3D;0;</span><br><span class="line">            int tmpm&#x3D;0;</span><br><span class="line">            </span><br><span class="line">            for(int i&#x3D;0;i&lt;len;i++)&#123;  &#x2F;&#x2F;判断这一天是否满足要求</span><br><span class="line">                if(bloomDay[i]&lt;&#x3D;mid)&#123;</span><br><span class="line">                    cal++;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                    cal&#x3D;0;</span><br><span class="line">                if(cal&#x3D;&#x3D;k)&#123;</span><br><span class="line">                    tmpm++;</span><br><span class="line">                    cal&#x3D;0;</span><br><span class="line">                    if(tmpm&#x3D;&#x3D;m)&#123;   &#x2F;&#x2F;满足要求，提前退出循环</span><br><span class="line">                        ok&#x3D;true;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;   </span><br><span class="line">            </span><br><span class="line">            if(ok)</span><br><span class="line">                maxday&#x3D;mid;</span><br><span class="line">            else</span><br><span class="line">                minday&#x3D;mid+1;</span><br><span class="line">        &#125;</span><br><span class="line">        return minday;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/27/cmu15-445-%E7%BC%93%E5%86%B2%E6%B1%A0%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="wwow">
      <meta itemprop="description" content="努力不一定会成功，但不努力真的很舒服">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wwow's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/27/cmu15-445-%E7%BC%93%E5%86%B2%E6%B1%A0%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">CMU15-445学习笔记-缓冲池和内存管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-27 23:04:31" itemprop="dateCreated datePublished" datetime="2020-05-27T23:04:31+08:00">2020-05-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-30 12:04:08" itemprop="dateModified" datetime="2020-08-30T12:04:08+08:00">2020-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cmu15-445/" itemprop="url" rel="index"><span itemprop="name">cmu15-445</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Bifurcated-environment（分叉环境？）"><a href="#Bifurcated-environment（分叉环境？）" class="headerlink" title="Bifurcated environment（分叉环境？）"></a>Bifurcated environment（分叉环境？）</h3><p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/XJRL5GX_J66T7V_CE9P.png"></p>
<p>以上是目前许多公司的标准配置，它们有前端的OLTP数据库以及后端大型数据仓库，前端的OLTP数据库通常会被称为Data silo（数据孤岛，即相互<strong>独立</strong>的数据存储区），因为我们可以对其中一个数据库实例进行许多更新操作，并将其应用到此处的单个逻辑数据库中（Data silo），但这些前端数据库之间不会互相交流，它们每一个都是独立于其他数据库的一个“孤岛”。</p>
<p>从前端的OLTP数据库中得到数据后，我们会进行一种称为ETL（ETL是将业务系统的数据经过抽取，清洗转换后加载到数据仓库的过程）的操作，然后在数据仓库（OLAP数据库）中对这些数据进行分析，最后将分析得到的新信息再返回给OLTP数据库，通过OLTP数据库将这些新信息向外暴露。</p>
<p>HTAP（上节课提到的一种混合模式的workload）的理念是，让前端的OLTP数据库也能够完成一些原先在OLAP端所做的分析行为。但我们仍然需要后端的大型数据仓库（OLAP），因为前端的OLTP数据库只能根据自己所拥有的数据进行少量分析行为，且由于它们互相之间是“孤岛”，所以我们只能在后端的数据仓库中看到<strong>所有</strong>的OLTP数据库中的数据，并对它们一起进行分析。</p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>数据库无法直接在磁盘上进行操作，由于冯诺伊曼架构，我们只能对内存中的数据进行读写，所以这节课我们会学习我们如何将磁盘中的数据库文件或是page放到内存中，以便我们能够对它们进行操作。</p>
<p>我们希望能够去支持超出我们内存容量大小的数据库，同时也希望能够最小化磁盘执行查询速度缓慢带来的影响，我们希望这些操作就像在内存中进行的那样。</p>
<p>我们可以从空间和时间的管理上来思考这个问题。</p>
<h3 id="空间管理"><a href="#空间管理" class="headerlink" title="空间管理"></a>空间管理</h3><p>空间管理是指我们将数据写入在磁盘的什么地方，依照磁盘的特性，我们希望尽可能的将经常使用的page连续的存放，当我们对这些page读写的时候，由于它们的物理位置彼此靠近，我们就无须花费过多时间用于查找它们在磁盘上的位置。</p>
<h3 id="时间管理"><a href="#时间管理" class="headerlink" title="时间管理"></a>时间管理</h3><p>时间管理指我们在什么时候将page读入内存，另一方面，当这些page被修改后，我们也需要将它们写回磁盘，我们需要决定何时执行这些操作。</p>
<p>总而言之，我们希望最小化将数据库存放在磁盘给我们带来的许多负面影响。</p>
<h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/WQE5_JXZ292WJKD6A.png"></p>
<p>前面两节课我们讨论了如何在磁盘中表示数据，现在我们要讨论图中内存中的Buffer Pool这一部分。当上层请求读取page2时，我们会同过page目录找到page2，并将其送入内存。但是我们的内存容量是远小于外存的，必然会出现Buffer Pool已满，但是我们仍然需要向磁盘中读入新的page这种情况。这时我们就需要将一些在Buffer Pool中的page写出，这样就能够有空闲的空间读入新的page。</p>
<p>这就要求我们需要决定对那些page执行写出操作，这是今天这节课的重点讨论内容。</p>
<h3 id="Buffer-Pool管理器"><a href="#Buffer-Pool管理器" class="headerlink" title="Buffer Pool管理器"></a>Buffer Pool管理器</h3><p>Buffer Pool需要系统分配一块很大的内存空间，因此才能够将page从磁盘中读入。但是注意，这一块内存空间是完全由数据库系统来控制的，而不是OS。</p>
<p>我们将这块大的内存空间分成一个个固定大小的chunk，它被称为frame。我们会将从磁盘中读入的一个page放入一个frame中，我个人认为frame是内存中的页框，专门用于装入page。</p>
<p>当数据库请求得到一个page时，Buffer Pool具体做了哪些事呢？</p>
<p>首先是查看Buffer Pool中是否存在这个page，如果存在那就直接将它的指针提交给上层；如果不存在就需要到磁盘中拷贝一份数据放入内存中。这个过程中不会对数据进行任何的序列化处理，数据在磁盘中是怎样的，那么它在内存中就是怎样的。</p>
<h4 id="定位内存中的page"><a href="#定位内存中的page" class="headerlink" title="定位内存中的page"></a>定位内存中的page</h4><p>和在磁盘中遇到的一样，我们如何在内存中找到想要的page的位置呢？</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/NWWFU_B_T4QB785_P.png"></p>
<p>我们同样使用一个额外的indirection层来保存一个映射关系，即page表（注意跟磁盘中的page目录做一个区分），page表是一个hash表，通过它来跟踪内存中的page，我们可以根据page表和pageId来定位某个page存放在哪个frame中。</p>
<p>我们需要使用一些元数据来跟踪对于内存中page的操作，这里说以下Dirty Flag和Pin/Reference Counter</p>
<h4 id="Dirty-Flag"><a href="#Dirty-Flag" class="headerlink" title="Dirty Flag"></a>Dirty Flag</h4><p>前面提到，当Buffer Pool满时我们需要换出一些page来将一些内存空间空出来给新的page。那么对于在内存中没有被修改的page，我们可以直接将它丢弃，这不会影响正确性，且减少了I/O操作，提高了性能。但是对于在内存中遭到修改的page，我们必须要将它们写回磁盘中，否则就会造成数据的缺失。</p>
<p>为了确认哪些page在内存中被修改，我们使用Dirty Flag对被修改的page进行一个标记。</p>
<h4 id="Pin-Reference-Counter"><a href="#Pin-Reference-Counter" class="headerlink" title="Pin/Reference Counter"></a>Pin/Reference Counter</h4><p>这个元数据用于追踪使用该page的当前线程数量或是正在查询这个page的线程数，如果当前有线程在使用或查询该page，我们就不应该将它丢弃或是写回磁盘中，这种时候我们可以在page表中为这一项page加一个latch（锁）。</p>
<p>我们还需要额外去做一些事情来跟踪哪些page被修改了，上述两者只是其中的一部分，我们可能还需要追踪时谁修改了page。</p>
<p>上述内容可以很好的解释我们在数据库存储中说到的，为什么不适用OS（mmap）来帮我们进行内存管理？ 因为也许OS会提前将我们仍需要使用的page写出到磁盘中。</p>
<h4 id="Locks-vs-Latchs"><a href="#Locks-vs-Latchs" class="headerlink" title="Locks vs Latchs"></a>Locks vs Latchs</h4><p>为了防止混淆，我们做以下lock和latch的区分。</p>
<p>在数据库中，lock是更高级的逻辑原语，它用于保护数据库中的逻辑内容（如tuple，表，数据库），事务在运行时会持有lock，来支持并发操作同时保证操作的正确性。lock的内容是暴露给开发人员的，我们可以在运行查询时看到持有的是哪种lock。</p>
<p>latch是一种底层保护原语，它用来保护数据库内部的内容，例如保护数据结构和内存区域。在我们执行操作时会持有latch来保护某些东西，例如当我修改page表的内容时，我会在要修改的地方加一个latch，在修改后再将它释放。当我们使用latch时，不需要担心回滚操作。因为它是内部的东西，它会去更新数据库系统的物理数据结构，当我进行修改时，如果没能拿到对应的latch，那我就会终止操作，而不用担心回滚的问题。关于回滚的内容会在后续的并发控制的课上详细说明。</p>
<h4 id="page表-vs-page目录"><a href="#page表-vs-page目录" class="headerlink" title="page表 vs page目录"></a>page表 vs page目录</h4><p>同样的，来区分以下page表和page目录。</p>
<p>page目录的作用是用来找到page在磁盘上的位置。我们对page目录所作的修改都必须持久化，它们必须被写到磁盘中，即使系统崩溃了，在恢复之后我们也能知道从哪里找到我们的page。</p>
<p>page表是内存中的映射，它将pageId映射到它们在Buffer Pool中frame的位置。它是一个暂时的东西，我们无须将它持久化保存在磁盘中。</p>
<h4 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h4><p><strong>全局策略</strong>中我们所作的策略是对全局有利的，我们会查看所有运行的查询和事务，再决定某个内容是否应该存储在内存中。</p>
<p><strong>局部策略</strong>是针对单个查询或事务来说，我们尝试使用对它有利的分配方式，但这对其他查询和事务来说也许是非常不利的。</p>
<p>这两种策略没有优劣之分，根据实际情况来选择分配策略，在很多时候我们也希望对两种策略做一个折中处理。</p>
<h4 id="Buffer-Pool优化"><a href="#Buffer-Pool优化" class="headerlink" title="Buffer Pool优化"></a>Buffer Pool优化</h4><p>接下来我们详细的讨论如何优化我们的Buffer Pool，让它变得更加高效。</p>
<h5 id="1-multiple-Buffer-Pool（多缓冲池）"><a href="#1-multiple-Buffer-Pool（多缓冲池）" class="headerlink" title="1.multiple Buffer Pool（多缓冲池）"></a>1.multiple Buffer Pool（多缓冲池）</h5><p>之前的例子中，我们都把Buffer Pool作为单个实体，但事实上我们可以拥有多个Buffer Pool，我们分配不同内存区域，每一个内存区域都有自己的一套pageId与frame的映射关系。</p>
<p>我们希望使用多个Buffer Pool的原因是我们可以在每个Buffer Pool根据存储数据的不同来定制不同的局部分配策略。例如我们可以让一个Buffer Pool来处理索引，另一个Buffer Pool来处理表，它们的访问模式和策略都不相同。显然，如果我们使用一个大的Buffer Pool来替代多个Buffer Pool，我们就不可能使用不同的分配策略了。</p>
<p>另一方面，使用多个Buffer Pool可以减少试图访问Buffer Pool的多个线程间争夺同一个latch的情况发生。因为我们拥有多个page表，在同一时间内不同线程可以访问不同的page表，这样就可以减少争夺latch的情况。</p>
<p>如何确定page在哪个Buffer Pool中？</p>
<p><strong>Object Id</strong></p>
<p>第一种方法是将page的record id保存到一个列表中，然后就能够根据record id找到对应的对象在何处（保存record id和位置的一一映射关系）。</p>
<p><strong>Hashing</strong></p>
<p>第二种方法是对传入record id进行hash，并使用record id对n（Buffer Pool的数量）进行取模，这就能快速得到数据的存放位置。</p>
<h5 id="2-Pre-Fetching（预读）"><a href="#2-Pre-Fetching（预读）" class="headerlink" title="2.Pre-Fetching（预读）"></a>2.Pre-Fetching（预读）</h5><p>由于磁盘和内存处理速度的不匹配，我们希望尽可能减少从磁盘读入数据所带来的影响。举例说，对于一个要求全局遍历的查询请求之前，我们会从page0读入内存，当page0的数据全部处理完之后，再读入page1，处理page1的数据，再读取page2…</p>
<p>这种情况下，我们在解析查询请求的时候就知道了哪些page需要读入内存，也许我们能够在CPU处理数据时，让I/O去读下一个page（比如说处理机处理page0的数据时，I/O就去读page1的数据），做到处理机和I/O的并行操作，这样就能减少从磁盘读入数据带来的高额时间成本，同时降低整个查询的执行时间。</p>
<p>这个例子十分简单，实际上OS的mmap就能够做到提前读入下一个page（因为上例中的page之间本就是连续的）。</p>
<p>但是考虑一些复杂的情况，OS就不知道如何去预读page，但数据库可以。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/F89Y6Y7P57WMX8HP4YP3.png"></p>
<p>如上图，我们要读取所有value值在100~250之间的tuple，我们可以在value上添加一个索引，在索引中记录了不同value的tuple所存放的位置，我们可以通过使用以上的索引结构来找到想要的page。</p>
<p>这些page在物理上的存储位置可能是非连续的（如图中的page3和page5），但是在有了索引之后我们就能够找到它们，并且完成预读。但是在这种情况下OS就无法进行正确的预读，因为我们想要的page是非连续的，它不理解查询的上下文语义，它不会知道为什么在预读了page3之后应该预读page5而不是page4。</p>
<h5 id="3-Scan-Sharing（扫描共享）"><a href="#3-Scan-Sharing（扫描共享）" class="headerlink" title="3.Scan Sharing（扫描共享）"></a>3.Scan Sharing（扫描共享）</h5><p>首先说明以下，在某一个查询请求中，我们顺序扫描磁盘的page的时候，有一个游标，它一开始指向page0，当page0读出时它再指向page1，以此类推…..它会记录刚才扫描过的位置，这样我们在顺序扫描的时候就不用每次都从头再来。</p>
<p>对于扫描共享而言，它可以认为是不同查询请求之间互相搭顺风车，即后来的请求可以与先来的请求共享游标。</p>
<p>在扫描共享中，共享游标的查询请求不需要完全相同，只要两者都需要读取相同的page，它们就能够进行扫描共享。</p>
<p>扫描共享的大致流程为: DBMS工作后，某个查询A开始了一次扫描，过了一小段时间，查询B也开始了，查询B意识到它要扫描的page与A大致相同，这样它就可以把自己附加到查询A的游标上，当查询A拿到page时，查询B也会收到通知，所以查询B也可以去取数据。有一点需要注意的是，在B搭上顺风车之前，A可能已经读完了前面的一些page，但B现在漏读了这些page，所以最后B要从上顺风车的位置开始，逆向的扫描一开始漏掉的page。</p>
<p>我们据一个示例来具体说明：</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/RF2CJHRBE2CEXP_8PWZU.png"></p>
<p>如上图所示，一开始查询Q1开始执行，它要读取表A的全部内容，它现在读到了page3.</p>
<p>这时查询Q2出现了，它也需要读取表A的全部内容。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/NC6N1NLF7Z_FXJ@FL.png"></p>
<p>不考虑扫描共享的情况，如上图，Q2要读取page0进入内存，但事实上我们刚将page0换出内存，可以想到，这种情况会导致大量page的换入换出，导致两个查询出现争夺内存资源的情况。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/H@3JVQL0ASG4XEK4S79X.png"></p>
<p>如果我们使用了扫描共享，如上图，这时Q2就应该附加到Q1的游标上，即它也一起去读page3的数据，然后Q1和Q2能够随着Q1的游标继续读取page4，page5，这样就不会出现page不断换入换出的情况。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/CAXCBAHB9J@FYOMB4O.png"></p>
<p>当Q1,Q2读完page5时，Q1的任务结束了，但Q2还需要从它搭上顺风车的位置（即page3），再回头去读取page2，page1，page0，这样Q2才能完成任务。（如上图）</p>
<p>（Q1：在查询过程中会产生许多中间结果，如上图中Q2计算平均值就需要记录一些中间数据，这些中间数据是如何存储的？</p>
<p>A1：这些中间结果也需要存储在内存中，并且它们也是由一个<strong>单独</strong>的Buffer Pool保存的，但这个Buffer Pool是全局的还是私有的取决于具体实现方式。当这些中间结果过大导致内存溢出时，为了保存中间结果，我们也会将Buffer Pool中的page刷出到磁盘，为了保护某些page，我们会使用latch把page”固定住“，告诉管理器这个page还有用，不要将他刷回磁盘。）</p>
<p>上述Q1,Q2的例子引出了一个关于关系模型的很好的例子。假设上述Q2改为</p>
<p>SELECT AVG(val) FROM A LIMIT 100,即读出前100条tuple的val并取平均值，对于使用和不使用扫描共享的情况而言，这条语句所返回的结果也可能不同（从page0开始读100条或是从page3开始读100条），但是这样的结果是允许的，因为关系模型是无序的，我们存储的tuple之间没有明确的存放顺序（例如先放入的tuple在前面，后方的tuple在后面这类规则）。</p>
<p>所以无论我们从哪里开始读100条tuple来计算平均值，无论结果如何不同，它们都可以认为是正确的。</p>
<h5 id="Buffer-Pool-Bypass"><a href="#Buffer-Pool-Bypass" class="headerlink" title="Buffer Pool Bypass"></a>Buffer Pool Bypass</h5><p>这和刚才说到的存储中间结构的问题相关。当我们<strong>循序扫描</strong>时，需要读入大量的page，其中许多page在短时间内不会再复用，为了防止它们污染缓存，我们首先为每一个执行查询的线程分配一小块内存，当我们从磁盘中读入新的page时，不会将这些page放入buffer pool，而是将它放入线程的本地内存，当这次查询完成时，这些page全部会被丢弃。</p>
<h3 id="OS-page-cache"><a href="#OS-page-cache" class="headerlink" title="OS page cache"></a>OS page cache</h3><p>OS page cache介于磁盘和操作系统之间。</p>
<p>我们对于磁盘的操作都是基于OS给我们提供的API（fwrite，fread）进行的，但另一方面OS也会维护自己的文件系统缓存。当数据库从磁盘中读取一个page时，OS也会在它的文件系统缓存中同样保存一份。显然这样做会浪费许多内存空间，大多数数据库系统不希望OS缓存这些page，所以它们通过direct I/O来做，不让文件系统对该数据进行缓存，又数据库自己来管理其中的内容。</p>
<p>OS page cache虽然会对每一个page多保存一个副本，但是当数据库将某个page做修改后，OS并不会对它保存的page做相应的修改。这样一来，OS保存的那一份page就不能称之为副本了（因为它没有与数据库中的那一份保持一致），它可以被认为是冗余的旧数据。这也是多数数据库系统不适用OS page cache的原因。</p>
<p>虽然大多数系统不希望这么做，但还是有少量数据库使用了OS page cache，例如postgreSQL。它们这么做可能是通过使用OS提供的服务来降低开发和维护的复杂度。</p>
<h4 id="Buffer替换策略"><a href="#Buffer替换策略" class="headerlink" title="Buffer替换策略"></a>Buffer替换策略</h4><p>我们之前已经介绍过Buffer Pool的基本工作流程，现在我们要讨论在我想要读取一个page进入磁盘时，Buffer Pool的内存空间却满了的情况下，我们该怎么做。</p>
<p>对于Buffer替换策略，我们使用以下几点来评价它们的优劣。</p>
<p><strong>正确性</strong>，当某个内存中的page还未使用完时，它不应该被替换或移除出去。</p>
<p><strong>准确性</strong>，要确保我们替换出去的都是在短时间内不会用到的page。</p>
<p><strong>速度</strong>，替换策略需要迅速，因为我们会使用latch来锁定某些page，我们不希望替换策略花费许多时间来找到能够被替换出的page。</p>
<p><strong>元数据</strong>，我们不希望为了替换策略而维护追踪大量的元数据，不希望保存元数据花费的page甚至大于保存真实数据的page。</p>
<h5 id="LRU（最近最少使用）"><a href="#LRU（最近最少使用）" class="headerlink" title="LRU（最近最少使用）"></a>LRU（最近最少使用）</h5><p>在这个算法中，我们需要跟踪一个page最后一次被访问时的时间戳，每次我们都替换或移除时间戳最老的page。</p>
<p>我们可以维护一个数据结构（例如queue），它将page根据时间戳排序，每当某个page被读或写时，就将它从队列中拉出来，再放到队尾。每次需要换出page时，就将队首的page换出内存。</p>
<h5 id="CLOCK"><a href="#CLOCK" class="headerlink" title="CLOCK"></a>CLOCK</h5><p>这是一种LRU的近似算法，在CLOCK中，我们不去跟踪page最后一次访问的时间戳，我们需要去追踪的信息是每个page的标志位（reference bit），它表示自从上次检查该page后，这个page是否被访问。</p>
<p>我们将page组织成一个环形的buffer（就像钟一样），使用一个能够旋转的指针不断的移动去检查每个page的标志位是0还是1，如果是0就说明从上一次检查它之后，这个page没有再被某个线程访问，因此我们可以将它从buffer中移除。如果是1，说明上一次检查之后它被某个或某些线程访问了，我们将标志位改为0，继续检查下一个page。</p>
<p>对于某个page而言，无论它在某个时间段内被多少个线程访问，它的标志位都是置1，而不会因为访问次数增多而累加（不会变成2，3，4，5…）</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/7NWX00KUYA1QYNO2V.png"></p>
<p>上图中，我们执行CLOCK算法找出要被替换的page，首先是page1，它的ref标志位为1，我们将其改为0，并将指针移到page2检查。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/IZQB2XL373VQSVK9BGC.png"></p>
<p>发现page2的ref标志位为0，就将page2置换出去。</p>
<p>再举一个例子。假设这时page1，2，3，4的ref标志位都为1，那么在指针检查完所有page一遍后，所有page的ref全都变为0，这时指针再次回到page1，发现page1的ref位为0，所以将page1置换出去。</p>
<p>在CLOCK算法中，实际置换出的不一定是<strong>最久未被访问</strong>的page，我们只关注一段时间内未被访问的page，而当有多个page在一段时间内都未被访问时，我们不需精确的找到最久未被访问的那个，只要从中抽出一个page，并将它置换出去就行。</p>
<h5 id="LRU和CLOCK存在的问题"><a href="#LRU和CLOCK存在的问题" class="headerlink" title="LRU和CLOCK存在的问题"></a>LRU和CLOCK存在的问题</h5><p>在简单的情况下，例如进行点查询（point query）时访问单个数据（例如page），它们的效果都挺好。但是它们都容易受到sequential flooding的影响，sequential flooding即我们的查询请求需要读取<strong>每个</strong>page，这可能会污染我们的page缓存。因为它读取了一堆page，且所有这些page都比我最近缓存的page的时间戳更新，这时LRU或CLOCK算法会将最近使用的page换出，但事实上这个最近使用的page也许是我们之后需要用到的，而真正应该被换出的应该是较新的这些page。</p>
<p>为了应对这种情况，我们可以选择三种改进的策略。</p>
<h5 id="LUR-K"><a href="#LUR-K" class="headerlink" title="LUR-K"></a>LUR-K</h5><p>为了解决算法污染问题，LRU-K将“最近使用过1次”的判断标准扩展为“最近使用过K次”。</p>
<p>相比于LRU，LRU-K算法中的K表示对每个缓存在内存中的page的访问次数进行计数，我们会多维护一个历史队列，来记录所有缓存page的访问历史。当page的访问次数达到K次后才将其放入缓存。当需要置换数据时，LRU-K会淘汰第K次访问时间据现在时间最长的page。</p>
<p>这种方法通过历史数据的访问时间间隔来预测未来的数据访问规律。</p>
<p>对于较为复杂的数据库系统来说，它们会采用LRU-K的做法。</p>
<h5 id="Localization"><a href="#Localization" class="headerlink" title="Localization"></a>Localization</h5><p>这种方法是使用多个buffer pool让查询请求本地化，我们在之前讨论过相关的做法。我们将本次查询所涉及到的page单独放到某一块buffer中，其他查询请求也能读取到它们，但是在我们要替换出page时，我们只会选择在<strong>当前查询请求下访问最少</strong>的page做置换，而不是从全局的角度看谁被访问的次数最少。</p>
<p>即我们不关心其他查询请求访问了这个page多少次，只要在本次查询请求中它的被访问次数是最少的，那么它就应该被置换出去。</p>
<h5 id="Priority-Hints"><a href="#Priority-Hints" class="headerlink" title="Priority Hints"></a>Priority Hints</h5><p>我们可以提供一些暗示给buffer Pool来提醒它哪些page是重要的，而哪些page是不重要的。</p>
<p>这似乎比较抽象，我们给出一个例子来说明。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/83VN5HZPPNDV796RAQBQ.png"></p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/ZU0HW7EIYOVCWJ4W7WG.png"></p>
<p>对于Q2来说，我们需要从表A中得到id为特定值的tuple。</p>
<p>当我们使用索引（例如B+树结构），我们在每一次查询时都需要从根节点进入，然后一直向下直到叶节点。假设我们在将叶节点读入内存时，我们的buffer Pool已经满了，这时就需要选择一个内存中的page置换出去，根据最近最少使用的原则，index—page0（也就是根节点）会被置换出去。但是我们知道，当下一次再次出现查询请求时，我们仍然需要使用索引结构，仍然需要从根节点开始查找数据，那么根节点立刻会被再次读入内存。</p>
<p>我们的priority hint就是在这种情况下，一定不会选择根节点置换出内存，而是选择中间的非叶节点置换出去（即便最近最少原则指向的是根节点）。在特定的环境下，让数据库理解上下文信息，这样它就能够根据这些“hint”来更好的执行置换算法。</p>
<h4 id="Dirty-page（脏页）"><a href="#Dirty-page（脏页）" class="headerlink" title="Dirty page（脏页）"></a>Dirty page（脏页）</h4><p>在每一个page上会有一个dirty bit，它会告诉我们自从它进入buffer pool后，是否有查询对该page的内容进行了修改。</p>
<p>当我们执行替换策略时，最好的方法当然是找到一个未被标记为dirty的page，然后将它直接移除，再将新读入的page放到这个frame中。假设我们要换出一个dirty page，在将新的page读入内存之前，我们需要将这个dirty page安全的写回磁盘中。</p>
<p>这时我们就需要在替换策略上做一个取舍，在dirty page的基础上，我们会更希望找到未被标记为dirty的page，然后直接移除它来空出内存空间，但这些未被标记为dirty的page可能在短时间内会被再次用到，这种情况下也许我会考虑多花一些代价选择一个dirty page置换出去（保留非dirty page）</p>
<p>这种情况下的取舍是十分困难的，在不同的情景下不同的选择的代价也不同，没有一个绝对的结论告诉我们如何选择。</p>
<h4 id="Background-Writing（后台写入）"><a href="#Background-Writing（后台写入）" class="headerlink" title="Background Writing（后台写入）"></a>Background Writing（后台写入）</h4><p>要解决Dirty page下页面置换的两难问题，即为了避免<strong>必须立即</strong>将page写出以便在buffer pool释放可用空间的问题，我们可以使用后台写操作。</p>
<p>我们在数据库系统中创建一个执行定时任务的线程，每隔一段时间它会去buffer pool中找出dirty page，然后将其写出到磁盘上（但是page仍然保留在buffer pool中，只是将修改数据更新到磁盘），这样dirty page就变成clean的了。当我们执行替换策略时，我们就有更多clean page可以直接移除而不用写回磁盘。 不过在这个过程中要注意，在修改的内容尚未写入到日志之前，我们不希望将dirty page写回磁盘。</p>
<p>这样做的重点在于，我们可以使用在平时闲置的I/O资源来将dirty page写回磁盘，而不是只有在需要被置换时才写回磁盘。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这节课的重点在于我们要如何去管理内存并做的比OS更好，因为我们知道查询的语义，我们知道page中的内容，我们知道这些数据如何被访问，我们可以使用更多的优化来提高性能和效率。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/20/cmu15-445-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8part2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="wwow">
      <meta itemprop="description" content="努力不一定会成功，但不努力真的很舒服">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wwow's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/20/cmu15-445-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8part2/" class="post-title-link" itemprop="url">CMU15-445学习笔记-数据库存储part2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-20 18:01:10" itemprop="dateCreated datePublished" datetime="2020-05-20T18:01:10+08:00">2020-05-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-30 12:03:24" itemprop="dateModified" datetime="2020-08-30T12:03:24+08:00">2020-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cmu15-445/" itemprop="url" rel="index"><span itemprop="name">cmu15-445</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="面向磁盘型数据库系统"><a href="#面向磁盘型数据库系统" class="headerlink" title="面向磁盘型数据库系统"></a>面向磁盘型数据库系统</h2><h3 id="page布局"><a href="#page布局" class="headerlink" title="page布局"></a>page布局</h3><h4 id="log-structured"><a href="#log-structured" class="headerlink" title="log-structured"></a>log-structured</h4><p>上节课我们在讲到page布局时说到了<strong>tuple-oriented</strong>的方式，使用slotted page的方法将每一个tuple对应的偏移量保存在slot中，这样就能在定位到tuple在page内部的位置。这节课将会补充说明另外一种<strong>log-structured</strong>方法。</p>
<p>这种组织方式不是将所有tuple存放在page内，而是去存储这些与创建tuple，修改tuple相关的日志信息。在page内部，我们不断的追加日志信息，并且这些信息是以文本形式存储的。当我们对tuple执行某项操作（insert xxx,update xxx等)，我们只需要将这个操作记录为一个日志条目并且追加到page的尾部就行。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/A1RC090MJI4LMOEA@U.png"></p>
<p>log-structured的页存储方式</p>
<p>这样做的一大好处就是操作起来更快，对于磁盘来说，循序访问的速度要快于随机访问。如果我们使用<strong>slotted pages</strong>方式组织page，假设当前我要去更新10个tuple，它们在不同page上，那我就需要在10个page上来写入并更新这些tuple。但如果我使用log-structured的方式，那么我就能够将10条更新语句写在单个page上，一次就能搞定。</p>
<p>这项技术在HDFS和S3之类的分布式文件系统中只支持这种追加的page组织方式。</p>
<p>但这种方式的一大缺陷就是读取十分麻烦，当我们要读取一条tuple时，我们就需要从page的最后一条日志反向查找，看看有关这条tuple的日志中记录的最终值是多少。当我们对tuple进行批量操作的时候，这个弊端就更加显著。</p>
<p>我们可以使用几种方式来加速的过程，我们可以建立索引，记录不同tuple对应日志的偏移量，读取时我们跳到特定的偏移量处就能读出我想要的数据。</p>
<p>我们也可以周期性的压缩日志。即重新把日志从头走一遍，这样一来我们就能知道当前情况下各个tuple的值是多少，我们可以把之前的日志全部删除，只保留tuple当前的值。（如下图所示）这也能解决日志无限增长占用大量空间的问题。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/LL5CTSZNWS8QUP7F0C9.png"></p>
<p>虽然我们介绍了log-structured的方法，但是本课程中我们假设我们面对的是slotted page型数据库。</p>
<h3 id="使用tuple表示数据"><a href="#使用tuple表示数据" class="headerlink" title="使用tuple表示数据"></a>使用tuple表示数据</h3><p>前面我们讲到了数据库是由一系列page组成的，讨论到了如何将heap文件拆分为page，接着说到了page内部的slot数组。现在我们想知道在tuple内，我们如何去表示不同属性或列的数据。</p>
<p>在高级层面而言tuple只是一串字节序列，而数据库管理系统需要去解释它的意思，弄清楚它的类型。这节课上，我们需要把这些字节数组组织成tuple，然后当数据库执行查询时，我们要去解释这些字节数组中的实际内容，以此来生成我们所寻找的答案。</p>
<p>在大部分数据库中，例如对于<strong>固定长度</strong>的类型（integer，bigint，smallint，float/real），我们使用的表达方式与C和C++相同（遵循IEEE-754标准），对于不定长类型我们的表达方式则有所不同。</p>
<p>基本上讲，float/real属于浮点数，numeric/decimal属于定点数，定点数的表达方式需要我们在数据库中自行实现。</p>
<p>对于可变长度类型（varchar，text，blob等），它们一般有一个头部，它会保存数据的长度，在头部后面跟着真实数据的字节序列。与C中的字符串不同，C是在结束位置提供一个‘/0’作为终结符，但这里我们使用一个前缀来指明数据的大小。</p>
<p>对于time/date/timestamp类型，大多数数据库会保存从1970年1月1日起的秒数或毫秒数甚至微秒数来处理时间。</p>
<h4 id="浮点数（float-real）和定点数（decimal-numeric）对比"><a href="#浮点数（float-real）和定点数（decimal-numeric）对比" class="headerlink" title="浮点数（float/real）和定点数（decimal/numeric）对比"></a>浮点数（float/real）和定点数（decimal/numeric）对比</h4><p>对于float，real/double这些可变精度类型，它们是CPU或C++提供给我们的<strong>不精确</strong>数字。</p>
<p>浮点数执行操作的速度要比定点数快得多，因为CPU有能够高效处理浮点数操作的指令，一条CPU指令就能对两个浮点数进行相加或想相。但处理定点数时，我们需要写一大堆东西对它们进行处理，这意味着对于定点数的操作，需要执行更多的指令。</p>
<p>从效率角度而言，我们似乎更应该使用浮点数，但是这也存在一个问题，浮点数存在舍入误差，这在很多情况可能导致严重的问题（航天工程，金融系统等）。</p>
<p>#include&lt;stdio.h&gt;<br>int main(){<br>    double a=0.1;<br>    double b=0.2;<br>    double c=0.3;<br>    if(a+b==c)<br>        printf(“true”);<br>    return 0;<br>}</p>
<p>执行上述代码，我们可以发现并不会输出“true”，为什么0.1+0.2≠0.3？这就是因为double存在舍入误差，在IEEE-754标准中无法精确的表示浮点数。</p>
<p>为了避免不准确的数据造成错误，我们选择使用定点数。这也是我们要在数据库中自行实现的内容。</p>
<p>（Andy在课堂上对于real和decimal类型的数据处理做了上机演示，结论是decimal类型的数据处理时间比real慢了一倍，但real的计算结果会存在精度问题。）</p>
<p>下面我们看一看PostgreSQL中numeric类型的结构（由于PostgreSQL是开源而其他两个数据库是闭源的，所以举它的例子）。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/74VPNL9FMFJDGJQX22.png"></p>
<p>PostgreSQL中numeric类型的结构</p>
<p>可以看到，表示numeric类型具体数值的部分其实是使用unsigned char来存储的，所以对于numeric数据类型而言它们需要自行编写对应的数据处理函数，这也导致了numeric类型的数据处理效率较差（float，double这些浮点数的数据处理有对应的CPU指令）</p>
<h3 id="存储一个过大的数据"><a href="#存储一个过大的数据" class="headerlink" title="存储一个过大的数据"></a>存储一个过大的数据</h3><h5 id="overflow-page"><a href="#overflow-page" class="headerlink" title="overflow page"></a>overflow page</h5><p>我们会遇到一些情况导致我们要存储的数据无法保存在单个page下，我们使用overflow page来解决这个情况。</p>
<p>下面这个例子中，该tuple的属性c由于过大无法与其他属性放在同一个page中。所以我们通过保存一个指针在属性c处，通过这个指针来指向保存了真实数据的overflow page。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/FS6JFPWQMJ64PFZ5Q5BE.png"></p>
<p>overflow page</p>
<p>当一个查询请求属性c作为输出的一部分时，就根据这个指针，找到对应的page，并将它拷贝下来，并生成一个输出结果。</p>
<p>同样的，如果属性c的数据大到无法在一个page中存放，那么就从属性c中继续拆分一些数据，存放在另外的overflow page，并在当前overflow page中存储到对应page的指针。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/ROPOTIGFQVK5O61RP0Y.png"></p>
<p>多级的overflow page</p>
<p>对于overflow page中的数据，依然应该具备常规数据应有的保护措施，但是我们难以通过常规手段对overflow page进行操作，所以需要针对overflow page进行各种各样的优化。在PostgreSQL中，大部分时候这些overflow page都是只读的，很少在上面写入东西，这样可以尽可能的降低维护overflow page的复杂度。</p>
<h5 id="外部存储"><a href="#外部存储" class="headerlink" title="外部存储"></a>外部存储</h5><p>除了将过大的数据存储在overflow page，我们还可以使用外部存储来存放数据。</p>
<p>其基本思路就是我们不将属性的数据保存在tuple内部，而是保存一个指针或是文件路径，它们指向了存储数据的本地磁盘，网络存储或是某些外部设备。</p>
<p>一般情况下，我们只能读取存放在外部存储的数据，而不能操作它。但是如果有人在数据库系统之外对该文件进行了修改，那么我们应该能够发现其中的变化，因为外部存储实际上超出了我们数据库系统的控制范围和保护范围。</p>
<p>什么情况下我们会使用外部存储？对于一些视频网站而言，它们需要保存使用者上传的视频文件，这些视频文件大多超过1G，我们不可能把这些视频文件全部放入数据库中，因为这会占用非常庞大的空间，且代价极高。所以我们可以将这些视频文件存储到更便宜的外部设备上，以此来降低成本。</p>
<p>那么我们来说什么时候使用overflow page，什么时候使用外部存储呢？</p>
<p>在2000年左右的时候，任何小于256KB的数据，我们会将它保存在一个overflow page中；任何大于256KB中，我们会将它保存在外部存储上。但是这都不是硬性要求，这只是经过性能和经济方面的考量后，所得到的结果。</p>
<h3 id="system-catalog"><a href="#system-catalog" class="headerlink" title="system catalog"></a>system catalog</h3><p>system catalog中保存了数据库相关信息的元数据，包括表名，索引以及用户权限等等。多数数据库系统会将它们的catalog使用一张表来存储。</p>
<p>同时，数据库系统也会提供某种底层的方法来访问catalog，在早期，不同的数据库系统都有它们自己的catalog和对应不同的访问方式，这对于用户而言十分不友好，当应用程序从一个数据库系统迁移到另一个数据库系统时，我们需要根据新的数据库系统的catalog来重写相关的代码。</p>
<p>为了解决这些catalog多样化带来的问题，ANSI标准以及SQL标准定义了一种称为INFORMATION_SCHEME的catalog接口，每个数据库系统都需要支持它。但不同的数据库也额外使用了不同的快捷方式来得到这些数据。下图就是不同数据库中查看catalog的方式。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/3YPWWCCMT__TLDS9FJE.png"></p>
<p>我们可以使用这些命令看一看catalog具体是怎样的（只列出postgreSQL的情况，其他数据库可以自行尝试）</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/14SWR3PFWQXPZ5H50NAG.png"></p>
<p>使用/d得到所有表的列表</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/DB6OZH9J2H0VRZBWO7.png"></p>
<p>使用/d+得到更多的信息</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/OYDFSCHSBF_A6U5V_BC.png"></p>
<p>对某张表是用\d+ &lt;db_name&gt;得到这张表的scheme</p>
<p>我们可以根据catalog中所展现的表的scheme去解析存储在数据库中的tuple，之前提到对于存储层而言，我们的tuple只是一串字符序列，它没有任何意义，但数据库有义务对这一串字符序列进行解释。如图中的例子，通过scheme，我们可以知道这个tuple的第一个属性是integer，它占了32位空间，第二个属性也是integer，它也占了32位空间，这样我们就能够来划分字符序列，并将它解释为一个有意义的tuple。</p>
<p>通过关注数据库的catalog，我们可以跟踪查看我们的scheme，当我们去查询以及构建索引时，会使用到它，并决定我们如何去做。通过scheme，我们可以了解数据的布局，从而将一条字符序列解释为tuple，但是注意，如果我们需要对每一条tuple都分析数据布局，这实际上会很慢，因为重复了大量冗余的操作（同一个表下的tuple数据布局都是一样的），在高级的系统中，可以在运行时进行编译或是代码生成来减少重复的解释操作（例如通过JVM中的JIT(Just-in-time）编译来对这些操作进行编译）。</p>
<h3 id="存储模型"><a href="#存储模型" class="headerlink" title="存储模型"></a>存储模型</h3><p>在第一节课上提到了关系模型（Ted Codd的论文）但它并没有说明我们该如何去存储数据（字节数组，类型等内容），它甚至没有说明我们需要将tuple的所有属性保存在内存或磁盘中。到目前为止，我们在课堂上可视化数据库时，我们都是使用行来表示某个tuple的所有属性，但对于某些workload来说，这不是最好的处理方式。</p>
<h4 id="workload"><a href="#workload" class="headerlink" title="workload"></a>workload</h4><p>在本门课的数据库系统中，我们所关心的workload有两种，<strong>OLTP</strong>和<strong>OLAP</strong>。</p>
<h5 id="OLTP（On-line-Transaction-Processing）"><a href="#OLTP（On-line-Transaction-Processing）" class="headerlink" title="OLTP（On-line Transaction Processing）"></a>OLTP（On-line Transaction Processing）</h5><p>OLTP被称为联机事务处理，当我们构建一个新的应用程序时就会遇到它（website，app等）。OLTP的思路是我们从外界取得新的数据后，将它们放入我们的数据库，这些操作非常简单，它们一般只涉及小部分数据的更新或读取。</p>
<p>举例来说，对于电商平台，当我在网站上购买东西的时候，就是对应用程序的OLTP（即联机事务处理），因为我会向我的购物车里添加商品，然后结账，最后更新我的账户信息。由于电商平台总会有很多人浏览并购买东西，所以它会处理大量的这种操作。但从一名顾客的角度而言，我不会更新太多数据，我更新的是我的账户信息，我的购物车信息，这些查询和更新只会访问数据库中很小的一部分信息（只访问属于我的那一小撮信息）。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/0_TOTHQYU6B6BDL_4U.png"></p>
<p>上图是wikipedia内部的例子，我们有三张表，在revision表中，我们保存的是每篇文章的更新记录，在pages表中有一个对revision的外键引用，表示这是该page的最新版本，使用者可以无须扫描，直接跳转到此处取数据。然后我们对这些表执行OLTP操作。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/TABJOLPNBG_VVPNNXC.png"></p>
<p>第一个SQL语句可以拿到page当前的revision，第二个SQL语句表示使用者在登陆账号时更新他的账号登陆信息。这些操作都只会访问小部分的tuple。在OLTP中我们会不断重复做这类事情。</p>
<h5 id="OLAP（On-line-Analytical-Processing"><a href="#OLAP（On-line-Analytical-Processing" class="headerlink" title="OLAP（On-line Analytical Processing)"></a>OLAP（On-line Analytical Processing)</h5><p>OLAP被称为联机分析处理，当我们从OLTP应用程序中收集到一大堆数据时，我们会想去分析它，并从中得到新的信息，这也被称为数据科学，即从已有的数据中派生处新的信息。</p>
<p>在这种情况下，我们不会去更新数据，它所要做的就是从已有的信息中为我们分析提供新的信息，我们会试着让这些信息变得有意义。</p>
<p>我们还是以上述的wikipedia为例子。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/LOCXWKSDB4PESV7PCX0.png"></p>
<p>这条SQL语句会去统计每个月里，主机名以.gov结尾的用户登陆数量。这种类型的查询就是只读的，它会去读取大量数据，例如扫描整张表。在OLTP（联机事务处理）中，我只会去更新一个东西，但是对于OLAP（联机分析处理）来说，我要去做大量的join，并读取大量的数据。</p>
<h5 id="OLTP与OLAP的对比"><a href="#OLTP与OLAP的对比" class="headerlink" title="OLTP与OLAP的对比"></a>OLTP与OLAP的对比</h5><p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/G6W_S2VGOO@GURKGHTKP.png"></p>
<p>上图可以粗略的表达不同workload的操作复杂度，可以看到，OLTP擅长简单的查询，但会做大量的写入操作；OLAP会做大量的读操作，并且它更复杂。图中我们还能看到一种新的workload，它被称为混合事务分析处理（HTAP），它试着将OLTP和OLAP混合在一起，既想要提取数据，又想在拿到数据时对它进行分析。</p>
<p>（Q1：OLAP和NoSQL或NewSQL系统间的关系是什么？（课堂内容）</p>
<p>A1：图上的这些（OLAP,OLTP,HTAP）是workload的类型，而NoSQL和NewSQL是DBMS系统类型。对于传统的NoSQL系统，MongoDB，Cassandra以及Redis来说，它们属于靠近OLTP那块，我们主要往它们塞入新数据。</p>
<p>NoSQL大约在2000年末时出现，许多公司为此投入大量资金，例如google，它们推出了HBase，BigTable和Hadoop，这些系统不去执行SQL，也不进行事务处理，更不会进行join操作，这就是它们能够扩展的原因。Hadoop具有在线分析处理的能力（OLAP），但像BigTable，Cassandra，MongoDB以及其他一些NoSQL数据库具备的则是OLTP联机事务处理的能力。</p>
<p>然后人们开始意识到他们想要处理事务的能力，想要SQL，也想去进行某些join操作，因此，NewSQL应运而生。他们想要实现的想法是，在不放弃事务的前提下，拥有快速处理事务的能力和OLTP。</p>
<p>)</p>
<h4 id="n-ary存储模型（行存储模型）"><a href="#n-ary存储模型（行存储模型）" class="headerlink" title="n-ary存储模型（行存储模型）"></a>n-ary存储模型（行存储模型）</h4><p>我们再次回到存储模型的主题上来，目前我们展示tuple时，我们总是以行的方式展现它。这被称<strong>n-ary存储模型</strong>，它的基本思路是将单个tuple的所有属性，连续的存储在同一个page中，对于体积较大的数据我们也可以使用overflow page，但基本思路都是一样的。</p>
<p>这是关于OLTP的一个想法，因为我们每次去访问的数据量在粒度上足够小（只访问少量tuple的全部属性），这样就能够访问单个实体，并拿到我的账户信息，我的订单信息，以及有关我账号的全部信息。我不需要关心其他几百万用户的信息，我只需要我自己的账号信息。如果它使用一行数据将我的账户信息连续存储，那么我的访问操作就非常的高效（相比column存储），我们只需要跳转到对应的page，并取到我想要的数据就结束了。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/BO0O2JTCANVOAO90.png"></p>
<p>上图是使用n-ary存储模型时，我们执行SQL查询时的流程。通过该SQL语句我想要根据用户名和账号拿到账号信息，我们可以通过索引来查找（后续介绍），得到tuple所在的page id和slot number，然后我们通过一次查找和读取，将page放入内存中，并跳转到对应偏移量得到我想要的数据。对于插入操作也是类似，只需要找到一个空的slot，并将数据一次性写入就行。</p>
<p>在这类请求下，将一个tuple的所有数据连续存储是读取数据时最高效的方式。</p>
<p>那么在什么情况下，行存储是低效的呢？</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/E2R4NIZQ2@N_MVBGVU.png"></p>
<p>回头看看这条SQL语句（上面OLAP处提到过它的内容）。当我们执行这条SQL语句时，我们实际上要对整个用户账号表进行扫描，根据hostname来找到以.gov结尾的账号。</p>
<p>简单来说，我们只需要hostname和LastLogin这两个属性，就能够得到最终结果。由于行存储模式下，我们将一条tuple的全部属性连续存储在一起，且在非易失型存储设备中，我们每次读入读出都以page为单位，这两条限制导致我们可能会将其他不需要的属性一起读入内存（userId，userName，userPass）。可以看到我们读入了五个属性，但其中包含了三个没用的属性，当我们的数据量达到PB级别的话，这是非常低效的</p>
<p>总结一下行存储模型，在n-ary存储模型中（行存储模型），当我们访问<strong>整个tuple</strong>的时候，即插入，更新以及删除tuple时的速度很快。但如果我们要进行一些分析型的查询以及做些OLAP工作并且想要扫描整张表的大部分内容时，n-ary存储模型就十分废柴了，因为我们会向内存中读入一大堆我们不需要的数据。</p>
<p>为了解决n-ary存储模型所不能应对的情况，出现了column存储模型。</p>
<h4 id="column存储模型（列存储模型）"><a href="#column存储模型（列存储模型）" class="headerlink" title="column存储模型（列存储模型）"></a>column存储模型（列存储模型）</h4><p>在列存储模型中，我们不会将单个tuple的全部属性放在单个page上，而是将所有tuple的某个属性放在同一个page中，即将单个列的所有值连续保存在一起。这对于OLAP而言十分友好，我们可以读取表的部分属性集合，而不是像行存储模型一样将全部属性读出。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/QEYKSEYUL736A_STI7N5B.png"></p>
<p>回到上一个例子，这一次我们使用列存储模型。这一次我们只需将保存hostname的page放入内存中，并对每个hostname进行扫描匹配，这样我们就得到了能够匹配的tuple，接着把存储lastLogin的page读入内存，找到对应的lastLogin的值，最终生成输出结果。</p>
<p>可以看到这一次我们只需要读取2个page（存储hostname和lastLogin的page），就能够生成输出结果，而行存储则需要读取全部page，考虑在极端情况下，如果我有上亿个page，行存储模式的优越性就很明显。</p>
<h5 id="压缩数据"><a href="#压缩数据" class="headerlink" title="压缩数据"></a>压缩数据</h5><p>同时，列存储还有一个优点就是可压缩。对于行存储模型而言，不同属性对应的数据类型不同，在存储时，这些不同类型的数据被连续的存放在一起，显得十分散乱，我们难以直接分辨它们，所以对于行存储的压缩是较为困难的。</p>
<p>但对于列存储模型来说，一个page只会存放同一个属性的值，这些数据的类型显然是相同的，并且其中某些数据的值可能是相同的，那么我们就能够对它们进行压缩。</p>
<p>举例来说，我们要存储室内不同时间的温度，现在室内的温度是36度，一小时之后温度是36.1度，两小时后是36.2度，这些温度没有太多波动，我们无需完整的保存每次的温度数据，只需要将第一次记录的温度作为标准，然后记录每次新的温度和标准之间的差值即可，这样我们就能够保存较小的值。</p>
<p>对于原先只能存放1000个tuple的page，也许在进行了压缩之后，能够存放10000个数据。并且某些系统可以在未解压的情况下直接对数据进行操作，这就很美妙了…</p>
<h5 id="定位tuple的属性"><a href="#定位tuple的属性" class="headerlink" title="定位tuple的属性"></a>定位tuple的属性</h5><p>在列存储模式中，是否会将主键和每一个属性一起保存，即如何弄清某个hostname一开始是在哪一条tuple中？</p>
<p>我们有两种方法做这件事。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/NZRLABY__QWY50VNKC@T9E.png"></p>
<p><strong>Fixed-length Offsets</strong></p>
<p>第一种方案使用固定长度的偏移量，也就是说对于一列中的每个值而言，它的长度是固定的。</p>
<p>如上图，如果我们知道pageA中的一个属性x的偏移量d，该如何定位pageB中与x同属于一个tuple的属性y的偏移量D呢？</p>
<p>由于所有属性都是定长的，假设pageA中单个属性的长度为32位，而pageB中单个属性的类型为8位，那么我们首先确定x在A中的rowId（或者叫slot number，怎么命名取决于自己，但是不要和之前讲的那些弄混了）</p>
<p>rowId=d/32</p>
<p>然后就可以得到y在pageB中的偏移量D=indexA*8</p>
<p>经过很简单的计算就能够得到数据的位置。</p>
<p>但是如果遇上可变长类型怎么办？</p>
<p>我们可以将它压缩成一个定长的数据或是对可变长数据进行填充，让他的长度变成我们所允许的最大长度。</p>
<p>对于大多数系统而言，它们都使用Fixed-length Offsets的方法来定位tuple的属性。</p>
<p><strong>Embedded tuple id</strong></p>
<p>该方法中，我们为列中的每一个值都保存一个主键或是标识符，通过这个主键或是标识符来定位tuple的属性（上图右侧示例）</p>
<p>但这种方法是很糟糕的，因为我们要为每一个值额外花费32位或是64位的空间来保存它们的标识符，这是十分浪费的，所以大多数系统不使用这种方法。</p>
<p>总结一下列存储模型，对于列存储模型而言，它的优点是当我们进行OLAP查询时，可以显著降低无用I/O操作的数量，它不会读取我们不需要的page，借此提高系统的性能，并且它能够更好的支持压缩。但它的缺点也十分显著，由于我们将一个tuple的所有属性分开存储，当我们要读取或更新一条tuple时，就需要读取多个page，并将这些page中的属性拼接起来。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们明白了，数据库的存储管理不应该完全独立于DBMS的其他部分，即对于DBMS的其他部分而言，存储管理不应该是个黑盒。当我们的数据库知道它要做什么，数据看起来是怎样的，它就能够更好的做出判断以及设计选择，并更加高效的执行查询操作。</p>
<p>另一方面，我们了解了OLTP和OLAP，在OLTP中，我们使用行存储，在OLAP中，我们使用列存储，简单的规则能够让我们的职业生涯更加轻松。</p>
<p>这两节课中，我们讨论了DBMS如何在磁盘上表示文件，下节课我们会讨论如何将数据放入内存，并对它们进行管理。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/14/cmu15-445-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8part1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="wwow">
      <meta itemprop="description" content="努力不一定会成功，但不努力真的很舒服">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wwow's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/14/cmu15-445-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8part1/" class="post-title-link" itemprop="url">CMU15-445学习笔记-数据库存储part1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-14 23:33:41" itemprop="dateCreated datePublished" datetime="2020-05-14T23:33:41+08:00">2020-05-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-30 12:03:57" itemprop="dateModified" datetime="2020-08-30T12:03:57+08:00">2020-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cmu15-445/" itemprop="url" rel="index"><span itemprop="name">cmu15-445</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>第一节课中我们学到了从使用者的角度如何看待数据库，也学会了如何编写sql语句从数据库中读写数据，在后续的课程里我们将会学习如何构建一个数据库管理软件。</p>
<h2 id="面向磁盘型数据库系统"><a href="#面向磁盘型数据库系统" class="headerlink" title="面向磁盘型数据库系统"></a>面向磁盘型数据库系统</h2><p>每次我们要访问的数据都不在内存中，我们需要访问磁盘来得到我们需要的数据。在设计我们的软件时，需要设计一系列的组件来保护我们的系统。（有时会出现数据丢失，保存无效或错误数据等情况）</p>
<h3 id="易失型存储和非易失型存储"><a href="#易失型存储和非易失型存储" class="headerlink" title="易失型存储和非易失型存储"></a>易失型存储和非易失型存储</h3><p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/FB4MM@IF@2I_B9@MT1YHAM.png"></p>
<p>存储设备层次</p>
<p>图中虚线上方的存储设备属于易失型存储，而虚线下方的属于非易失型存储，不同存储设备的<strong>访问速度从上到下递减，容量大小从上到下递增</strong>。</p>
<p>当电源断开时，易失型存储中的数据将会消失，而不能持续的存在。对于存储在易失型存储中的数据，它支持快速随机访问，当以不同顺序访问不同位置的数据的延迟和速度都大致相同。它具有字节可寻址能力，即当我想读取64byte数据时，我也只得到64byte数据，也许大家觉得这理所当然，但是块可寻址的做法并不是这样。同时具有字节一般我们称DRAM中的东西为内存。</p>
<p>而易失型存储中的数据即使在断电后也能被持久性的保存。对于大部分非易失型存储（如磁盘），它一般支持的是顺序访问，这意味着访问不同位置的数据的延迟和速度会有差异，当读写一段连续的块中的内容时会更有效率，所以我们尽可能希望按序读取数据。另一方面，它不想DRAM一样具有字节可寻址能力，它具备的是块寻址能力，当我们要访问非易失型存储中的数据时，我们得到的一般是数据所在的块或页（可以看作是同一个东西），假如我们只想要64byte的数据，我们也不得不把整个大小为4KB的页读出来。</p>
<p>在数据库中，我们需要将数据从磁盘（非易失型存储）移动到内存（易失型存储）。</p>
<p>在图中的分割线处还有一类新的非易失型存储设备（e.g Intel傲腾内存），它像DRAM那样具有字节可寻址能力，又能够在断电后持久性保存数据。目前这种设备还未被大量使用，但是Andy认为它是数据库未来的方向。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/ZE1C6@BP4J342PH25Q.png"></p>
<p>可以看到不同设备的访问耗时有着巨大的差异，这意味着我们需要最小化从磁盘读取数据的影响，如果我们每次都要从磁盘读取数据，那么数据库的运行效率将十分惨淡。</p>
<h3 id="系统设计目标"><a href="#系统设计目标" class="headerlink" title="系统设计目标"></a>系统设计目标</h3><p>我们希望在数据库系统中达成的目标是给上层的应用程序一种<strong>错觉</strong>，即我们能够提供足够的内存将整个数据库存入内存中。即我们想要存储的数据库超出了可用内存的大小，但我们不必每次停下去读取或写入某些东西。</p>
<p>这几节课的内容就是关于如何最小化每次从磁盘读取内容或运行查询时所带来的影响（多线程，缓存，提前计算相关数据）。</p>
<h3 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h3><p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/UJE7ZS8Z5TT1UQZEUIBYQ.png"></p>
<p>上层的应用向buffer缓存池请求读取page2的内容，这时page2不在内存中，我们再从磁盘的page目录中查找到page2，并将其放入内存缓冲池中，再由buffer将page2的指针提交给上层</p>
<h3 id="为什么不使用OS"><a href="#为什么不使用OS" class="headerlink" title="为什么不使用OS"></a>为什么不使用OS</h3><p>这个过程像是操作系统中的虚拟内存的工作机制，我们为什么要在数据库中再做这样的内存管理呢？</p>
<p>在OS的术语中，我们可以使用mmap实现上述机制。如果我们使用OS来帮我们进行内存的管理，这就意味着我们放弃了对数据的直接控制权。OS不关心数据库的行为，它不知道数据库想要做什么，它只知道数据的读写，而不知道高层的语义。这会导致数据库需要使用更多的机制来提示OS的操作，但是我们始终无法完全控制OS完全按照我们的想法行动，这可能会导致许多性能瓶颈。</p>
<p>许多数据库都使用了mmap（levelDB,mongoDB，memSQL，SQLite），但它们大多数在发展过程中都逐渐摆脱了mmap，因为使用OS做内存管理会导致许多限制和性能瓶颈。（We known that Andy hate mmap）</p>
<p>而数据库明白查询的语义，它知道工作负载如何，它能够根据这些做出最佳选择，但OS不知道这些，它只知道一些底层的读写调用。OS就像一辆通用卡车，但我们能够像保时捷法拉利那样调整我们的系统，来做到更好的定制化，</p>
<h3 id="如何用磁盘上的文件表示数据库"><a href="#如何用磁盘上的文件表示数据库" class="headerlink" title="如何用磁盘上的文件表示数据库"></a>如何用磁盘上的文件表示数据库</h3><h3 id="如何将页存储在文件中"><a href="#如何将页存储在文件中" class="headerlink" title="如何将页存储在文件中"></a>如何将页存储在文件中</h3><p>数据库就是磁盘上的一堆文件。对于OS而言，它不知道这里面有什么，这只是一堆普通的二进制文件。但是这些数据文件的格式通常都是专用于某个数据库管理系统的，我们无法将SQLite文件导入mySQL中，反之亦然。</p>
<p>我们通常将文件存放在OS提供的文件系统中（Ex3，Ex4），我们使用文件系统的读写API对文件进行读写（提高数据库的可移植性和降低开发复杂度）。</p>
<h4 id="存储管理器"><a href="#存储管理器" class="headerlink" title="存储管理器"></a>存储管理器</h4><p>我们的课程lab将会构建一个存储管理器（存储引擎），它负责维护磁盘上的数据库文件，我们将这些文件组织为一个page的集合，我们的存储管理器将会跟踪在这些page上的所有读写操作。</p>
<h4 id="数据库page"><a href="#数据库page" class="headerlink" title="数据库page"></a>数据库page</h4><p>一个page就是一个固定大小的数据块，我们将文件组织为这些块，它能够存储各种东西（数据，索引，日志，元数据），但是有些数据库要求page必须是self-contained的，即page中的所有信息你都需要知道如何去理解和解释。</p>
<p>举例说，我有一张表，我将表的元数据存入一个page，而表的所有tuple存入另一个page，但是现在磁盘烧了，存储元数据的那个page丢失了，那么我就无法解释存储tuple的那个page，我们不知道这里面的数据是什么。所以我们应该将元数据和tuple应该存放在一起，这样就满足了self-contained。</p>
<p>所以self-contained特性能够保证即使丢失了一个page，也不会影响其他page，许多系统通过它来进行容灾恢复。</p>
<p>每个page会被赋予一个唯一的内部标识符，我们会有一个indirection层来将一个pageID映射到集合中一个文件的某个位置（记录一个相对位置，当文件整体移动后，我们只需要知道文件的起始位置，就可以通过pageID得到数据对应的位置，因为页的大小是固定的，id*页的大小就能够得到offset）</p>
<p>我们需要明确数据库中讲的page和OS以及硬件层的page不完全相同。</p>
<p>对于硬件层和OS来说，一个page的大小一般为4KB，但数据库中page的大小是可调整的（512B~16KB），需要注意的是由于硬件层的page大小为4KB，这意味这当我对磁盘进行写入和刷新时，存储设备只能保证每次写入4KB时原子性的。</p>
<p>这就容易造成一个问题 例如我们将一个16KB的数据库page回写到磁盘 但是OS在写入前8KB后故障了 这个时候它并不会回滚，它只会继续把剩下8kb继续写入磁盘，这样会导致这16kb的数据被分裂成两部分，我们就不能使用了</p>
<h4 id="page存储架构"><a href="#page存储架构" class="headerlink" title="page存储架构"></a>page存储架构</h4><p>不同DBMS使用不同的方式管理磁盘上的page</p>
<h5 id="Heap-file-organization"><a href="#Heap-file-organization" class="headerlink" title="Heap file organization"></a>Heap file organization</h5><p>数据库中的heap文件是一个page的<strong>无序</strong>集合，即随机地把tuple存在其中，当我们将tuple一个接一个地插入，不能保证在磁盘的顺序和插入的顺序相同。</p>
<p>我们需要使用一些元数据来跟踪page，知道哪些page是空闲的，这样我们就可以将数据插入到空闲的page中。</p>
<p>我们可以通过不同的方式表示heap文件。</p>
<p>1.链表</p>
<p>我们需要在heap文件的头部中维护两个链表，一个是指向空闲page的链表，另一个是指向已保存数据page的链表。每次我们要插入数据的时候就在空闲page的链表中遍历查找一个大小合适的page来保存插入的数据。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/KA0E_UOHB74O8W6U.png"></p>
<p>2.page目录</p>
<p>page目录一样存放在heap文件的头部中，它里面维护了pageID和它们位置的映射关系，我们也可以在其中维护一些额外的元信息，例如每个page的空闲空间，当我想要插入一些数据的时候，我们就可以在page字典中查找到对应的page存放数据。</p>
<p>（类似hash Table）</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/2IJNNGPAORYUWO96.png"></p>
<p>page目录</p>
<p>这时我们会遇到一些关于原子性操作的问题，当我们删除了一些数据和page，我们也需要修改page目录中的信息，表示这个page现在有空闲的空间了。但是这个过程不能保证是原子性的，有可能在我们修改page目录中的信息前，系统崩溃了，当系统恢复正常时，page目录中仍显示哪些我们已经删除数据的page是满的，但实际上它已经变成空闲的了。</p>
<p>也许我们可以在系统恢复后，对所有page进行一次扫描并更新对应的page目录信息。但在数据库中信息量非常大的情况（1PB），这个工作就显得不太可能完成。</p>
<p>我们后续会讨论采用一些机制来维护日志和初始的元数据，在系统崩溃后，我们仍然可以正确的恢复它。</p>
<p>（Q1：为什么数据库的page大小要设置的比OS和硬件层更大？</p>
<p>A1：这是一种权衡，在数据库内部，我们使用内存中的page目录来映射page的位置。如果我们使用更大的page，那么我们使用的pageID就更少，相应的page目录就更小，类似CPU中的TLB（页表缓存）；如果page设置的小，那么page目录就会变得很大，那么它就难以存放在高速缓存或是内存中。</p>
<p>我们可以讨论一下随机访问和顺序访问的问题，如果我们的数据库page是16KB，我们可以连续写出4个4KB的page（OS意义的page）来表示它，这其实一定程度上用到了顺序访问的特点。但是我们在写入的时候也需要增加许多机制来防止由于原子性导致的数据错误。所以不同的做法各有优缺点，这也是许多商业数据库允许你根据自己的需要调整数据库的原因。）</p>
<p>（Q2：如果使用self-contained page，是否能够解决上述的原子性问题？</p>
<p>A2：不行，因为对于self-contained page，它只是表示元数据和tuple放在同一个数据page中。我们在修改数据时，一定需要做修改数据page和修改目录page这两步操作，原子性的问题并没有解决。）</p>
<h5 id="page头部"><a href="#page头部" class="headerlink" title="page头部"></a>page头部</h5><p>每一个page中都有一个包含元数据的头部，头部中的数据一般包括：</p>
<p>1.page大小</p>
<p>2.Checksum（使用CRC,md5来检验出错）</p>
<p>3.数据库管理系统版本</p>
<p>4.transaction visibility（目前不太了解，就不翻译了)</p>
<p>5.compression information（同上）</p>
<h5 id="page布局"><a href="#page布局" class="headerlink" title="page布局"></a>page布局</h5><p>对于任何page存储架构，我们需要理解如何在page内部存储和组织数据</p>
<p>我们可以通过两种方式表示一个page中的数据：(我们假设目前只存储tuple)</p>
<p>1.Tuple-oriented；2.log-structured</p>
<p>我们现在来看一看page内部是怎样的。</p>
<p><strong>Tuple-oriented</strong></p>
<p>首先来看一看最简单的一种做法</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/KH93RO3Z2AECQ.png"></p>
<p>我们在page的头部中记录一个TupleNum，它表示目前存储的tuple的数量，每次插入一个新的tuple，我们就根据TupleNum来计算偏移量，将新的tuple插入到最后。</p>
<p>但是这么做很蠢，因为当我们要在中间删除一个tuple的时候，我们要将在它之后的大量tuple都向前移。</p>
<p>也许我们可以不必移动后面的tuple，而是将新的tuple插入到这个空位就行了，但这仍然不好，因为我们要存储的tuple可能是不定长的，可能这个空位不够大，无法容纳新的tuple。另一方面，这种做法要求我们在头部维护一个空位信息来告诉新插入的tuple，哪些位置是空位。</p>
<p>我们介绍一种更加通用的page存储策略：<strong>slotted page</strong></p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/SGCPRH17CE_L1WE14FB7V.png"></p>
<p>首先在page的头部保存一些基本的元数据（checksum，访问时间等），并且我们有一个slot数组，它将一个特定的slot映射到page内的一个偏移量。而数据存储部分则在page的最后部分。我们可以通过查找slot数组来得到tuple的偏移量，并进一步查找得到数据。当tuple移动时，只需要更新slot数组的对应值就行。这样，当我们要查找一条tuple时，我们可以使用pageID和slot number来定位它。</p>
<p>我们填充page的方式是从前往后对slot数组进行填充，而数据则是从后向前填充（如图所示，对于tuple1而言，我们从page结束位置开始，减去tuple1的大小，这样就得到了tuple1的起始偏移量，并将它存到slot数组中），当我们的数据占用了page的一半大小时，将认为这个page已满，这样可能会留下一些空隙，但我们为了支持可变大小的tuple，不得不这么做。</p>
<p>（Q3：我怎么知道tuple1是存在slot1中的？</p>
<p>A3：我们识别tuple的方式是使用tupleId或recordId，它是一个用来表示一个tuple的逻辑地址，一般是由pageId加上offset或是slot来表示。</p>
<p>Andy分别使用PostgreSQL，SQLite，Oracle来展示不同的数据库如何定位一个tuple。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/2HTVS72D7C7ZQIIH8.png"></p>
<p><strong>首先是PostgreSQL的例子</strong>，它使用属性ctid来定位不同tuple，（0，1）表示该tuple位于page0，slot1的位置</p>
<p>当我们删除id=102的tuple后得到下图的结果。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/U02JAYPV953_PDTWO@@9.png"></p>
<p>可以看到slot2被清空了，那么考虑一下如果这时我们再插入新的tuple，新的tuple会放在slot2还是slot4？</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/JEAMUWX338_T0J8BIPN.png"></p>
<p>答案是新的tuple会放在slot4（这只是代表PostgreSQL的做法）</p>
<p>在PostgreSQL中有一个类似于GC的东西，叫做vaccum，它会遍历所有page，并对它们进行整理，当它发现空闲空间，它会对这些page进行压缩。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/8ENM9Z_4LQ2L7_PK.png"></p>
<p>这是我们执行vaccum后的结果，可以看到id=103的tuple被移动到slot2的空位上，后面的id=104的tuple也向前紧凑。</p>
<p><strong>接下来看看在SQL server中是如何定位一个tuple</strong></p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/TUNN@0JKOELI8JGP.png"></p>
<p>SQL中使用File：Page：Slot这个属性清晰的告诉我们tuple的位置。</p>
<p>然后我们将第二条tuple删去，得到下图的结果。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/NPRF6TCDA72@NH8U.png"></p>
<p>再插入一条新的tuple看看，对于SQL server而言，它会将新的tuple放在哪个Slot。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/LM11OC61@NJRMEAWKI.png"></p>
<p>从上图中看到，SQL server在更新pserverage时，它一旦发现了page中存在可用的空隙，那么它会将page做紧凑处理，然后再将数据写出到page上。所以我们会看到id=103的tuple从slot2被移动到slot1，而新插入的id=104的tuple被放在slot2。</p>
<p><strong>最后我们看看Oracle的做法</strong></p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/RFVXX_R6REBF5ZFZX95M.png"></p>
<p>Oracle使用rowID来定位tuple，但是显然rowID的数据我们看不懂，我们可以添加命令对他进行翻译，得到OBJID,FILENUM,BLOCKNUM,ROWSLOT这几项属性。</p>
<p>同样的，我们删去ID=102的tuple。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/2KDGZA5CZZTWAXS3E.png"></p>
<p>最后插入一条ID=104的tuple。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/1P@DX88OO1QEV8@XH.png"></p>
<p>结果和PostgreSQL相似，新插入的tuple被放在了Slot3上，而不是存在空位的Slot1。</p>
<p>上面三个例子是不同数据库表示内部tuple的方法，SQL server会在我们写入数据时进行压缩，而PostgreSQL和Oracle则是把空的slot放在那里不管它。不同的数据库系统做不同的事情，这只是系统内部组织page的tuple的方法，它并不会影响系统的其他部分。</p>
<p>）</p>
<h3 id="页中的tuple是怎样的"><a href="#页中的tuple是怎样的" class="headerlink" title="页中的tuple是怎样的"></a>页中的tuple是怎样的</h3><h3 id="tuple布局"><a href="#tuple布局" class="headerlink" title="tuple布局"></a>tuple布局</h3><p>对我们而言，tuple是一串字节，当我们取得了slot偏移量，我们向对应的位置写入一些字节，这就足够了。</p>
<p>但对于数据库而言，它需要能够解释这一串字节的实际含义。这也是我们需要有scheme的原因，scheme会记录不同属性的类型，这样我们可以知道tuple的大小，并进一步跳转到不同的偏移量处得到我想要的tuple。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/YEHLKACVXJ11GW2S7UV.png"></p>
<p>上图是tuple的结构，在一个tuple内我们也需要一个头部来追踪不同的信息，例如哪一个事务查询修改了它，以及null值的位图。</p>
<p>通常情况下，我们不需要将tuple的元数据（这个tuple有几列，不同属性的类型等）保存在tuple内部。我们将这些高级的元数据保存在这个page里（整个page都存储同一个表的tuple）。</p>
<p>但是对于支持JSON和scheme的数据库（MongoDB），我们需要将元数据写在tuple内部，因为每一条tuple和记录都可能不同，所以我们要保存与其实际内容相关的元数据。</p>
<h4 id="不同表的数据保存在同一个page"><a href="#不同表的数据保存在同一个page" class="headerlink" title="不同表的数据保存在同一个page"></a>不同表的数据保存在同一个page</h4><p>大多数情况下，我们为了让page变得独立，我们不会想将不同表的tuple保存在同一个page中，这样我们不得不保存一大堆属于不同表的元数据。</p>
<p>在某些情况下，我们希望将一张表嵌入另一张表中，我们会使用join操作将不同的表进行内联，这时，我们可以将不同表的数据放在同一个page中。</p>
<p>举例来说，如下图所示，我们有foo和bar两个table，它们使用一个外键相关联。</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/1O01UGBX9N_HWDP5.png"></p>
<p>通常情况下，我们会将这两张表分开保存在不同page中（如下图）</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/W2I7QUN@CUPCFD8KB.png"></p>
<p>但是当我们想将两张表进行join操作时，我们会将bar的tuple直接内嵌在foo的tuple中，这样它们就被存放在同一个page中。（如下图）</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/05/OE43Y5@M8XC59V0FJIHY.png"></p>
<p>这被称为反范式化，在内部我们会以这样的方式存储我们的page，在应用程序看来，它里面有两张相同的表，但在内部，我们的page实际上将它们合并到一起了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>数据库是通过page组织数据的</p>
<p>我们使用不同的方式来跟踪文件中的page</p>
<p>我们使用不同方式来存储page</p>
<p>在page中，我们可以用不同的方式存储tuple</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/18/mit-6-824-lab4b-sharded-key-value-server/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="wwow">
      <meta itemprop="description" content="努力不一定会成功，但不努力真的很舒服">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wwow's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/18/mit-6-824-lab4b-sharded-key-value-server/" class="post-title-link" itemprop="url">MIT-6.824-lab4B-Sharded Key/Value Server</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-18 17:19:25" itemprop="dateCreated datePublished" datetime="2020-04-18T17:19:25+08:00">2020-04-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-30 12:00:51" itemprop="dateModified" datetime="2020-08-30T12:00:51+08:00">2020-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mit6-824/" itemprop="url" rel="index"><span itemprop="name">mit6.824</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://github.com/wwow1/MIT-6.824">github: https://github.com/wwow1/MIT-6.824</a></p>
<p>在4A中我们完成了shardmaster的构建，那么下一步我们就需要完善shardmaster下层的分片kv存储系统。</p>
<p>在这个实验中，我们将数据进行分片处理，并将它们下放到不同的shardkv集群中进行管理。对于分片的内容和处理都应该对上层进行封装，简而言之，对于上层的用户而言，他的使用体验应该和lab3相同。而shardkv服务器向上层提供Get，Put，Append三个接口（它们的功能和lab3相同）</p>
<p>首先说明一下，我贴出的代码都是最终代码，所以在解释过程中大家可能发现某些代码的作用不太看得懂，那么可以先略过它们，等到后面看到错误解析的时候就会明白它们的作用</p>
<p><strong>1.移植lab3代码</strong></p>
<p>任务书上说，我们首先应该通过第一个测试，这个测试是静态的分片，我们不用考虑集群变化和分片迁移的问题，先把lab3中的代码抄过来（记得在common中的RPC结构中也要加上opnum和clientId）  </p>
<p>在将lab3的代码转移过来的时候有一些需要修改的地方，我们看一看实验提供的client代码，可以看到对于每一次的Get，PutAppend的返回中，都需要根据reply.Err来决定下一步的操作，而在lab3中我没有使用到这个变量，所以我需要在server代码的RPC调用添加上对于Err的修改</p>
<p>（1）确定WrongLeader=true时，不需要管Err</p>
<p>（2）WrongLeader=false， 且该请求已经被成功执行，则Err=OK</p>
<p>（3）WrongLeader=false，但该请求的key不属于当前集群所负责的分片，Err=ErrWrongGroup</p>
<p>既然提到了对key的判断，那么也应该在server的Get和PutAppend中判断改key是否处于当前集群的管理中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func (kv *ShardKV) checkShard(key string) bool&#123;</span><br><span class="line">	kv.mu.Lock()</span><br><span class="line">	defer kv.mu.Unlock()</span><br><span class="line">	return kv.configuration.Shards[key2shard(key)]!&#x3D;kv.gid</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;server.go中Get和PutAppend的最前端</span><br><span class="line">_,isLeader:&#x3D;kv.rf.GetState()</span><br><span class="line">if isLeader&#x3D;&#x3D;false&#123;</span><br><span class="line">	reply.WrongLeader&#x3D;true</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br><span class="line">reply.WrongLeader&#x3D;false</span><br><span class="line"></span><br><span class="line">if kv.checkShard(args.Key)&#123;  &#x2F;&#x2F;判断key是否属于当前集群</span><br><span class="line">	reply.Err&#x3D;ErrWrongGroup</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.更新Config信息</strong></p>
<p>现在我们的kv系统已经能够在静态分片的情况下工作了，那么下一步就需要解决集群更改的问题了</p>
<p>首先我们需要单独开启一个线程让它能够周期性的向shardmaster询问当前最新的集群信息（config），如果shardmaster发布了更新的集群信息，那么就需要更改自己的集群信息，然后更改集群配置</p>
<p>由于我的查询函数比较复杂，涉及到后面的一些细节，不便于在这一段讲解，所以我用文字给大家列一下执行步骤。</p>
<p>查询函数QueryConfig执行流程：</p>
<p>（1）<strong>周期性</strong>地循环调用shardmaster的接口Query，来获得最新的下一个的Config（Query(kv.configuration.Num+1))</p>
<p>（2.1）如果shardmaster返回的newConfig.Num&gt;kv.Config,Num，就使用newConfig来替换当前config。并且如果当前函数执行者是集群的<strong>leader</strong>，那么它就应该对比newConfig和当前config得到需要更新的分片编号，然后调用sendShardMigrationRPC；如果不是leader就等待进入下一次循环</p>
<p>（2.2）如果newConfig.Num&lt;=kv.Config.Num，那么就等待进入下一次循环</p>
<p><strong>3.分片迁移</strong></p>
<p>然后我们再说一下sendShardMigrationRPC，我们知道当集群配置发生变化时，不同集群所负责的分片也会发生变化，某些分片可能从当前的集群迁移到另一个集群，sendShardMigrationRPC的作用就是负责分片的迁移，这里需要考虑一下到底是主动发送RPC去请求分片，还是等待对方将分片送过来。</p>
<p>实验指导书上面有提到，在shardkv server可以继续存储不属于它负责的分片，这将简化我们的工作。这也意味着，对于一个shardkv server而言，它不需要管那些即将离去的分片，因为它们根本就不影响自己的工作；但对于要接受这些分片的server而言，何时接收到这些新的分片将影响它们对于client request的响应，所以我选择由分片接收方主动请求分片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;傻瓜版的syncMap，主要用于整合sendShardMigrationRPC中得来的新分片</span><br><span class="line">type syncMap struct&#123;</span><br><span class="line">	State map[string]string &#x2F;&#x2F;key-&gt;value</span><br><span class="line">	ApplyNum map[int64]int  &#x2F;&#x2F;clientId-&gt;opnum</span><br><span class="line">	mu 	sync.Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;sendShardMigrationRPC的主要代码</span><br><span class="line">&#x2F;&#x2F;为了保证一致性，要求分片的转移只能在leader间进行，然后leader再通过raft实现&#x2F;&#x2F;集群内部的一致性</span><br><span class="line">for _,v:&#x3D;range newShards&#123;</span><br><span class="line">	wg.Add(1)</span><br><span class="line">	go func(value int)&#123;</span><br><span class="line">		defer wg.Done()</span><br><span class="line">		for&#123;</span><br><span class="line">			if oldConfig.Shards[value]&#x3D;&#x3D;0&#123;  </span><br><span class="line">				return</span><br><span class="line">			&#125;</span><br><span class="line">			if servers, ok :&#x3D; oldConfig.Groups[oldConfig.Shards[value]]; ok &#123;</span><br><span class="line">				for si :&#x3D; 0; si &lt; len(servers); si++ &#123;</span><br><span class="line">					srv :&#x3D; kv.make_end(servers[si])</span><br><span class="line">					args:&#x3D;ShardMigrationArgs&#123;value,nowConfig.Num,oldConfig.Num&#125;</span><br><span class="line">					var reply ShardMigrationReply</span><br><span class="line">					ok :&#x3D; srv.Call(&quot;ShardKV.ShardMigration&quot;, &amp;args, &amp;reply)</span><br><span class="line">					WrongLeader:&#x3D;reply.WrongLeader</span><br><span class="line">					if ok &amp;&amp; WrongLeader&#x3D;&#x3D;false&#123;</span><br><span class="line">						tmp.mu.Lock()</span><br><span class="line">						for k,s:&#x3D;range reply.State&#123;</span><br><span class="line">							tmp.State[k]&#x3D;s</span><br><span class="line">						&#125;</span><br><span class="line">						for k,s:&#x3D;range reply.ApplyNum&#123;</span><br><span class="line">							tmp.ApplyNum[k]&#x3D;max(s,tmp.ApplyNum[k])</span><br><span class="line">						&#125;</span><br><span class="line">						tmp.mu.Unlock()</span><br><span class="line">						return</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			time.Sleep(100 * time.Millisecond)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(v)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">kv.Migrate(nowConfig,tmp.State,tmp.ApplyNum)</span><br><span class="line">&#x2F;&#x2F;将新的config和新的分片传入raft实现集群内一致</span><br></pre></td></tr></table></figure>

<p>在这之后我们需要完善RPC handler-&gt;ShardMigration</p>
<p>首先我们必须要保证，分片是在两个leader之间迁移，这样才能保证一致性（后续会举例说明）。然后还需要保证对方的config.Num与自己相同或大于自己，如果对方的config小于自己的话，那么许多请求还没有被apply，这时它的分片数据还不够“新”，许多append和put请求也许处于已被提交到raft但还未被apply阶段，如果直接把现在的数据取过来之后，那些请求再被apply到原集群上，这就导致我们取到的数据是缺失的，所以需要通过config.Num来实现一个简单的数据同步</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;ShardMigration 参数结构</span><br><span class="line">type ShardMigrationArgs struct&#123;</span><br><span class="line">	Shards int</span><br><span class="line">	ConfigNum int</span><br><span class="line">	LastConfigNum int  </span><br><span class="line">&#x2F;&#x2F;与下文提到的afterUpdateConfig相同，同样是为保证数据同步</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ShardMigrationReply struct&#123;</span><br><span class="line">	WrongLeader bool</span><br><span class="line">	State	map[string]string  &#x2F;&#x2F;key-&gt;value</span><br><span class="line">	ApplyNum  map[int64]int   &#x2F;&#x2F;clientId-&gt;opnum</span><br><span class="line">&#x2F;&#x2F;实验书上有相关提示，用于防止request dup造成数据的错误</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">func (kv *ShardKV) ShardMigration(args * ShardMigrationArgs, reply *ShardMigrationReply)&#123;</span><br><span class="line">	_,isLeader:&#x3D;kv.rf.GetState()</span><br><span class="line">	if isLeader&#x3D;&#x3D;false&#123;</span><br><span class="line">		reply.WrongLeader&#x3D;true</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	t0:&#x3D;time.Now()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;等待信息同步</span><br><span class="line">	for (kv.configuration.Num&lt;args.ConfigNum || kv.afterUpdateConfig&lt;args.LastConfigNum) &amp;&amp; time.Since(t0).Seconds()&lt;1&#123;</span><br><span class="line">		time.Sleep(100*time.Millisecond)</span><br><span class="line">	&#125;</span><br><span class="line">	if kv.configuration.Num&lt;args.ConfigNum || kv.afterUpdateConfig&lt;args.LastConfigNum&#123;</span><br><span class="line">		reply.WrongLeader&#x3D;true</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;传递状态信息和applyNum</span><br><span class="line">	kv.mu.Lock()</span><br><span class="line">	reply.State&#x3D;make(map[string]string)</span><br><span class="line">	reply.ApplyNum&#x3D;make(map[int64]int)</span><br><span class="line">	for k,v:&#x3D;range kv.DB&#123;</span><br><span class="line">		if key2shard(k)&#x3D;&#x3D;args.Shards&#123;</span><br><span class="line">			reply.State[k]&#x3D;v</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#x2F;&#x2F;下面这部分可以先略过，在错误解析中会提及</span><br><span class="line">	for index,v:&#x3D;range kv.applyNum&#123;   </span><br><span class="line">		shd,ok:&#x3D;kv.ErrGroupApply[index]</span><br><span class="line">		if ok &amp;&amp; args.Shards!&#x3D;(int(shd[0])%shardmaster.NShards&#123;</span><br><span class="line">			reply.ApplyNum[index]&#x3D;v-1</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			reply.ApplyNum[index]&#x3D;v</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	kv.mu.Unlock()</span><br><span class="line">	reply.WrongLeader&#x3D;false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.提交newConfig</strong></p>
<p>然后就是将新的集群信息传入raft实现集群内部一致性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func (kv *ShardKV) Migrate(configuration shardmaster.Config,State map[string]string,ApplyNum map[int64]int) &#123;</span><br><span class="line">	_,isLeader:&#x3D;kv.rf.GetState()</span><br><span class="line">	if isLeader&#x3D;&#x3D;false&#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	op:&#x3D;Op&#123;&quot;updateConfig&quot;,0,UpdateConfig&#123;configuration,State,ApplyNum&#125;,0&#125;</span><br><span class="line">	_,_,Leader:&#x3D;kv.rf.Start(op)</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Migrate这一部分的内容很简单，主题就是调用rf.Start，但是不知道大家会不会有一个疑问，在lab3中，我们在start后，不应该还需要等待结果来确认这个command是否真的被apply吗？</p>
<p>原因就是即使我们等待后明白了这个config是否被正确apply了，也没有意义。假设知道了config成功apply，那么就直接返回，不需要保存信息。而假设config没有成功apply，那么原因大概率是因为leader改变了，“我”已经不是leader了，那么“我”也无法再主导一次新的rf.start，所以结果还是直接返回。既然如此，干脆就不等待apply的结果了，在调用了rf.start之后就return</p>
<p>config update这个请求是由server集群自己产生的请求，而不是由client调用的请求，所以config提交失败之后不能返回client，也不能让client再次寻找新的leader提交请求。</p>
<p>但是如果我们不检验config update的结果的话，我们无法知道这个config是否成功的更新了，也许我们仅仅是再QueryConfig函数中更新了kv.configuration这一个变量，但是实际上的applyNum和DB都没有更新，那么就出大问题了</p>
<p>为了解决这个问题，我使用了一个新的变量afterUpdateConfig ，用它来记录已更新的config.Num。</p>
<p>然后我们需要进一步修改QueryConfig函数，这一次我们根据代码来实际分析一下整个函数流程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;QueryConfig的主体</span><br><span class="line"></span><br><span class="line">_,isLeader:&#x3D;kv.rf.GetState()</span><br><span class="line">afterUpdateConfig:&#x3D;kv.afterUpdateConfig</span><br><span class="line">oldConfig &#x3D; kv.mck.Query(afterUpdateConfig)</span><br><span class="line">&#x2F;&#x2F;当前config</span><br><span class="line"></span><br><span class="line">newConfig :&#x3D; kv.mck.Query(afterUpdateConfig+1)</span><br><span class="line">&#x2F;&#x2F;下一个confiig</span><br><span class="line"></span><br><span class="line">if newConfig.Num &gt; kv.configuration.Num&#123;</span><br><span class="line">	kv.mu.Lock()</span><br><span class="line">	kv.configuration&#x3D;newConfig</span><br><span class="line">	kv.mu.Unlock()</span><br><span class="line">	if isLeader&#123; &#x2F;&#x2F;如果是leader，就需要确认新的分片</span><br><span class="line">		newShards:&#x3D;make([]int,0)</span><br><span class="line">		for i :&#x3D; 0; i &lt; shardmaster.NShards; i++ &#123;</span><br><span class="line">			if newConfig.Shards[i] &#x3D;&#x3D; kv.gid &amp;&amp; oldConfig.Shards[i] !&#x3D; newConfig.Shards[i] &#123;</span><br><span class="line">				newShards &#x3D; append(newShards, i)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		t0&#x3D;time.Now()</span><br><span class="line">		go kv.sendShardMigrationRPC(oldConfig,newShards)</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;else if newConfig.Num &lt;&#x3D; kv.configuration.Num &amp;&amp; oldConfig.Num&lt;newConfig.Num &amp;&amp; time.Since(t0).Seconds()&gt;1 &amp;&amp; isLeader&#123;</span><br><span class="line">&#x2F;&#x2F;如果oldConfig.Num&lt;newConfig.Num说明这个新的config并没有真正的被apply</span><br><span class="line">&#x2F;&#x2F;设置一个时间点，例如这里的1s，如果超出时限仍没有被apply</span><br><span class="line">&#x2F;&#x2F;那么它有可能提交失败了，所以我们再次调用send...RPC重新获取分片并提交config</span><br><span class="line"></span><br><span class="line">	t0&#x3D;time.Now()</span><br><span class="line">	var newShards []int</span><br><span class="line">	for i :&#x3D; 0; i &lt; shardmaster.NShards; i++ &#123;</span><br><span class="line">		if newConfig.Shards[i] &#x3D;&#x3D; kv.gid &amp;&amp; oldConfig.Shards[i] !&#x3D; newConfig.Shards[i] &#123;</span><br><span class="line">			newShards &#x3D; append(newShards, i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	go kv.sendShardMigrationRPC(oldConfig,newShards)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5.apply newConfig</strong></p>
<p>在任务书中有提到，在我们进行一次集群变换的时候，是不应该接收新的client请求的，因为集群可能还没有实现真正意义上的更新（更新DB和applyNum），这时我们就需要在Get和PutAppend中添加等待</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for kv.afterUpdateConfig&lt;kv.configuration.Num&#123;</span><br><span class="line">&#x2F;&#x2F;条件满足说明新的config还没有被真正apply，则client的请求先搁置</span><br><span class="line">	time.Sleep(20*time.Millisecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们提交的updateConfig请求通过raft达到一致并被再次传递到shardkv中时，我们就需要使用updateConfig中的数据更新shardkv的状态信息和applyNum</p>
<p>首先我们需要在apply函数中增加一个对updateConfig的处理接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if op.Operation&#x3D;&#x3D;&quot;updateConfig&quot;&#123;</span><br><span class="line">	Command:&#x3D;(op.Command).(UpdateConfig)</span><br><span class="line">	kv.ApplyNewConfig(Command)</span><br><span class="line">	kv.mu.Lock()</span><br><span class="line">	if msg.Index&gt;kv.commitIndex&#123;</span><br><span class="line">		kv.commitIndex&#x3D;msg.Index</span><br><span class="line">		kv.commitTerm&#x3D;msg.Term</span><br><span class="line">	&#125;</span><br><span class="line">	kv.mu.Unlock()</span><br><span class="line">	continue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后转入ApplyNewConfig函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">func (kv *ShardKV) ApplyNewConfig(args UpdateConfig)&#123;</span><br><span class="line">&#x2F;&#x2F;首先要保证我们的集群是一定不会回退的，通过集群号来鉴别过时的config</span><br><span class="line">	if kv.afterUpdateConfig!&#x3D;args.Configuration.Num-1&#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	kv.mu.Lock()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;有关ErrGroupApply的部分在错误解析部分会说明</span><br><span class="line">	for k,v:&#x3D;range kv.ErrGroupApply&#123;</span><br><span class="line">		if args.ApplyNum[k]&lt;kv.applyNum[k]&#123;</span><br><span class="line">			delete(args.ApplyNum,k)</span><br><span class="line">			delete(args.State,v)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for k,v:&#x3D;range args.ApplyNum&#123;</span><br><span class="line">		kv.applyNum[k]&#x3D;max(v,kv.applyNum[k])</span><br><span class="line">	&#125;</span><br><span class="line">	for k,v:&#x3D;range args.State&#123;</span><br><span class="line">		kv.DB[k]&#x3D;v</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;更新afterUpdateConfig</span><br><span class="line">	kv.afterUpdateConfig&#x3D;max(args.Configuration.Num,kv.afterUpdateConfig)</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;做一个“啰嗦”的保护</span><br><span class="line">	if kv.configuration.Num&lt;args.Configuration.Num&#123;</span><br><span class="line">		kv.configuration&#x3D;args.Configuration  </span><br><span class="line">	&#125;</span><br><span class="line">	kv.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此为止，我们的主要流程已经结束，但是debug之路才刚刚开始，我们需要根据错误反馈来进一步完善代码</p>
<p><strong>6.错误解析和解决办法</strong></p>
<p><strong>问题1：分片迁移中的数据缺失1</strong></p>
<p>首先，我一开始在QueryConfig中使用Query（-1）来定义newConfig，这样每次得到的newConfig都是最新的，而不一定是下一个config。  </p>
<p>但是这就导致了一种情况出现，如果shardmaster一次更新了两个config，假设当前config信息为config0{shard[100,100,100]}（假设只有三个分片，shard数组内的数组表示负责该分片的集群编号），更新的第一个config信息为config1{shard[101,101,101]}，更新的第二个分片是config2{ shard[102,102,102]}</p>
<p>由于我们的QueryConfig是周期性的Query，所以在这种情况下，不同集群的config变化情况可能不同</p>
<p>对于gid101而言，它直接从config0更新到了config2，但是不管是在config0还是config2中，gid101都不负责任何分片，它也不参与任何分片迁移过程。但是对于gid102而言，它先更新到config1，再更新到config2，从config1更新到config2的过程中，它不参与分片迁移过程，但是从config1更新到config2时，它需要向gid101请求三个分片。但是我们知道，gid101根本就没有任何分片，那么gid102取到的分片全是空的，但实际上在config0时，gid100中的这三个分片的内容不是空的，这就导致我们的分片数据缺失了</p>
<p>造成这个错误的原因是由于不同集群的config变化情况不一致，所以我们修改了QueryConfig，使其每次只更新下一个config而不是最新的config。这样所有集群都会老老实实的从config0更新到config2，而不会发生有集群“跳步操作“造成它与其他集群的不一致</p>
<p><strong>问题2：分片迁移中的数据缺失2</strong></p>
<p>在ShardMigration中，一开始我没有使用到afterUpdateConfig，但是这导致了切片传递中的数据缺失</p>
<p>同样是问题1中的例子，假设gid102从config1更新到config2，而gid101正从config0更新到config1。这时gid102应该向gid101请求分片，但是gid101可能也正在向gid100请求分片，那么可能在gid101还未向gid100取完分片前，gid102就取完分片了，这种情况下，gid102只取到了部分分片。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;ShardMigration的前置判断</span><br><span class="line">&#x2F;&#x2F;kv.afterUpdateConfig&gt;&#x3D;args.LastConfigNum才向下执行</span><br><span class="line"></span><br><span class="line">for (kv.configuration.Num&lt;args.ConfigNum || kv.afterUpdateConfig&lt;args.LastConfigNum) &amp;&amp; time.Since(t0).Seconds()&lt;1&#123;</span><br><span class="line">	time.Sleep(100*time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line">if kv.configuration.Num&lt;args.ConfigNum || kv.afterUpdateConfig&lt;args.LastConfigNum&#123;</span><br><span class="line">	reply.WrongLeader&#x3D;true</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了解决这种问题，我们需要在取分片之前（ShardMigration）加上一个确认条件，即kv.afterUpdateConfig应该大于等于 args.LastConfigNum（就是afterUpdateConfig)</p>
<p><strong>问题3：部分请求丢失</strong></p>
<p>假设一种情况，数据A即将从gid100转移到gid101，一般来说，在转移过程中，server不会接受新的client请求，但是<strong>对于已经提交到raft但还未被shardkv apply的请求，无法被屏蔽</strong>。当数据A通过ShardMigration传递到gid101后，某个append{A,123}请求从raft被apply到shardkv，那么这个请求会被执行，并且会返回告知client，这个请求执行完成了。</p>
<p>那么下一次Get{A}的时候，就会发现数据A缺失了123，因为这个append123应该在gid101上被执行，但是它却在gid100被执行完了，并且这个数据没有更新到gid101上</p>
<p>为了解决这个问题，我在apply中也添加了一个checkShard(key)函数来检验请求是否正确，如果我们检测到了一个类似上述例子中apend{A,123}这样的请求，我们还是予以执行（个人选择，也可以选择不执行），但是会返回给client一个Err=ErrWrongGroup。</p>
<p>同时与ShardMigration中的前置判断条件相结合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;ShardMigration函数中的前置判断条件</span><br><span class="line">&#x2F;&#x2F;kv.configuration.Num&gt;&#x3D;args.ConfigNum才向下执行</span><br><span class="line"></span><br><span class="line">for (kv.configuration.Num&lt;args.ConfigNum || kv.afterUpdateConfig&lt;args.LastConfigNum) &amp;&amp; time.Since(t0).Seconds()&lt;1&#123;</span><br><span class="line">	time.Sleep(100*time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line">if kv.configuration.Num&lt;args.ConfigNum || kv.afterUpdateConfig&lt;args.LastConfigNum&#123;</span><br><span class="line">	reply.WrongLeader&#x3D;true</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设gid100更新了config，那么在apply中就会对当前请求设置reply.Err=ErrWrongGroup，使client向gid101重发append{A,123}请求。而如果gid100还未更新config，那么在ShardMigration就会卡住直到它更新config为止</p>
<p>从前面这几个错误解析中我们可以知道，ShardMigration中的前置判断条件是非常重要且缺一不可的</p>
<p><strong>问题4：快速更新config导致状态信息与applyNum不匹配</strong></p>
<p>在前面的基础上，考虑一种情况，数据A{key：A，value：0}从gid100转移到gid101，在转移过程中，gid100的raft向其shardkv apply了请求append{key：A,value：123，clientId:1，opnum:20}，由问题3的解法知，gid100仍然执行了append请求，同时更新applyNum[1]=20，并返回一个ErrWrongGroup给client1，让client1重新发送这个append请求给gid101</p>
<p>但此时，在gid101还未接收到client1重发的append请求之前，新的config又来了，这次数据A要立即从gid101再转移回到gid100，这时由于我在ApplyNewConfig函数中使用覆盖的方式更新DB，那么gid.DB[A]从“0123”再次被覆盖为”0，但是由于applyNum=max（rf.applyNum,args.applyNum)，那么applyNum[1]仍然保留为20。</p>
<p>这样的话我们的DB信息和applyNum就出现了不匹配的情况，此时client1又重新发送append{key：A,value：123，clientId:1，opnum:20}给gid100，但是由于applyNum[1]=20，这个请求被判定为request dup，不会被执行。这就导致了数据A缺失了”123”这个部分的信息</p>
<p>我一开始想到了多个思路解决这个方法，让我们一一来想一想它们的可行性：</p>
<p>（1）在问题3中，我们对于“过时”的请求选择不执行，直接返回ErrGroup。这样gid100中applyNum就不会更新到20，请求就不会被判定为request dup，而是正确执行</p>
<p>这个解法看似正确，但是这只是对于leader而言，我们知道ShardMigration中是由leader来交接分片，那么我们上述的思路只能保证在leader中的正确性。但是对于每一个follower而言，它们更新config的时间点和leader不同（apply的时间点相同，但是更新不一定相同）可能这个请求在apply到shardkv时，它们的config还未更新，那么这个请求就不是”过时”的，它们会执行这个请求。在部分follower执行了这个请求后，我们又走上了错误的道路- -</p>
<p>另一方面看，选择不执行“过时”的请求可能导致leader和follower的不一致，所以我选择执行“过时”请求使leader和follower都执行了相同的请求，保持了它们的一致</p>
<p>（2）在ApplyNewConfig函数中，将<br>applyNum=max（rf.applyNum,args.applyNum)</p>
<p>改为<br>applyNum=args.applyNum</p>
<p>很显然这一定不对…因为这样会影响其他正常的client发送的请求，造成回退，进一步导致request dup</p>
<p>在摒弃了上面两种我认为不可行的方法后，我选择了如下方法</p>
<p>使用新的数据结构ErrGroupApply(clientId-&gt;key)来记录与“过时”请求相关的分片和clientId</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在apply中添加代码</span><br><span class="line">if err&#x3D;&#x3D;ErrWrongGroup&#123;</span><br><span class="line">	kv.ErrGroupApply[op.ClientId]&#x3D;Command.Key  </span><br><span class="line">&#x2F;&#x2F;记录这次过时请求的clientId和key</span><br><span class="line">&#125;else&#123;</span><br><span class="line">	delete(kv.ErrGroupApply,op.ClientId)</span><br><span class="line">&#x2F;&#x2F;执行正常时删除clientId和对应的key</span><br><span class="line">&#x2F;&#x2F;因为这一次会正常的执行说明之前的请求都被正确处理了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一方面我们需要向ApplyNewConfig中添加一些代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for k,v:&#x3D;range kv.ErrGroupApply&#123;</span><br><span class="line">	if args.ApplyNum[k]&lt;kv.applyNum[k]&#123;</span><br><span class="line">&#x2F;&#x2F;如果我的applyNum[clientId]更大，并且ErrGroupApply[clientId]存在说明出现</span><br><span class="line">&#x2F;&#x2F;出错情况，那么我们就在args中把这个applyNum和对应的部分数据删除，防止错误覆</span><br><span class="line">&#x2F;&#x2F;盖</span><br><span class="line">		delete(args.ApplyNum,k)</span><br><span class="line">		delete(args.State,v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仅仅是这样还不够，这可能造成新的错误，所以我们也需要修改ShardMigration</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;ShardMigration中传递applyNum的部分代码</span><br><span class="line">for index,v:&#x3D;range kv.applyNum&#123;</span><br><span class="line">	shd,ok:&#x3D;kv.ErrGroupApply[index]</span><br><span class="line">	if ok &amp;&amp; args.Shards!&#x3D;(int(shd[0])%shardmaster.NShards)&#123;</span><br><span class="line">		reply.ApplyNum[index]&#x3D;v-1</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		reply.ApplyNum[index]&#x3D;v</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为在ShardMigration中，无论请求的分片是什么，我们都会将全部client对应的applyNum传递出去。</p>
<p>而修改shardMigration是为了防止  分片请求者没有更新对应errGroup  shard，但是却获得了对应的ApplyNum造成与问题4相同的错误。</p>
<p>最后要记得将ErrGroupApply存入Snapshot，并修改restoreSnapshot和checkLogLength</p>
<p>坦白来说，我觉得我对于问题4的解决方法并不好，基本是属于简单的亡羊补牢类型的debug，但是由于我中期划水，导致我在6.824lab上花费了过多的时间，所以只能是以完成主要部分为主，不进行过多的设计优化</p>
<p><strong>总结</strong></p>
<p>到此为止MIT6.824的lab就完成了，虽然在细节上有很多的不足，但是我认为以我目前的水平能够基本完成测试点覆盖的大多数情况就足够了，进一步的代码优化任务就取决于以后的我了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/10/mit-6-824-4a-shardmaster/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="wwow">
      <meta itemprop="description" content="努力不一定会成功，但不努力真的很舒服">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wwow's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/10/mit-6-824-4a-shardmaster/" class="post-title-link" itemprop="url">MIT-6.824-lab4A-The Shard Master</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-10 22:22:25" itemprop="dateCreated datePublished" datetime="2020-04-10T22:22:25+08:00">2020-04-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-30 12:00:18" itemprop="dateModified" datetime="2020-08-30T12:00:18+08:00">2020-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mit6-824/" itemprop="url" rel="index"><span itemprop="name">mit6.824</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://github.com/wwow1/MIT-6.824">https://github.com/wwow1/MIT-6.824</a></p>
<p>在lab4中，我们将要搭建一个基于分片的kv存储系统，这个系统的工作流程稍微有一点复杂，我看了好几遍说明才看懂- -，同时也参考了一些网上的说明。</p>
<p>简而言之分片（shard）就是将我们要保存的数据分割成多份，然后将这些分片分发给下层的不同个raft集群，每一个raft集群负责多个分片的保存和响应对应的数据操作，同时为了管理这些不同的raft集群，在多个raft集群之上还需要增加一个用于管理分片和集群配置的raft集群，这个集群称为shardmaster</p>
<p>大家也许会想问分片是按照什么方法进行分割的呢？我认为具体的方法是由使用者决定的，在lab4中，由于保存的key-value全都是string变量，同时分片数量确定为10个，所以分配规则为 int(key[0])%10</p>
<p><img src="http://119.23.248.105/%22wp-content/uploads%22/2020/04/image-17.png"></p>
<p>这是我在网上看到的一个非常简单易懂的图片说明，取自<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6e8d33c3c799">https://www.jianshu.com/p/6e8d33c3c799</a></p>
<p>在lab4A中，我们只需要完成shardmaster部分，不涉及具体的分片数据管理</p>
<p>我们主要需要在shardmaster中为上层服务器提供4种服务，分别是</p>
<p>Join：将新的raft集群加入到配置中，同时需要保证在新raft集群加入后，集群中的分片分配是平均合理的</p>
<p>Leave：将先前存在于配置中的raft集群排出到集群之外，同样的，在新的集群中也要实现分片分配的平均合理</p>
<p>Move：将指定的分片分配给指定的某个raft集群</p>
<p>Query：给定一个配置号，返回对应编号的配置信息，如果配置号为-1或大于存在的所有配置号就返回最新的配置信息</p>
<p>这4个功能的具体参数和说明都在6.824的网站上有，这里只是简略的说明功能，在实现的时候还是要认真的查看要求和参数</p>
<p><strong>Client部分</strong></p>
<p>我们首先开始实现shardmaster的client，shardmaster的client中，对于4个功能的client端的调用已经完善，我们不需要更改，主要是做Clerk的初始化和Clerk变量的添加，这里可以仿照lab3的做法，首先为了防止请求重复执行，我们需要一个opnum来为当前发送的请求加上编号，同时为了支持多client操作，我们需要为每个clerk生成一个clientId。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type Clerk struct &#123;</span><br><span class="line">	servers []*labrpc.ClientEnd</span><br><span class="line">	opnum int</span><br><span class="line">	mu 		sync.Mutex</span><br><span class="line">	clientId int64</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Common部分</strong></p>
<p>然后我们需要修改common.go中的RPC结构变量，只需要在每个–Args中添加Opnum和ClientId就行，非常简单，这里就不贴图了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Config struct &#123;</span><br><span class="line">	Num    int              &#x2F;&#x2F; config number</span><br><span class="line">	Shards [NShards]int     &#x2F;&#x2F; shard -&gt; gid</span><br><span class="line">	Groups map[int][]string &#x2F;&#x2F; gid -&gt; servers[]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然提到了common.go，我们就来说一说配置结构Config，首先Num是用于标识当前的Config编号（从1开始），然后是记录分片所属的Shards数组，Shards数组有10个int值，在我们的lab中，使用到的数据被分为10个分片，而Shards则表示分片号和当前管理它们的集群的集群号gid的映射关系</p>
<p><strong>Server部分</strong></p>
<p>最后我们要填写server中的内容，首先是ShardMaster的结构，为了确定Start的log是否apply成功，我们需要加入applyMsg；为了保存每一次apply的结果，需要加入applyCheck；为了保存从头到尾的全部配置信息，我们需要加入configs</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type ShardMaster struct &#123;</span><br><span class="line">	mu      sync.Mutex</span><br><span class="line">	me      int</span><br><span class="line">	rf      *raft.Raft</span><br><span class="line">	applyCh chan raft.ApplyMsg</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Your data here.</span><br><span class="line">	applyMsg map[int64]map[int]Msg</span><br><span class="line">	applyCheck map[int64]map[int]Config</span><br><span class="line">	configs []Config &#x2F;&#x2F; indexed by config num</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们来一一完善Join，Leave，Move，Query这4个RPC</p>
<p>在lab3中，对于client的RPC请求Get和PutAppend，我们首先将它们start给下层的raft，在raft确保一致性之后，再apply到上层，由上层进行具体apply操作。</p>
<p>这里也是一样，我们要将这4种请求传入raft，在raft中保证了一致性之后，再回到当前执行它们</p>
<p>需要确认传入到raft中的结构，在lab3和lab4中都命名为Op</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type Op struct &#123;</span><br><span class="line">	Operation string   &#x2F;&#x2F;&quot;join&quot; &quot;leave&quot; &quot;move&quot; &quot;query&quot;</span><br><span class="line">	Opnum int</span><br><span class="line">	Args	interface&#123;&#125;</span><br><span class="line">	ClientId int64</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要需要说明一个Args，它必须为一个interface{}类型，因为Join，Leave，Move，Query的参数各不相同，只有interface{}才能够接纳它们</p>
<p>然后在各自函数中将需要使用到的变量打包进入Op，所有内容大致相同，唯一不一样的就是Args，要根据传入的参数来打包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func (sm *ShardMaster) Join(args *JoinArgs, reply *JoinReply) &#123;</span><br><span class="line">	Tmp:&#x3D;make(map[int][]string)</span><br><span class="line">	for k,s:&#x3D;range args.Servers&#123;</span><br><span class="line">		Tmp[k]&#x3D;make([]string,len(s))</span><br><span class="line">		copy(Tmp[k],s)</span><br><span class="line">	&#125;</span><br><span class="line">	op:&#x3D;Op&#123;&quot;Join&quot;,args.Opnum,Tmp,args.ClientId&#125;</span><br><span class="line">	tmpReply:&#x3D;sm.StartLog(op)</span><br><span class="line">	reply.WrongLeader&#x3D;tmpReply.WrongLeader</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func (sm *ShardMaster) Leave(args *LeaveArgs, reply *LeaveReply) &#123;</span><br><span class="line">	op:&#x3D;Op&#123;&quot;Leave&quot;,args.Opnum,args.GIDs,args.ClientId&#125;</span><br><span class="line">	tmpReply:&#x3D;sm.StartLog(op)</span><br><span class="line">	reply.WrongLeader&#x3D;tmpReply.WrongLeader</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func (sm *ShardMaster) Move(args *MoveArgs, reply *MoveReply) &#123;</span><br><span class="line">	LogArgs:&#x3D;MoveLogArgs&#123;args.Shard,args.GID&#125;</span><br><span class="line">	op:&#x3D;Op&#123;&quot;Move&quot;,args.Opnum,LogArgs,args.ClientId&#125;</span><br><span class="line">	tmpReply:&#x3D;sm.StartLog(op)</span><br><span class="line">	reply.WrongLeader&#x3D;tmpReply.WrongLeader</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func (sm *ShardMaster) Query(args *QueryArgs, reply *QueryReply) &#123;</span><br><span class="line">	op :&#x3D; Op&#123;&quot;Query&quot;, args.Opnum, args.Num, args.ClientId&#125;</span><br><span class="line">	tmpReply:&#x3D;sm.StartLog(op)</span><br><span class="line">	reply.WrongLeader&#x3D;tmpReply.WrongLeader</span><br><span class="line">	reply.Config&#x3D;tmpReply.Configuration</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在填充了Op结构之后，就将其传入StartLog函数中，这个函数用于统一调用raft.Start函数，StartLog的具体实现基本可以照搬lab3中Get和Append的实现方法。</p>
<p>之后我们需要编写server中的Apply函数，这里的实现也是基本照搬lab3的内容，实际上思路也差不多，但是不同的是在apply的具体执行时，要跳转到对应的RPChandler函数进行具体的处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">if op.Operation&#x3D;&#x3D;&quot;Join&quot;&#123;</span><br><span class="line">	servers:&#x3D;(op.Args).(map[int][]string)</span><br><span class="line">	sm.JoinHandler(servers)</span><br><span class="line">	sm.applyCheck[op.ClientId][op.Opnum]&#x3D;Config&#123;&#125;</span><br><span class="line">	_,ok&#x3D;sm.applyCheck[op.ClientId][op.Opnum]</span><br><span class="line">&#125;else if op.Operation&#x3D;&#x3D;&quot;Leave&quot;&#123;</span><br><span class="line">	GIDs:&#x3D;(op.Args).([]int)</span><br><span class="line">	sm.LeaveHandler(GIDs)</span><br><span class="line">	sm.applyCheck[op.ClientId][op.Opnum]&#x3D;Config&#123;&#125;</span><br><span class="line">&#125;else if op.Operation&#x3D;&#x3D;&quot;Move&quot;&#123;</span><br><span class="line">	moveMsg:&#x3D;(op.Args).(MoveLogArgs)</span><br><span class="line">	sm.MoveHandler(moveMsg)</span><br><span class="line">	sm.applyCheck[op.ClientId][op.Opnum]&#x3D;Config&#123;&#125;</span><br><span class="line">&#125;else if op.Operation&#x3D;&#x3D;&quot;Query&quot;&#123;</span><br><span class="line">	num:&#x3D;(op.Args).(int)</span><br><span class="line">	sm.applyCheck[op.ClientId][op.Opnum]&#x3D;sm.QueryHandler(num)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">	fmt.Println(&quot;unkonwn operation type &quot;+op.Operation)&#125;</span><br><span class="line">&#x2F;&#x2F;Apply中的部分代码</span><br></pre></td></tr></table></figure>

<p>最后我们需要一一编写RPC Handler函数</p>
<p>我们先从简单的开始，首先是QueryHandler，如果传入的参数num为-1或者大于当前最大的config.num，就返回最后一个config，否则就返回对应下标的config</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func (sm *ShardMaster) QueryHandler(num int) Config&#123;</span><br><span class="line">	if num&#x3D;&#x3D;-1 || num&gt;&#x3D;len(sm.configs)&#123;</span><br><span class="line">		return sm.configs[len(sm.configs)-1]</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		return sm.configs[num]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是MoveHandler函数，首先我们创建一个新的config，然后将上一个config的内容全部复制过来，唯一要改动的就是Shard[args.Shard]要改为指定的args.GID</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func (sm *ShardMaster) MoveHandler(args MoveLogArgs)&#123;</span><br><span class="line">	lastConfig:&#x3D;len(sm.configs)-1</span><br><span class="line">	newConfig:&#x3D;Config&#123;&#125;</span><br><span class="line">	newConfig.Num&#x3D;lastConfig+1</span><br><span class="line">	newConfig.Groups&#x3D;make(map[int][]string)</span><br><span class="line">	for k,v:&#x3D;range sm.configs[lastConfig].Groups&#123;</span><br><span class="line">		newConfig.Groups[k]&#x3D;make([]string,len(v))</span><br><span class="line">		copy(newConfig.Groups[k],v)</span><br><span class="line">	&#125;</span><br><span class="line">	for i:&#x3D;0;i&lt;NShards;i++&#123;</span><br><span class="line">		if i&#x3D;&#x3D;args.Shard&#123;</span><br><span class="line">			newConfig.Shards[i]&#x3D;args.GID</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			newConfig.Shards[i]&#x3D;sm.configs[lastConfig].Shards[i]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	sm.configs&#x3D;append(sm.configs,newConfig)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就是比较麻烦的LeaveHandler和JoinHandler，因为它们在更改集群成员的同时，需要对Shards进行再分配，并且要求在移动分片尽量少的情况下保证分片分配的平均。所以我们就需要思考对应的分片分配策略</p>
<p><strong>LeaveHandler</strong></p>
<p>1.首先将确定要保留的Group移到新的config中，这些保留的Group所维护的分片不应改变（尽量少移动分片），同时将这些Group计入remainGroupCircle数组（gid数组）中，并使用remainShard（gid-&gt; shard num) 记录它们现在维护的分片数量</p>
<p>2.根据remainShard的值从小到大给remainGroupCircle数组排序，然后将被移除的Group所维护的分片按照remainGroupCircle中的顺序循环分配给保留的Group们</p>
<p>稍微解释一下第二个步骤，由于我们确定上一次配置中的分片分配是平均的，所以保留的Group们所负责的分片数量应该是平均的，那么我们只需要将剩余的分片也平均分配就行了。</p>
<p>但是这里的平均只是相对的，对于10个分片，我们要将它分配给4个Group，那么2（gid100)，2(gid101)，3(gid102)，3(gid103)就是一种较为平均的分配方式，假设gid100退出集群，那么为了维持平均，我们不应该将这两个分片分给gid102和gid103，这将造成2（gid101），4（gid102），4（gid103）这种不平均的局面，而应该优先考虑把分片分配给分配数量最少的gid101，这也是为什么在分配前要根据remainShard排序的原因</p>
<p><strong>JoinHandler</strong></p>
<p>1.将新加入的Groups和保留的Groups一起加入新集群，同时记录新加入的Group个数newGroupnum以及保留的Group个数remainGroupnum</p>
<p>2.计算每个Group现在负责的分片数并保留到数组remainShard（gid-&gt;shard num)，计算出在新的配置中每个集群应负责的分片数量assignShards（只能整除），以及在计算assignShards中由于整除而被“漏网”的分片数leftShards</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assignShards:&#x3D;NShards&#x2F;(remainGroupnum+newGroupnum)</span><br><span class="line">leftShards:&#x3D;NShards-assignShards*(remainGroupnum+newGroupnum)</span><br></pre></td></tr></table></figure>

<p>3.用remainShard减去assignShards</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;这段代码与我的实际代码顺序不太一样，但是思路相同</span><br><span class="line">for k,v:&#x3D;range sm.configs[lastConfig].Groups&#123;</span><br><span class="line">   remainShard[k]-&#x3D;assignShards</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样remainShards的意思就转变为每个Group要分发给新Group的分片数，但这还不准确，还有leftShards要处理，为了实现移动尽量少的分片，所以leftShards我们就保留在旧Group上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;根据remainShard逆序排列remainGroup，表示分出分片多的Group应该优先减少分发数</span><br><span class="line"></span><br><span class="line">sort(remainGroup,remainShard,false)</span><br><span class="line">ptr&#x3D;0</span><br><span class="line">for leftShards&gt;0&#123;</span><br><span class="line">	remainShard[remainGroup[ptr]]--</span><br><span class="line">&#x2F;&#x2F;每次自减表示要分出的分片减少1个</span><br><span class="line">	ptr&#x3D;(ptr+1)%len(remainGroup)</span><br><span class="line">	leftShards--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.每个旧Group根据remainShard为新Group循环分发分片，同时也将自己维护的分片信息写入新的配置中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for i:&#x3D;0;i&lt;NShards;i++&#123;</span><br><span class="line">	if remainShard[sm.configs[lastConfig].Shards[i]]&gt;0 &amp;&amp; assignShards&gt;0&#123;  &#x2F;&#x2F;为新Group分发分片</span><br><span class="line">		newConfig.Shards[i]&#x3D;newGroup[circlePtr]</span><br><span class="line">		circlePtr&#x3D;(circlePtr+1)%newGroupnum</span><br><span class="line">		remainShard[sm.configs[lastConfig].Shards[i]]--</span><br><span class="line">	&#125;else&#123;   &#x2F;&#x2F;将属于旧Group的分片信息搬运到新配置中</span><br><span class="line">	        newConfig.Shards[i]&#x3D;sm.configs[lastConfig].Shards[i]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此为止，lab4A的内容就结束啦，lab4A的难度还是较低的，因为很多地方的实现都可以仿照lab3A来做，唯一需要思考的应该只有Join和Leave的分片分配策略，接下来我们就要进去6.824的最后一部分lab4B，大家也要做好心理准备哈，4B的难度可就不像4A这么友善了（我太菜了- -</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/10/mit-6-824-lab3b-kvraft/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="wwow">
      <meta itemprop="description" content="努力不一定会成功，但不努力真的很舒服">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wwow's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/10/mit-6-824-lab3b-kvraft/" class="post-title-link" itemprop="url">MIT-6.824-lab3B-kvraft</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-10 10:45:39" itemprop="dateCreated datePublished" datetime="2020-04-10T10:45:39+08:00">2020-04-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-30 12:00:35" itemprop="dateModified" datetime="2020-08-30T12:00:35+08:00">2020-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mit6-824/" itemprop="url" rel="index"><span itemprop="name">mit6.824</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://github.com/wwow1/MIT-6.824">https://github.com/wwow1/MIT-6.824</a></p>
<p>在lab3B的实验中，我们需要为3A的key-value服务添加日志压缩功能，在lab2C中，为了使server在重启时能够恢复之前的状态，我们对Raft中的几个持久化变量以及log进行了持久化保存，但是随着server的不断运行，其Raft中log的内容也不断增加，这将会导致我们在持久化log内容的时候耗费大量的存储空间。为了改进这一情况，我们需要在kvraft中增加能够持久性保存当前状态的Snapshot，当kvraft的当前状态存入Snapshot后，我们就可以使Raft丢弃快照之前的log达到节省空间的目的。</p>
<p>在lab3B的测试中，将会传入一个MaxRaftState变量，它记录了当前允许的Raft持久化数据的最大值，当Raft持久化数据的容量大于MaxRaftState时，我们的kvraft就需要保存一个快照，并只是Raft丢弃旧的日志条目</p>
<p>这里有一点需要注意的是，在lab3B之前，我们都是使用Slice来保存Raft log的，但是使用Slice无法实现“丢弃旧的日志”这一功能，因为丢弃旧的日志后，新的日志的下标并不会重新从0开始计数，假设当前快照对应的最后一个LogIndex=n，那么下一个传入的log的index应该为n+1。所以在这里，我首先将保存log的容器改为map。</p>
<p>我本来以为将log改为map存储很简单，只需要修改对应的变量就行，但是还是遇到了一些小问题，例如Slice是支持多个线程同步访问的，但是map就不行，所以需要将代码中使用到log的部分加上锁。这里给大家推荐另外一种方法，直接使用sync.Map，这个数据结构会在使用时自动实现上锁的功能，就不需要在每次访问log的时候都去一一加锁。（一开始我也使用了Sync.Map,但是由于当时没弄懂gob.Register，所以在RPC调用的时候，传入的log直接变空值了，于是我就放弃了它- -）</p>
<p>这里特别提醒一下，如果大家使用LastLogIndex=len（rf.log）-1这个句子来得到LastLogIndex的话，那么一定要记得修改，因为换用map，同时加入了discard log功能后，len（rf.log）-1得到的值将小于真实的LastLogIndex。我建议还是使用遍历map的方法.</p>
<p>在完成了将log容器从Slice过度到Map之后，我们就可以开始编写Snapshot的相关代码了</p>
<p><strong>1.Snapshot结构</strong></p>
<p>首先我们需要确认，哪些数据需要被保存在Snapshot中？</p>
<p>既然是通过Snapshot保存状态，那么当前保存的kv.DB信息肯定需要加入其中，然后还需要ApplyNum来保证在重启后不会发生request dup，最后是LastIncludedIndex和LastIncludedTerm保存Snapshot包含的最后一个log的Index和Term，通过这两个信息来指示Raft丢弃旧的log</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type SnapShot struct&#123;</span><br><span class="line">	State map[string]string  &#x2F;&#x2F;key-&gt;value</span><br><span class="line">	ApplyNum map[int64]int   &#x2F;&#x2F;clientId-&gt;opnum</span><br><span class="line">	LastIncludedIndex int</span><br><span class="line">	LastIncludedTerm int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.周期性地检查Raft持久化状态的长度（CheckLogLength)</strong></p>
<p>我使用了一个CheckLogLength的函数来周期性的检测Raft状态的长度，一旦发现Raft状态长度超过了MaxRaftState，就需要保存一个新的Snapshot，需要提醒的就是map的赋值不能直接使用=，而是需要跑一个循环将每一个数据一一进行复制。</p>
<p>还有一个问题就是Snapshot中的LastIncludedIndex和LastIncludedTerm要如何确认？我使用了两个新的变量kv.commitIndex和kv.commitTerm来记录被kvraft apply的最后一个raft log，所以需要在apply()函数中增加代码来更新commitIndex和commitTerm</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if op.Index&gt;kv.commitIndex&#123; &#x2F;&#x2F;in apply()</span><br><span class="line">	kv.commitIndex&#x3D;op.Index</span><br><span class="line">	kv.commitTerm&#x3D;op.Term</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在每次保存Snapshot的时候，就将当前的kv.commitIndex和kv.commitTerm作为LastIncludedIndex和LastIncludeTerm存入新的Snapshot中</p>
<p>在记录完Snapshot后，需要调用Raft中的函数丢弃旧log</p>
<p><strong>3.使用Snapshot恢复状态（RestoreSnapshot）</strong></p>
<p>在Server启动时，我们需要调用一个RestoreSnapshot函数来使用已经保存的Snapshot去恢复kvraft的状态。函数内容也很简单，把Snapshot中的数据解码之后复制给kvraft中对应的变量就行</p>
<p>到此为止，我们在kvraft程序中的修改就大致结束了，然后需要转移到raft中完成剩余的内容</p>
<p><strong>4.Raft根据kvraft提供的信息丢弃旧log（DiscardLog）</strong></p>
<p>由kvraft中的CheckLogLength调用raft中的DiscardLog函数来丢弃旧log</p>
<p>调用者应该需要提供LastIncludedIndex以及LastIncludedTerm，DiscardLog根据LastIncludedIndex对自己的log进行一轮遍历，丢弃所有index&lt;LastIncludedIndex的log，同时在Raft中也需要添加LastIncludedIndex和LastIncludedTerm两个变量（具体用处后面会说），说明一下这里更新lastApplied的操作其实是多余的，当时编写的时候没有去除掉。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for i:&#x3D;1;i&lt;&#x3D;LastIncludedIndex;i++&#123; &#x2F;&#x2F;in discardLog()</span><br><span class="line">	_,ok:&#x3D;rf.log[i]</span><br><span class="line">	if ok &#123;</span><br><span class="line">		delete(rf.log,i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">rf.lastIncludedIndex&#x3D;LastIncludedIndex</span><br><span class="line">rf.lastIncludedTerm&#x3D;LastIncludedTerm</span><br><span class="line">rf.lastApplied&#x3D;max(rf.lastApplied,rf.lastIncludedIndex)</span><br><span class="line">rf.persist()</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">type Raft struct &#123;   # new Raft struct</span><br><span class="line">	mu        sync.Mutex   &#x2F;&#x2F; Lock to protect shared access to this peer&#39;s state</span><br><span class="line">	peers     []*labrpc.ClientEnd &#x2F;&#x2F; RPC end points of all peers</span><br><span class="line">	persister *Persister          &#x2F;&#x2F; Object to hold this peer&#39;s persisted state</span><br><span class="line">	me        int                 &#x2F;&#x2F; this peer&#39;s index into peers[]</span><br><span class="line">	applyCh chan ApplyMsg</span><br><span class="line"></span><br><span class="line">	electionTimeout int</span><br><span class="line">	leaderId int</span><br><span class="line">	t *time.Timer</span><br><span class="line">	currentTerm int   &#x2F;&#x2F;persistent state</span><br><span class="line">	votedFor int</span><br><span class="line">	log		map[int]Entry</span><br><span class="line">	&#x2F;&#x2F;lastIncludedTerm int</span><br><span class="line">	lastIncludedIndex int</span><br><span class="line">	lastIncludedTerm int</span><br><span class="line"></span><br><span class="line">	commitIndex int &#x2F;&#x2F;volatile state on all servers</span><br><span class="line">	lastApplied int</span><br><span class="line">	lastLogIndex int</span><br><span class="line">	outdate  bool</span><br><span class="line"></span><br><span class="line">	nextIndex []int&#x2F;&#x2F;valatile state on leader</span><br><span class="line">	matchIndex []int</span><br><span class="line"></span><br><span class="line">	preSnapShotIndex []int</span><br><span class="line">	killCh	chan bool</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在完成了前面4个内容之后，一个基本的日志压缩功能就实现了。但是大家也许会发现一个很严重的问题。假设现在Raft leader有50个log，并且这50个log都被压缩为Snapshot了，那么此时它的rf.log应该是空的，如果这时候有新的follower加入集群或者是某些follower刚才掉线了如今重新加入集群，那么大概率它们的log没有达到这50个，但是我们的leader由于执行了日志压缩，leader的log已经是空的了，那leader肯定没办法通过AppendEntries为这些“掉队”的follower发送它们缺少的log，那这不就会造成不一致了吗？</p>
<p>为了解决这个问题，我们还需要在raft中实现InstallSnapshotRPC，允许leader通过这个RPC发送它的Snapshot给follower，只要follwer直接保存了leader的Snapshot，那么它就不用请求缺失的log，而是直接跳跃到了leader的状态。</p>
<p><strong>5.leader使用InstallSnapshotRPC向follower发送新的Snapshot（InstallSnapshot）</strong></p>
<p>首先定义InstallSnapshotRPC的Args和reply</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type InstallSnapshotArgs struct&#123;</span><br><span class="line">	Term int</span><br><span class="line">	LeaderId int</span><br><span class="line">	LeaderSnapShot []byte</span><br><span class="line">&#125;</span><br><span class="line">type InstallSnapshotReply struct&#123;</span><br><span class="line">	Term int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要内容是leader的Snapshot数据，其次是LeaderId和Term，这几个变量的用处和lab2中的VoteRequestRPC和AppendEntriesRPC中作用一样，这里就不多说了。</p>
<p>然后我们要编写InstallSnapshotRPC handler，首先RPC的标准部分，判断agrs.term和rf.term，然后…….（RPC基本操作）</p>
<p>之后我们需要对LeaderSnapshot进行解码，这里主要是为了得到Snapshot中的leader.LastIncludedIndex（这里的leader是伪代码，表示leader的成员变量，下同），因为InstallSnapshotRPC的调用和实现都是在raft中，没有与上层kvraft进行交互，所以要得到Snapshot中的LastIncludedIndex只能通过直接解码得到。</p>
<p>然后进行一个判断，当前follower的lastIncludedIndex是否小于LeaderSnapshot的（代码中的tmp.LastIncludedIndex）：</p>
<p>如果不小于，说明这个follower已经拥有跟LeaderSnapshot一样新的Snapshot了，那么函数直接返回</p>
<p>如果小于，那么需要使用LeaderSnapshot更新follower的Snapshot，首先将LeaderSnapshot通过ApplyCh传入kvraft层，让kvraft应用这个Snapshot，并且调用SavaSnapshot保存这个新的Snapshot。之后修改自己的LastIncludedIndex和LastIncludedTerm。</p>
<p>我们还需要根据follower当前的log信息决定如何丢弃旧log，首先判断rf.log[tmp.LastIncludedIndex].Term==tmp.LastIncludedTerm（tmp是指解码后的数据），如果条件为true，说明对于follower而言，它在LastIncludedIndex之前的log都是正确的，那么只需要丢弃在这之前的log就行；如果条件为false，说明不能保证LastIncludedIndex之前，甚至这之后的log是否正确，那么旧需要丢弃全部的log。如果需要丢弃全部log，我们也需要使用LastIncludedIndex来修改rf.lastLogIndex和rf.commitIndex</p>
<p>最后需要修改lastApplied的信息，这一点比较重要，更新了Snapshot相当于整个follower apply了所有LastIncludedIndex之前的log。反之不修改lastApplied的话，下一次apply的时候会apply nil（因为对应下标的log是空的）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;RPC handler的主要部分</span><br><span class="line"></span><br><span class="line">if rf.lastIncludedIndex&lt;tmp.LastIncludedIndex&#123;</span><br><span class="line">&#x2F;&#x2F;replace the old snapshot and apply the snapshot to kvraft</span><br><span class="line">	rf.applyCh&lt;-ApplyMsg&#123;tmp.LastIncludedIndex,nil,tmp.LastIncludedTerm,true,args.LeaderSnapShot&#125;</span><br><span class="line">	rf.persister.SaveSnapshot(args.LeaderSnapShot)</span><br><span class="line">	rf.mu.Lock()</span><br><span class="line">	rf.lastIncludedIndex&#x3D;tmp.LastIncludedIndex</span><br><span class="line">	rf.lastIncludedTerm&#x3D;tmp.LastIncludedTerm</span><br><span class="line">	if rf.log[tmp.LastIncludedIndex].Term&#x3D;&#x3D;tmp.LastIncludedTerm&#123;</span><br><span class="line">		fmt.Printf(&quot;%v clear log before %v\n&quot;,rf.me,tmp.LastIncludedIndex)</span><br><span class="line">		for i:&#x3D;1;i&lt;&#x3D;tmp.LastIncludedIndex;i++&#123;</span><br><span class="line">			_,ok:&#x3D;rf.log[i]</span><br><span class="line">			if ok &#123;</span><br><span class="line">				delete(rf.log,i)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		fmt.Printf(&quot;%v clear all log entries\nlastIncludedIndex&#x3D;%v\n&quot;,rf.me,tmp.LastIncludedIndex)</span><br><span class="line">		rf.log&#x3D;make(map[int]Entry)</span><br><span class="line">		rf.log[0]&#x3D;Entry&#123;-1,0&#125;</span><br><span class="line">		rf.lastLogIndex&#x3D;tmp.LastIncludedIndex</span><br><span class="line">		rf.commitIndex&#x3D;tmp.LastIncludedIndex</span><br><span class="line">	&#125;</span><br><span class="line">	rf.persist()</span><br><span class="line">	rf.mu.Unlock()</span><br><span class="line">	rf.lastApplied&#x3D;max(tmp.LastIncludedIndex,rf.lastApplied)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6.决定发送InstallSnapshotRPC的时机</strong></p>
<p>决定发送InstallSnapshotRPC的时间点非常重要，如果一个follower没有leader.LastIncludedIndex之前的log，但是leader仍然向它发送了AppendEntriesRPC，那么这个follower不会得到中间这一段它缺失的log，但是却会更新它的commitIndex，那么它的applyEntry函数就会更具下标来apply这些缺失的log（也就是nil），造成错误。</p>
<p>根据以上例子我们首先判断知道，如果需要发送InstallSnapshotRPC，那么它一定要在AppendEntriesRPC之前，所以我们首先在Start函数中加入一段发送InstallSnapshotRPC的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在start()中判断是否发送RPC</span><br><span class="line"></span><br><span class="line">if rf.lastIncludedIndex&gt;rf.matchIndex[server]&#123;  &#x2F;&#x2F;install Snapshot</span><br><span class="line">	ok:&#x3D;rf.sendInstallSnapshot(server)</span><br><span class="line">	if ok&#123;</span><br><span class="line">		rf.mu.Lock()</span><br><span class="line">		rf.matchIndex[server]&#x3D;max(rf.lastIncludedIndex,rf.matchIndex[server])</span><br><span class="line">		rf.nextIndex[server]&#x3D;max(rf.lastIncludedIndex+1,rf.nextIndex[server])</span><br><span class="line">		rf.mu.Unlock()</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于leader而言，它并不能准确的知道每个follwer log的具体情况，那么就使用matchIndex来作为follower log的更新情况，如果leader.lastIncludedIndex&gt;leader.matchIndex[server]，那么说明这个follower需要更新Snapshot，那么就对它发送InstallSnapshot，如果RPC成功那么就需要修改对应的matchIndex和nextIndex。 如果RPC失败，那么我们就应该直接返回，而不应该向下走，否则会导致apply nil（上面提到过这种情况）</p>
<p>在Start添加了InstallSnapshotRPC后，这里还有一点不足，就是如果上层的kvraft没有新的请求，在Start不被调用时，follower就无法通过leader的InstallSnapshotRPC在更新自己，所以我决定在HeartBeat中也加入发送InstallSnapshotRPC的判断。（程序段内容同上）</p>
<p><strong>7.kvraft应用被apply的Snapshot</strong></p>
<p>在InstallSnapshot中我们将新的Snapshot传入applyCh，那么在kvraft处，也需要编写函数来处理这个请求。由于在ApplyMsg中有一个UseSnapshot的bool量来标识当前请求是否是Snapshot，所以我们只需要在kvraft的apply()函数处增加一处判断和对应的处理程序就行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;server中apply Snapshot</span><br><span class="line">if op.UseSnapshot&#x3D;&#x3D;true&#123;  </span><br><span class="line">	fmt.Printf(&quot;useSnapShot index:%v\n&quot;,op.Index)</span><br><span class="line">	_&#x3D;kv.RestoreSnapShot(op.Snapshot)</span><br><span class="line">	continue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在apply Snapshot的时候想到了一个问题，从raft apply的Snapshot是否一定要调用RestoreSnapshot？ 假如当前kvraft的状态更新，那么应用了这个Snapshot不就出错了吗？虽然可以知道一开始Leader发送InstallSnapshotRPC的时候就是认为这个follower不含有该Snapshot对应的log，但是这个想法也许并不准确（根据matchIndex来判断是否发送RPC），所以为了防止应用Snapshot出错，我又在RestoreSnapshot中增加了一层条件保护</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;kvraft：RestoreSnapshot中的条件保护</span><br><span class="line">if kv.commitIndex&gt;tmp.LastIncludedIndex&#123;</span><br><span class="line">	return false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们前面提到了kvraft中的commitIndex指的是已经应用的log Index，那么如果它的值大于Snapshot中的LastIncludedIndex，就说明当前kvraft的状态比Snapshot中的状态更新。到这里</p>
<p><strong>8.对原有raft代码的修改</strong></p>
<p>完成了以上步骤之后，看似已经完成了lab3B，其实不然，真正的debug之路才刚刚开始（心态爆炸），在加入了discard log这一内容之后，我们原有的raft代码将不再适用于此，需要做许多改进和保护，否则根本跑不动= =</p>
<p>首先是对RequestVoteRPC的修改</p>
<p>我们知道，在RequestVoteRPC中，follower向candidate的条件是</p>
<p>1.candidate.lastLogTerm&gt;follower.LastLogTerm</p>
<p>2.candidate.LastLogTerm=follower.LastLogTerm &amp;&amp; candidate.LastLogIndex&gt;=follower.LastLogIndex</p>
<p>这里就需要考虑一种情况，follower或者Candidate的log因为更新Snapshot而被全部清空，那么我们就不能像原来一样使用rf.log[rf.lastLogIndex].Term来得到它们的LastLogTerm，因为这样得到的Term一定为0，这样就会导致出错，在这种情况下正确的做法应该是使用lastIncludedTerm来作为LastLogTerm参与判断（这也是为什么我们在raft中要保存这个变量的原因）</p>
<p>那么在发送RequestVoteRPC之前，就需要对follower传入RPC的LastLogTerm做一个保护</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;发送RequestVoteRPC前，对Candidate.LastLogIndex做保护</span><br><span class="line">if rf.lastIncludedIndex&gt;&#x3D;rf.lastLogIndex&#123;</span><br><span class="line">	lastLogIndex&#x3D;rf.lastIncludedIndex</span><br><span class="line">	lastLogTerm&#x3D;rf.lastIncludedTerm</span><br><span class="line">&#125;else&#123;</span><br><span class="line">	lastLogIndex&#x3D;rf.lastLogIndex</span><br><span class="line">	lastLogTerm&#x3D;rf.log[rf.lastLogIndex].Term</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一方面，在执行RequestVote时，也需要对follower的LastLogIndex做保护</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;效果同上，只是写法略微不同</span><br><span class="line">lastLogTerm:&#x3D;max(rf.log[rf.lastLogIndex].Term,rf.lastIncludedTerm) </span><br></pre></td></tr></table></figure>

<p>然后是对AppendEntriesRPC的修改</p>
<p>首先是AppendEntries中的一致性判断，一个leader在刚上位时，它的matchIndex[all]=0，但其他follower的log大概率不是空的（也许经过更新Snapshot的方法导致log变空，但它的新log下标并不是重新从1开始），那么Leader发送的AppendEntries中PrevLogIndex=1；假设follower经历了一次Snapshot，它的log中只保存了index&gt;10的log，那么按照之前的做法，我们会得到follower.log[1].Term=0（因为follower下标为1的log已经被丢弃了），这时leader会认为这个follower的日志跟自己的不一致，那么就引发了错误（这会造成死循环，因为leader不存在term=0的log，它们永远不会匹配成功）</p>
<p>为了解决这种情况，我们应该要在AppendEntriesRPC的一致性判断中加入一个条件。</p>
<p>即如果args.PrevLogIndex&lt;rf.lastIncludedIndex，那么就应当认为这个follower在PrevLogIndex之前的log全部与leader一致（保存为Snapshot的log的一致性已经被确认过了）</p>
<p>在完成了AppendEntries的一致性判断后，我们还需要更改prevLogIndex，否则后续的Append过程会由于 rf.log[prevLogIndex+1].Term≠leader.log[prevLogIndex,导致follower的log被全部清空，所以在执行append之前需要修改一下prevLogIndex</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;确保在后续append过程中，不会有空log参与判断</span><br><span class="line">prevLogIndex:&#x3D;max(args.PrevLogIndex,max(rf.lastIncludedIndex,args.LeaderLastIncludedIndex))</span><br></pre></td></tr></table></figure>

<p>在完成以上修改后，我们发现一个共性，那就是这些问题都是由于更新Snapshot时丢弃了旧Log，但raft仍然使用discardLog.Term，导致出错。</p>
<p>那么我们是不是想一些更简单的做法，比如在一个新的leader上任时，使它的所有<strong>matchIndex=leader.LastIncludedIndex</strong>，这样传入AppendEntriesRPC的prevLogIndex对应的log就不会是空值了。</p>
<p>到这里，lab3B的解析终于结束了，事实我在整个lab中，花费在lab3B的时间应该是最多的（一部分原因是因为那段时间划水严重），不断的debug，每天看着满屏的日志信息都头大，但是最终还是把遇到的bug一个个解决掉了（可能？），建议大家在遇到头大的bug的时候不要硬刚，可以做点其他事情（无限活力！！！）放松一下，不然很容易陷入焦躁，但是却完全改不出bug的困境中。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="wwow"
      src="/uploads/avatar.png">
  <p class="site-author-name" itemprop="name">wwow</p>
  <div class="site-description" itemprop="description">努力不一定会成功，但不努力真的很舒服</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wwow</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
